{"version":3,"file":"photon.es.js","sources":["../src/core/maker.ts","../src/core/angle.ts","../src/core/units.ts","../src/core/equal.ts","../src/core/measure-minimal.ts","../src/core/collect.ts","../src/core/chain.ts","../src/models/BezierCurve-esm.ts","../src/core/model.ts","../src/core/path.ts","../src/core/intersect.ts","../src/core/solvers.ts","../src/core/measure.ts","../src/core/point.ts","../src/core/paths.ts","../src/models/ConnectTheDots.ts","../src/models/Holes.ts","../src/models/Rectangle.ts","../src/models/Square.ts","../src/models/Polygon.ts","../src/models/Ring.ts","../src/models/Star.ts","../src/models/Dome.ts","../src/models/BoltCircle.ts","../src/models/BoltRectangle.ts","../src/models/RoundRectangle.ts","../src/models/Oval.ts","../src/models/Slot.ts","../src/models/SCurve.ts","../src/models/Dogbone.ts","../src/models/Belt.ts","../src/models/OvalArc.ts","../src/models/Ellipse.ts","../src/core/break.ts","../src/core/boolean-utils.ts","../src/core/combine.ts","../src/models/Text.ts","../src/core/functional.ts","../src/core/exporter.ts","../src/core/xml.ts","../src/core/svg-helpers.ts","../src/core/importer.ts","../src/core/svg-esm.ts","../src/core/fillet-core.ts","../src/core/fillet-path.ts","../src/core/fillet-chain.ts","../src/core/deadend.ts","../src/core/dxf.ts","../src/core/pdf-esm.ts","../src/core/openjscad-esm.ts","../src/core/layout.ts","../src/index.ts"],"sourcesContent":["/**\n * Root module for Photon.\n */\nimport { IModel, IPath, IPoint, IPathLine, IPathCircle, IPathArc, IPathArcInBezierCurve } from './schema.js';\n\n/** Version info */\nexport const version = 'debug';\n\n/** Enumeration of environment types. */\nexport const environmentTypes = {\n    BrowserUI: 'browser',\n    NodeJs: 'node',\n    WebWorker: 'worker',\n    Unknown: 'unknown'\n} as const;\n\nconst EPSILON = Number.EPSILON || Math.pow(2, -52);\n\nfunction tryEval(name: string) {\n    try {\n        const value = eval(name);\n        return value;\n    }\n    catch (e) { }\n    return;\n}\n\nfunction detectEnvironment() {\n    if (tryEval('WorkerGlobalScope') && tryEval('self')) {\n        return environmentTypes.WebWorker;\n    }\n    if (tryEval('window') && tryEval('document')) {\n        return environmentTypes.BrowserUI;\n    }\n    //put node last since packagers usually add shims for it\n    if (tryEval('global') && tryEval('process')) {\n        return environmentTypes.NodeJs;\n    }\n    return environmentTypes.Unknown;\n}\n\n/** Current execution environment type, should be one of environmentTypes. */\nexport const environment = detectEnvironment();\n\n/** String-based enumeration of unit types. */\nexport const unitType = {\n    Centimeter: 'cm',\n    Foot: 'foot',\n    Inch: 'inch',\n    Meter: 'm',\n    Millimeter: 'mm'\n} as const;\n\nfunction split(s: string, char: string) {\n    const p = s.indexOf(char);\n    if (p < 0) {\n        return [s];\n    } else if (p > 0) {\n        return [s.substr(0, p), s.substr(p + 1)];\n    } else {\n        return ['', s];\n    }\n}\n\n/** Split a decimal into its whole and fractional parts as strings. */\nexport function splitDecimal(n: number) {\n    let s = n.toString();\n    if (s.indexOf('e') > 0) {\n        s = n.toFixed(20).match(/.*[^(0+$)]/)[0];\n    }\n    return split(s, '.');\n}\n\n/** Numeric rounding */\nexport function round(n: number, accuracy = .0000001): number {\n    if (n % 1 === 0) return n;\n    const temp = 1 / accuracy;\n    return Math.round((n + EPSILON) * temp) / temp;\n}\n\n/** Create a string representation of a route array. */\nexport function createRouteKey(route: string[]) {\n    const converted: string[] = [];\n    for (let i = 0; i < route.length; i++) {\n        const element = route[i];\n        const newElement = i % 2 === 0 ? (i > 0 ? '.' : '') + element : JSON.stringify([element]);\n        converted.push(newElement);\n    }\n    return converted.join('');\n}\n\n/** Travel along a route inside of a model to extract a specific node in its tree. */\nexport function travel(modelContext: IModel, route: string | string[]) {\n    if (!modelContext || !route) return null;\n    const routeArray = Array.isArray(route) ? route : JSON.parse(route);\n    const props = routeArray.slice();\n    let ref: any = modelContext;\n    let origin = modelContext.origin || [0, 0];\n    while (props.length) {\n        const prop = props.shift();\n        ref = ref[prop];\n        if (!ref) return null;\n        // TEMP: point.add will be available after point.ts is converted\n        // if (ref.origin && props.length) {\n        //     origin = point.add(origin, ref.origin);\n        // }\n    }\n    return {\n        result: ref as IPath | IModel,\n        offset: origin\n    };\n}\n\n/** Clone an object. */\nexport function cloneObject<T>(objectToClone: T): T {\n    const anyGlobal: any = globalThis as any;\n    if (typeof anyGlobal.structuredClone === 'function') {\n        return anyGlobal.structuredClone(objectToClone);\n    }\n    return JSON.parse(JSON.stringify(objectToClone));\n}\n\n/** Copy the properties from one object to another object. */\nexport function extendObject(target: any, other: any) {\n    if (target && other) {\n        for (const key in other) {\n            if (typeof other[key] !== 'undefined') {\n                target[key] = other[key];\n            }\n        }\n    }\n    return target;\n}\n\n/** Test to see if a variable is a function. */\nexport function isFunction(value: any): boolean {\n    return typeof value === 'function';\n}\n\n/** Test to see if a variable is a number. */\nexport function isNumber(value: any): boolean {\n    return typeof value === 'number';\n}\n\n/** Test to see if a variable is an object. */\nexport function isObject(value: any): boolean {\n    return typeof value === 'object';\n}\n\n/** Test to see if an object implements the required properties of a point. */\nexport function isPoint(item: any) {\n    return item && Array.isArray(item) && (item as Array<number>).length == 2 && isNumber(item[0]) && isNumber(item[1]);\n}\n\n/** A measurement of extents, the high and low points. */\nexport interface IMeasure {\n    low: IPoint;\n    high: IPoint;\n}\n\n/** A measurement of extents, with a center point. */\nexport interface IMeasureWithCenter extends IMeasure {\n    center: IPoint;\n    width: number;\n    height: number;\n}\n\n/** A map of measurements. */\nexport interface IMeasureMap {\n    [key: string]: IMeasure;\n}\n\n/** A path that was removed in a combine operation. */\nexport interface IPathRemoved extends IPath {\n    reason: string;\n    routeKey: string;\n}\n\n/** Options to pass to measure.isPointInsideModel(). */\nexport interface IMeasurePointInsideOptions {\n    farPoint?: IPoint;\n    measureAtlas?: any; // measure.Atlas - typed as any to avoid circular dependency\n    out_intersectionPoints?: IPoint[];\n}\n\n/** Test to see if an object implements the required properties of a path. */\nexport function isPath(item: any): boolean {\n    return item && (item as IPath).type && isPoint((item as IPath).origin);\n}\n\n/** Test to see if an object implements the required properties of a line. */\nexport function isPathLine(item: any): boolean {\n    return isPath(item) && (<IPath>item).type == 'line' && isPoint((<IPathLine>item).end);\n}\n\n/** Test to see if an object implements the required properties of a circle. */\nexport function isPathCircle(item: any): boolean {\n    return isPath(item) && (<IPath>item).type == 'circle' && isNumber((<IPathCircle>item).radius);\n}\n\n/** Test to see if an object implements the required properties of an arc. */\nexport function isPathArc(item: any): boolean {\n    return isPath(item) && (<IPath>item).type == 'arc' && isNumber((<IPathArc>item).radius) && isNumber((<IPathArc>item).startAngle) && isNumber((<IPathArc>item).endAngle);\n}\n\n/** Test to see if an object implements the required properties of an arc in a bezier curve. */\nexport function isPathArcInBezierCurve(item: any): boolean {\n    return isPathArc(item) && isObject((<IPathArcInBezierCurve>item).bezierData) && isNumber((<IPathArcInBezierCurve>item).bezierData.startT) && isNumber((<IPathArcInBezierCurve>item).bezierData.endT);\n}\n\n/** String-based enumeration of all paths types. */\nexport const pathType = {\n    Line: \"line\",\n    Circle: \"circle\",\n    Arc: \"arc\",\n    BezierSeed: \"bezier-seed\"\n} as const;\n\n/** Slope and y-intercept of a line. */\nexport interface ISlope {\n    hasSlope: boolean;\n    slope?: number;\n    line: IPathLine;\n    yIntercept?: number;\n}\n\n/** Options to pass to path.intersection() */\nexport interface IPathIntersectionBaseOptions {\n    excludeTangents?: boolean;\n    out_AreOverlapped?: boolean;\n}\n\n    /**\n     * Options to pass to path.intersection()\n     */\n    export interface IPathIntersectionOptions extends IPathIntersectionBaseOptions {\n\n        /**\n         * Optional boolean to only return deep intersections, i.e. not on an end point or tangent.\n         */\n        path1Offset?: IPoint;\n\n        /**\n         * Optional output variable which will be set to true if the paths are overlapped.\n         */\n        path2Offset?: IPoint;\n    }\n\n    /**\n     * An intersection of two paths.\n     */\n    export interface IPathIntersection {\n\n        /**\n         * Array of points where the two paths intersected. The length of the array may be either 1 or 2 points.\n         */\n        intersectionPoints: IPoint[];\n\n        /**\n         * This Array property will only be defined if the first parameter passed to pathIntersection is either an Arc or a Circle.\n         * It contains the angles of intersection relative to the first path parameter. \n         * The length of the array may be either 1 or 2.\n         */\n        path1Angles?: number[];\n\n        /**\n         * This Array property will only be defined if the second parameter passed to pathIntersection is either an Arc or a Circle.\n         * It contains the angles of intersection relative to the second path parameter. \n         * The length of the array may be either 1 or 2.\n         */\n        path2Angles?: number[];\n    }\n\n    /**\n     * Options when matching points\n     */\n    export interface IPointMatchOptions {\n\n        /**\n         * Max distance to consider two points as the same.\n         */\n        pointMatchingDistance?: number;\n    }\n\n    /**\n     * Options to pass to model.combine.\n     */\n    export interface ICombineOptions extends IPointMatchOptions {\n\n        /**\n         * Flag to remove paths which are not part of a loop.\n         */\n        trimDeadEnds?: boolean;\n\n        /**\n         * Point which is known to be outside of the model.\n         */\n        farPoint?: IPoint;\n\n        /**\n         * Cached measurements for model A.\n         */\n        measureA?: any; // measure.Atlas - typed as any to avoid circular dependency\n\n        /**\n         * Cached measurements for model B.\n         */\n        measureB?: any; // measure.Atlas - typed as any to avoid circular dependency\n\n        /**\n         * Output array of 2 models (corresponding to the input models) containing paths that were deleted in the combination.\n         * Each path will be of type IPathRemoved, which has a .reason property describing why it was removed.\n         */\n        out_deleted?: IModel[];\n    }\n\n    /**\n     * Options to pass to measure.isPointOnPath.\n     */\n    export interface IIsPointOnPathOptions {\n\n        /**\n         * The slope of the line, if applicable. This will be added to the options object if it did not exist.\n         */\n        cachedLineSlope?: ISlope;\n    }\n\n    /**\n     * Options to pass to model.findLoops.\n     */\n    export interface IFindLoopsOptions extends IPointMatchOptions {\n\n        /**\n         * Flag to remove looped paths from the original model.\n         */\n        removeFromOriginal?: boolean;\n    }\n\n    /**\n     * Options to pass to model.simplify()\n     */\n    export interface ISimplifyOptions extends IPointMatchOptions {\n\n        /**\n         * Optional \n         */\n        scalarMatchingDistance?: number;\n\n    }\n\n    /**\n     * A path that may be indicated to \"flow\" in either direction between its endpoints.\n     */\n    export interface IPathDirectional extends IPath {\n\n        /**\n         * The endpoints of the path.\n         */\n        endPoints: IPoint[];\n\n        /**\n         * Path flows forwards or reverse.\n         */\n        reversed?: boolean;\n    }\n\n    //models\n\n    /**\n     * Callback signature for model.walkPaths().\n     */\n    export interface IModelPathCallback {\n        (modelContext: IModel, pathId: string, pathContext: IPath): void;\n    }\n\n    /**\n     * Test to see if an object implements the required properties of a model.\n     */\n    export function isModel(item: any): boolean {\n        return item && (item.paths || item.models);\n    }\n\n    /**\n     * Reference to a path id within a model.\n     */\n    export interface IRefPathIdInModel {\n        modelContext: IModel;\n        pathId: string;\n    }\n\n    /**\n     * A route to either a path or a model, and the absolute offset of it.\n     */\n    export interface IRouteOffset {\n        layer: string;\n        offset: IPoint;\n        route: string[];\n        routeKey: string;\n    }\n\n    /**\n     * A path reference in a walk.\n     */\n    export interface IWalkPath extends IRefPathIdInModel, IRouteOffset {\n        pathContext: IPath;\n    }\n\n    /**\n     * Callback signature for path in model.walk().\n     */\n    export interface IWalkPathCallback {\n        (context: IWalkPath): void;\n    }\n\n    /**\n     * Callback for returning a boolean from an IWalkPath.\n     */\n    export interface IWalkPathBooleanCallback {\n        (context: IWalkPath): boolean;\n    }\n\n    /**\n     * A link in a chain, with direction of flow.\n     */\n    export interface IChainLink {\n\n        /**\n         * Reference to the path.\n         */\n        walkedPath: IWalkPath;\n\n        /**\n         * Path flows forwards or reverse.\n         */\n        reversed: boolean;\n\n        /**\n         * The endpoints of the path, in absolute coords.\n         */\n        endPoints: IPoint[];\n\n        /**\n         * Length of the path.\n         */\n        pathLength: number;\n    }\n\n    /**\n     * A chain of paths which connect end to end.\n     */\n    export interface IChain {\n\n        /**\n         * The links in this chain.\n         */\n        links: IChainLink[];\n\n        /**\n         * Flag if this chain forms a loop end to end.\n         */\n        endless: boolean\n\n        /**\n         * Total length of all paths in the chain.\n         */\n        pathLength: number;\n\n        /**\n         * Chains that are contained within this chain. Populated when chains are found with the 'contain' option \n         */\n        contains?: IChain[]\n    }\n\n    /**\n     * A map of chains by layer.\n     */\n    export interface IChainsMap {\n        [layer: string]: IChain[];\n    }\n\n    /**\n     * Test to see if an object implements the required properties of a chain.\n     * \n     * @param item The item to test.\n     */\n    export function isChain(item: any): boolean {\n        var x = item as IChain;\n        return x && x.links && Array.isArray(x.links) && isNumber(x.pathLength);\n    }\n\n    /**\n     * Callback to model.findChains() with resulting array of chains and unchained paths.\n     */\n    export interface IChainCallback {\n        (chains: IChain[], loose: IWalkPath[], layer: string, ignored?: IWalkPath[]): void;\n    }\n\n    /**\n     * Options to pass to model.findChains.\n     */\n    export interface IFindChainsOptions extends IPointMatchOptions {\n\n        /**\n         * Flag to separate chains by layers.\n         */\n        byLayers?: boolean;\n\n        /**\n         * Flag to not recurse models, look only within current model's immediate paths.\n         */\n        shallow?: boolean;\n\n        /**\n         * Flag to order chains in a heirarchy by their paths being within one another.\n         */\n        contain?: boolean | IContainChainsOptions;\n\n        /**\n         * Flag to flatten BezierCurve arc segments into IPathBezierSeeds.\n         */\n        unifyBeziers?: boolean;\n    }\n\n    /**\n     * Sub-options to pass to model.findChains.contain option.\n     */\n    export interface IContainChainsOptions {\n\n        /**\n         * Flag to alternate direction of contained chains.\n         */\n        alternateDirection?: boolean;\n    }\n\n    /**\n     * Reference to a model within a model.\n     */\n    export interface IRefModelInModel {\n        parentModel: IModel;\n        childId: string;\n        childModel: IModel;\n    }\n\n    /**\n     * A model reference in a walk.\n     */\n    export interface IWalkModel extends IRefModelInModel, IRouteOffset {\n    }\n\n    /**\n     * Callback signature for model.walk().\n     */\n    export interface IWalkModelCallback {\n        (context: IWalkModel): void;\n    }\n\n    /**\n     * Callback signature for model.walk(), which may return false to halt any further walking.\n     */\n    export interface IWalkModelCancellableCallback {\n        (context: IWalkModel): boolean;\n    }\n\n    /**\n     * Options to pass to model.walk().\n     */\n    export interface IWalkOptions {\n\n        /**\n         * Callback for every path in every model.\n         */\n        onPath?: IWalkPathCallback;\n\n        /**\n         * Callback for every child model in every model. Return false to stop walking down further models.\n         */\n        beforeChildWalk?: IWalkModelCancellableCallback;\n\n        /**\n         * Callback for every child model in every model, after all of its children have been walked.\n         */\n        afterChildWalk?: IWalkModelCallback;\n    }\n\n    /**\n     * A hexagon which surrounds a model.\n     */\n    export interface IBoundingHex extends IModel {\n\n        /**\n         * Radius of the hexagon, which is also the length of a side.\n         */\n        radius: number;\n    }\n\n    //kits\n\n    /**\n     * Describes a parameter and its limits.\n     */\n    export interface IMetaParameter {\n\n        /**\n         * Display text of the parameter.\n         */\n        title: string;\n\n        /**\n         * Type of the parameter. Currently supports \"range\".\n         */\n        type: string;\n\n        /**\n         * Optional minimum value of the range.\n         */\n        min?: number;\n\n        /**\n         * Optional maximum value of the range.\n         */\n        max?: number;\n\n        /**\n         * Optional step value between min and max.\n         */\n        step?: number;\n\n        /**\n         * Initial sample value for this parameter.\n         */\n        value: any;\n    }\n\n    /**\n     * An IKit is a model-producing class with some sample parameters. Think of it as a packaged model with instructions on how to best use it.\n     */\n    export interface IKit {\n\n        /**\n         * The constructor. The kit must be \"new-able\" and it must produce an IModel.\n         * It can have any number of any type of parameters.\n         */\n        new(...args: any[]): IModel;\n\n        /**\n         * Attached to the constructor is a property named metaParameters which is an array of IMetaParameter objects.\n         * Each element of the array corresponds to a parameter of the constructor, in order.\n         */\n        metaParameters?: IMetaParameter[];\n\n        /**\n         * Information about this kit, in plain text or markdown format.\n         */\n        notes?: string;\n    }\n\n    //cascades\n    /**\n     * A container that allows a series of functions to be called upon an object.\n     * @deprecated Use pipe() or compose() for new code. This legacy API is provided for backward compatibility.\n     */\n    export interface ICascade {\n\n        /**\n         * The initial context object of the cascade.\n         */\n        $initial: any;\n\n        /**\n         * The current final value of the cascade.\n         */\n        $result: any;\n\n        /**\n         * Use the $original as the $result.\n         */\n        $reset: () => this;\n    }\n\n    /**\n     * Cascade container for Photon operations.\n     * Provides jQuery-style method chaining for legacy code compatibility.\n     * @deprecated Use pipe() or compose() for new code\n     * @private\n     */\n    class Cascade<T> implements ICascade {\n        public $result: any;\n\n        constructor(private _module: any, public $initial: T) {\n            for (const methodName in this._module) this._shadow(methodName);\n            // Clone initial value to prevent mutations\n            this.$result = cloneObject($initial);\n        }\n\n        private _shadow(methodName: string) {\n            this[methodName] = (...args: any[]) => {\n                return this._apply(this._module[methodName], args);\n            };\n        }\n\n        private _apply(fn: Function, carriedArgs: any[]) {\n            const args = [this.$result, ...carriedArgs];\n            this.$result = fn(...args);\n            return this;\n        }\n\n        public $reset() {\n            this.$result = this.$initial;\n            return this;\n        }\n    }\n\n    // Module registry for cascade to avoid circular dependencies\n    const _moduleRegistry: {\n        model?: any;\n        path?: any;\n        point?: any;\n    } = {};\n\n    /**\n     * Register modules for cascade use. Called automatically by index.ts.\n     * @private\n     */\n    export function registerCascadeModules(model: any, path: any, point: any) {\n        _moduleRegistry.model = model;\n        _moduleRegistry.path = path;\n        _moduleRegistry.point = point;\n    }\n\n    /**\n     * Create cascade container for fluent API (LEGACY)\n     * @deprecated Use pipe() or compose() for new code. This legacy API is provided for backward compatibility.\n     * @param context - Model, Path, or Point to wrap\n     * @returns Cascade container with chainable operations\n     */\n    export function $(modelContext: IModel): ICascade;\n    export function $(pathContext: IPath): ICascade;\n    export function $(pointContext: IPoint): ICascade;\n    export function $(context: any): ICascade {\n        if (isModel(context)) {\n            if (!_moduleRegistry.model) {\n                throw new Error('Model module not registered for cascade. This is likely a build or import order issue.');\n            }\n            return new Cascade<IModel>(_moduleRegistry.model, context);\n        } else if (isPath(context)) {\n            if (!_moduleRegistry.path) {\n                throw new Error('Path module not registered for cascade. This is likely a build or import order issue.');\n            }\n            return new Cascade<IPath>(_moduleRegistry.path, context);\n        } else if (isPoint(context)) {\n            if (!_moduleRegistry.point) {\n                throw new Error('Point module not registered for cascade. This is likely a build or import order issue.');\n            }\n            return new Cascade<IPoint>(_moduleRegistry.point, context);\n        }\n        throw new Error('Invalid context for Photon cascade function. Expected Model, Path, or Point.');\n    }\n","import { IPoint, IPathArc, IPathLine, IPath } from './schema.js';\nimport { round, splitDecimal, pathType } from './maker.js';\nimport * as point from './point.js';\n\n// TEMP: These will be available after respective modules are converted\ndeclare const paths: any;\ndeclare const chain: any;\n\nexport interface IChainLink {\n    walkedPath: { pathContext: IPath; };\n    reversed: boolean;\n}\n\nfunction getFractionalPart(n: number) {\n        return splitDecimal(n)[1];\n    }\n\nfunction setFractionalPart(n: number, fractionalPart: string) {\n        if (fractionalPart) {\n            return +(splitDecimal(n)[0] + '.' + fractionalPart);\n        } else {\n            return n;\n        }\n    }\n\nfunction copyFractionalPart(src: number, dest: number) {\n        if ((src < 0 && dest < 0) || (src > 0 && dest > 0)) {\n            return setFractionalPart(dest, getFractionalPart(src));\n        }\n        return dest;\n    }\n\n/** Ensures an angle is not greater than 360 */\nexport function noRevolutions(angleInDegrees: number) {\n        const revolutions = Math.floor(angleInDegrees / 360);\n        if (revolutions === 0) return angleInDegrees;\n        const a = angleInDegrees - (360 * revolutions);\n        return copyFractionalPart(angleInDegrees, a);\n    }\n\n/** Convert an angle from degrees to radians. */\nexport function toRadians(angleInDegrees: number): number {\n        return noRevolutions(angleInDegrees) * Math.PI / 180.0;\n    }\n\n/** Convert an angle from radians to degrees. */\nexport function toDegrees(angleInRadians: number): number {\n        return angleInRadians * 180.0 / Math.PI;\n    }\n\n/** Get an arc's end angle, ensured to be greater than its start angle. */\nexport function ofArcEnd(arc: IPathArc): number {\n        //compensate for values past zero. This allows easy compute of total angle size.\n        //for example 0 = 360\n        if (arc.endAngle < arc.startAngle) {\n            const revolutions = Math.ceil((arc.startAngle - arc.endAngle) / 360);\n            const a = revolutions * 360 + arc.endAngle;\n            return copyFractionalPart(arc.endAngle, a)\n        }\n        return arc.endAngle;\n    }\n\n/** Get the angle in the middle of an arc's start and end angles. */\nexport function ofArcMiddle(arc: IPathArc, ratio = .5): number {\n        return arc.startAngle + ofArcSpan(arc) * ratio;\n    }\n\n/** Total angle of an arc between its start and end angles. */\nexport function ofArcSpan(arc: IPathArc): number {\n    const endAngle = ofArcEnd(arc);\n    const a = endAngle - arc.startAngle;\n        if (round(a) > 360) {\n            return noRevolutions(a);\n        } else {\n            return a;\n        }\n    }\n\n/** Angle of a line path. */\nexport function ofLineInDegrees(line: IPathLine) {\n        return noRevolutions(toDegrees(ofPointInRadians(line.origin, line.end)));\n    }\n\n/** Angle of a line through a point, in degrees. */\nexport function ofPointInDegrees(origin: IPoint, pointToFindAngle: IPoint): number {\n        return toDegrees(ofPointInRadians(origin, pointToFindAngle));\n    }\n\n/** Angle of a line through a point, in radians. */\nexport function ofPointInRadians(origin: IPoint, pointToFindAngle: IPoint): number {\n    const d = point.subtract(pointToFindAngle, origin);\n    const x = d[0];\n    const y = d[1];\n        return Math.atan2(-y, -x) + Math.PI;\n    }\n\n/** Mirror an angle on either or both x and y axes. */\nexport function mirror(angleInDegrees: number, mirrorX: boolean, mirrorY: boolean): number {\n\n        if (mirrorY) {\n            angleInDegrees = 360 - angleInDegrees;\n        }\n\n        if (mirrorX) {\n            angleInDegrees = (angleInDegrees < 180 ? 180 : 540) - angleInDegrees;\n        }\n\n        return angleInDegrees;\n    }\n\nconst linkLineMap: { [pathType: string]: (p: IPath, first: boolean, reversed: boolean) => IPathLine } = {};\n\nlinkLineMap[pathType.Arc] = (arc: IPathArc, first: boolean, reversed: boolean) => {\n        const fromEnd = first != reversed;\n        const angleToRotate = fromEnd ? arc.endAngle - 90 : arc.startAngle + 90;\n        const origin = point.fromArc(arc)[fromEnd ? 1 : 0];\n        const end = point.rotate(point.add(origin, [arc.radius, 0]), angleToRotate, origin);\n        return new paths.Line(first ? [end, origin] : [origin, end]);\n    };\n\nlinkLineMap[pathType.Line] = (line: IPathLine, first: boolean, reversed: boolean) => {\n        return reversed ? new paths.Line(line.end, line.origin) : line;\n    };\n\nfunction getLinkLine(chainLink: IChainLink, first: boolean) {\n        if (chainLink) {\n            const p = chainLink.walkedPath.pathContext;\n            const fn = linkLineMap[p.type];\n            if (fn) {\n                return fn(p, first, chainLink.reversed);\n            }\n        }\n    }\n\n/** Get the angle of a joint between 2 chain links. */\nexport function ofChainLinkJoint(linkA: IChainLink, linkB: IChainLink) {\n    if (arguments.length < 2) return null;\n    const linkLines: IPathLine[] = [linkA, linkB].map((link, i) => getLinkLine(link, i === 0));\n    let result = noRevolutions(ofLineInDegrees(linkLines[1]) - ofLineInDegrees(linkLines[0]));\n    if (result > 180) result -= 360;\n    return result;\n}\n","import { unitType } from './maker.js';\n\n/** The base type is arbitrary. Other conversions are then based off of this. */\nconst base = unitType.Millimeter;\n\n/** Table of conversions. Lazy load upon first conversion. */\nlet table: { [unitType: string]: { [unitType: string]: number }; };\n\n/** Initialize all known conversions. */\nfunction init() {\n    addBaseConversion(unitType.Centimeter, 10);\n    addBaseConversion(unitType.Meter, 1000);\n    addBaseConversion(unitType.Inch, 25.4);\n    addBaseConversion(unitType.Foot, 25.4 * 12);\n}\n\n/** Add a conversion, and its inversion. */\nfunction addConversion(srcUnitType: string, destUnitType: string, value: number) {\n    const row = (unitType: string) => {\n        if (!table[unitType]) {\n            table[unitType] = {};\n        }\n        return table[unitType];\n    };\n\n    row(srcUnitType)[destUnitType] = value;\n    row(destUnitType)[srcUnitType] = 1 / value;\n}\n\n/** Add a conversion of the base unit. */\nfunction addBaseConversion(destUnitType: string, value: number) {\n    addConversion(destUnitType, base, value);\n}\n\n/** Get a conversion ratio between a source unit and a destination unit. */\nexport function conversionScale(srcUnitType: string, destUnitType: string): number {\n    if (srcUnitType == destUnitType) {\n        return 1;\n    }\n\n    // Lazy load the table with initial conversions\n    if (!table) {\n        table = {};\n        init();\n    }\n\n    // Look for a cached conversion in the table\n    if (!table[srcUnitType][destUnitType]) {\n        // Create a new conversion and cache it in the table\n        addConversion(srcUnitType, destUnitType, table[srcUnitType][base] * table[base][destUnitType]);\n    }\n\n    return table[srcUnitType] && table[srcUnitType][destUnitType];\n}\n\n/** Check to see if unit type is a valid Maker.js unit. */\nexport function isValidUnit(tryUnit: string) {\n    for (const id in unitType) {\n        if (unitType[id] == tryUnit) {\n            return true;\n        }\n    }\n    return false;\n}\n","import { IPoint, IPath, IPathLine, IPathCircle, IPathArc } from './schema.js';\nimport { round, pathType } from './maker.js';\nimport type { ISlope, IIsPointOnPathOptions } from './maker.js';\nimport * as angle from './angle.js';\nimport * as path from './path.js';\n\n// TEMP: These will be available after respective modules are converted\ndeclare const measure: any;\n\n/** Find out if two angles are equal. */\nexport function isAngleEqual(angleA: number, angleB: number, accuracy: number = .0001) {\n    const a = angle.noRevolutions(angleA);\n    const b = angle.noRevolutions(angleB);\n    const d = angle.noRevolutions(round(b - a, accuracy));\n    return d == 0;\n}\n\ninterface IPathAreEqualMap {\n    [type: string]: (pathA: IPath, pathB: IPath, withinPointDistance?: number) => boolean;\n}\n\nconst pathAreEqualMap: IPathAreEqualMap = {};\n\npathAreEqualMap[pathType.Line] = (lineA: IPathLine, lineB: IPathLine, withinPointDistance?: number): boolean => {\n    return (isPointEqual(lineA.origin, lineB.origin, withinPointDistance) && isPointEqual(lineA.end, lineB.end, withinPointDistance))\n        || (isPointEqual(lineA.origin, lineB.end, withinPointDistance) && isPointEqual(lineA.end, lineB.origin, withinPointDistance));\n};\n\npathAreEqualMap[pathType.Circle] = (circleA: IPathCircle, circleB: IPathCircle, withinPointDistance): boolean => {\n    return isPointEqual(circleA.origin, circleB.origin, withinPointDistance) && circleA.radius == circleB.radius;\n};\n\npathAreEqualMap[pathType.Arc] = (arcA: IPathArc, arcB: IPathArc, withinPointDistance): boolean => {\n    return pathAreEqualMap[pathType.Circle](arcA, arcB, withinPointDistance) && isAngleEqual(arcA.startAngle, arcB.startAngle) && isAngleEqual(arcA.endAngle, arcB.endAngle);\n};\n\n/** Find out if two paths are equal. */\nexport function isPathEqual(pathA: IPath, pathB: IPath, withinPointDistance?: number, pathAOffset?: IPoint, pathBOffset?: IPoint): boolean {\n    let result = false;\n\n    if (pathA.type == pathB.type) {\n        const fn = pathAreEqualMap[pathA.type];\n        if (fn) {\n            const getResult = () => {\n                result = fn(pathA, pathB, withinPointDistance);\n            };\n\n            if (pathAOffset || pathBOffset) {\n                path.moveTemporary([pathA, pathB], [pathAOffset, pathBOffset], getResult);\n            } else {\n                getResult();\n            }\n        }\n    }\n\n    return result;\n}\n\n/** Find out if two points are equal. */\nexport function isPointEqual(a: IPoint, b: IPoint, withinDistance?: number): boolean {\n    if (!withinDistance) {\n        return round(a[0] - b[0]) == 0 && round(a[1] - b[1]) == 0;\n    } else {\n        if (!a || !b) return false;\n        const distance = pointDistance(a, b);\n        return distance <= withinDistance;\n    }\n}\n\n/** Point distance calculation. */\nfunction pointDistance(a: IPoint, b: IPoint): number {\n    const dx = b[0] - a[0];\n    const dy = b[1] - a[1];\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\n/** Find out if a point is distinct among an array of points. */\nexport function isPointDistinct(pointToCheck: IPoint, pointArray: IPoint[], withinDistance?: number) {\n    for (let i = 0; i < pointArray.length; i++) {\n        if (isPointEqual(pointArray[i], pointToCheck, withinDistance)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/** Find out if point is on a slope. */\nexport function isPointOnSlope(p: IPoint, slope: ISlope, withinDistance = 0): boolean {\n    if (slope.hasSlope) {\n        // y = mx * b\n        return Math.abs(p[1] - (slope.slope * p[0] + slope.yIntercept)) <= withinDistance;\n    } else {\n        // vertical slope\n        return Math.abs(p[0] - slope.line.origin[0]) <= withinDistance;\n    }\n}\n\n/** Find out if point is on a circle. */\nexport function isPointOnCircle(p: IPoint, circle: IPathCircle, withinDistance = 0): boolean {\n    const d = Math.abs(pointDistance(p, circle.origin) - circle.radius);\n    return d <= withinDistance;\n}\n\nconst onPathMap: { [pathType: string]: (point: IPoint, path: IPath, withinDistance: number, options?: IIsPointOnPathOptions) => boolean } = {};\n\nonPathMap[pathType.Circle] = (p: IPoint, circle: IPathCircle, withinDistance: number) => {\n    return isPointOnCircle(p, circle, withinDistance);\n};\n\nonPathMap[pathType.Arc] = (p: IPoint, arc: IPathArc, withinDistance: number) => {\n    if (onPathMap[pathType.Circle](p, arc, withinDistance)) {\n        const a = angle.ofPointInDegrees(arc.origin, p);\n        return measure.isBetweenArcAngles(a, arc, false);\n    }\n    return false;\n};\n\nonPathMap[pathType.Line] = (p: IPoint, line: IPathLine, withinDistance: number, options: IIsPointOnPathOptions) => {\n    const slope = (options && options.cachedLineSlope) || measure.lineSlope(line);\n    if (options && !options.cachedLineSlope) {\n        options.cachedLineSlope = slope;\n    }\n    return isPointOnSlope(p, slope, withinDistance) && measure.isBetweenPoints(p, line, false);\n};\n\n/** Find out if a point lies on a path. */\nexport function isPointOnPath(pointToCheck: IPoint, onPath: IPath, withinDistance = 0, pathOffset?: IPoint, options?: IIsPointOnPathOptions) {\n    const fn = onPathMap[onPath.type];\n    if (fn) {\n        const offsetPath = pathOffset ? path.clone(onPath, pathOffset) : onPath;\n        return fn(pointToCheck, offsetPath, withinDistance, options);\n    }\n    return false;\n}\n\n/** Check for slope equality. */\nexport function isSlopeEqual(slopeA: ISlope, slopeB: ISlope): boolean {\n    if (!isSlopeParallel(slopeA, slopeB)) return false;\n\n    if (!slopeA.hasSlope && !slopeB.hasSlope) {\n        // lines are both vertical, see if x are the same\n        return round(slopeA.line.origin[0] - slopeB.line.origin[0]) == 0;\n    }\n\n    // lines are parallel, but not vertical\n    const slopes = [slopeA, slopeB];\n    const angles = slopes.map(s => angle.toDegrees(Math.atan(s.slope)));\n    const lines = slopes.map(s => path.clone(s.line)) as IPathLine[];\n    const origin = lines[0].origin;\n\n    lines.forEach((l, i) => path.rotate(l, -angles[i], origin));\n\n    const averageYs = lines.map(l => (l.origin[1] + l.end[1]) / 2);\n    return round(averageYs[0] - averageYs[1], .00001) == 0;\n}\n\n/** Check for parallel slopes. */\nexport function isSlopeParallel(slopeA: ISlope, slopeB: ISlope): boolean {\n    if (!slopeA.hasSlope && !slopeB.hasSlope) {\n        return true;\n    }\n\n    if (slopeA.hasSlope && slopeB.hasSlope && (round(slopeA.slope - slopeB.slope, .00001) == 0)) {\n        // lines are parallel\n        return true;\n    }\n\n    return false;\n}\n","// Minimal measure module with essential functions needed by models\n// This is a temporary file to unblock model conversions\n// Full measure.ts will be converted later with all functions\n\nimport { IPoint, IPath, IPathLine, IPathCircle, IPathArc, IPathBezierSeed, IModel } from './schema.js';\nimport { round, pathType } from './maker.js';\nimport type { IMeasure, IMeasureWithCenter, ISlope } from './maker.js';\nimport * as angle from './angle.js';\nimport * as point from './point.js';\nimport * as path from './path.js';\nimport * as model from './model.js';\nimport { isPointEqual } from './equal.js';\n\n// TEMP: These will be available after full measure.ts conversion\ndeclare const models: any;\n\n/** Measures the distance between two points. */\nexport function pointDistance(a: IPoint, b: IPoint): number {\n    const dx = b[0] - a[0];\n    const dy = b[1] - a[1];\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\n/** Gets the slope of a line. */\nexport function lineSlope(line: IPathLine): ISlope {\n    const dx = line.end[0] - line.origin[0];\n    if (round(dx, .000001) == 0) {\n        return {\n            line: line,\n            hasSlope: false\n        };\n    }\n\n    const dy = line.end[1] - line.origin[1];\n    const slope = dy / dx;\n\n    return {\n        line: line,\n        hasSlope: true,\n        slope: slope,\n        yIntercept: line.origin[1] - (slope * line.origin[0])\n    };\n}\n\n/** Check if a bezier seed has control points on the line slope and between the line endpoints. */\nexport function isBezierSeedLinear(seed: IPathBezierSeed, exclusive?: boolean): boolean {\n    // create a slope from the endpoints\n    const slope = lineSlope(seed);\n\n    // import from equal.ts\n    const isPointOnSlope = (p: IPoint, slope: ISlope, withinDistance = 0): boolean => {\n        if (slope.hasSlope) {\n            return Math.abs(p[1] - (slope.slope * p[0] + slope.yIntercept)) <= withinDistance;\n        } else {\n            return Math.abs(p[0] - slope.line.origin[0]) <= withinDistance;\n        }\n    };\n\n    const isBetweenPoints = (pointInQuestion: IPoint, line: IPathLine, exclusive: boolean): boolean => {\n        let oneDimension = false;\n        for (let i = 2; i--;) {\n            if (round(line.origin[i] - line.end[i], .000001) == 0) {\n                oneDimension = true;\n            } else {\n                const origin_value = round(line.origin[i]);\n                const end_value = round(line.end[i]);\n                if (exclusive) {\n                    if (!isBetween(round(pointInQuestion[i]), origin_value, end_value, exclusive)) {\n                        return false;\n                    }\n                } else {\n                    if (!(round(pointInQuestion[i]) >= Math.min(origin_value, end_value) && round(pointInQuestion[i]) <= Math.max(origin_value, end_value))) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return oneDimension;\n    };\n\n    const isBetween = (valueInQuestion: number, limitA: number, limitB: number, exclusive: boolean): boolean => {\n        if (exclusive) {\n            return Math.min(limitA, limitB) < valueInQuestion && valueInQuestion < Math.max(limitA, limitB);\n        } else {\n            return Math.min(limitA, limitB) <= valueInQuestion && valueInQuestion <= Math.max(limitA, limitB);\n        }\n    };\n\n    for (let i = 0; i < seed.controls.length; i++) {\n        if (!isPointOnSlope(seed.controls[i], slope)) return false;\n        if (!isBetweenPoints(seed.controls[i], seed, exclusive)) return false;\n    }\n\n    return true;\n}\n\ntype IMathMinMax = (a: number, b: number) => number;\n\nfunction getExtremePoint(a: IPoint, b: IPoint, fn: IMathMinMax): IPoint {\n    return [\n        fn(a[0], b[0]),\n        fn(a[1], b[1])\n    ];\n}\n\nconst pathExtentsMap: { [pathType: string]: (pathToMeasure: IPath) => IMeasure } = {};\n\npathExtentsMap[pathType.Line] = (line: IPathLine): IMeasure => {\n    return {\n        low: getExtremePoint(line.origin, line.end, Math.min),\n        high: getExtremePoint(line.origin, line.end, Math.max)\n    };\n};\n\npathExtentsMap[pathType.Circle] = (circle: IPathCircle): IMeasure => {\n    const r = circle.radius;\n    return {\n        low: point.add(circle.origin, [-r, -r]),\n        high: point.add(circle.origin, [r, r])\n    };\n};\n\nconst isBetweenArcAngles = (angleInQuestion: number, arc: IPathArc, exclusive: boolean): boolean => {\n    const startAngle = angle.noRevolutions(arc.startAngle);\n    const span = angle.ofArcSpan(arc);\n    const endAngle = startAngle + span;\n    angleInQuestion = angle.noRevolutions(angleInQuestion);\n\n    if (angleInQuestion < startAngle) {\n        angleInQuestion += 360;\n    }\n\n    const isBetween = (valueInQuestion: number, limitA: number, limitB: number, exclusive: boolean): boolean => {\n        if (exclusive) {\n            return Math.min(limitA, limitB) < valueInQuestion && valueInQuestion < Math.max(limitA, limitB);\n        } else {\n            return Math.min(limitA, limitB) <= valueInQuestion && valueInQuestion <= Math.max(limitA, limitB);\n        }\n    };\n\n    return isBetween(angleInQuestion, startAngle, endAngle, exclusive);\n};\n\npathExtentsMap[pathType.Arc] = (arc: IPathArc): IMeasure => {\n    const r = arc.radius;\n    const arcPoints = point.fromArc(arc);\n\n    const extremeAngle = (xyAngle: number[], value: number, fn: IMathMinMax): IPoint => {\n        const extremePoint = getExtremePoint(arcPoints[0], arcPoints[1], fn);\n\n        for (let i = 2; i--;) {\n            if (isBetweenArcAngles(xyAngle[i], arc, false)) {\n                extremePoint[i] = value + arc.origin[i];\n            }\n        }\n\n        return extremePoint;\n    };\n\n    return {\n        low: extremeAngle([180, 270], -r, Math.min),\n        high: extremeAngle([360, 90], r, Math.max)\n    };\n};\n\n/** Calculates the smallest rectangle which contains a path. */\nexport function pathExtents(pathToMeasure: IPath, addOffset?: IPoint): IMeasure {\n    if (pathToMeasure) {\n        const fn = pathExtentsMap[pathToMeasure.type];\n        if (fn) {\n            const m = fn(pathToMeasure);\n\n            if (addOffset) {\n                m.high = point.add(m.high, addOffset);\n                m.low = point.add(m.low, addOffset);\n            }\n\n            return m;\n        }\n    }\n\n    return { low: null, high: null };\n}\n\nconst pathLengthMap: { [pathType: string]: (pathToMeasure: IPath) => number } = {};\n\npathLengthMap[pathType.Line] = (line: IPathLine) => {\n    return pointDistance(line.origin, line.end);\n};\n\npathLengthMap[pathType.Circle] = (circle: IPathCircle) => {\n    return 2 * Math.PI * circle.radius;\n};\n\npathLengthMap[pathType.Arc] = (arc: IPathArc) => {\n    const value = pathLengthMap[pathType.Circle](arc);\n    const pct = angle.ofArcSpan(arc) / 360;\n    return value * pct;\n};\n\npathLengthMap[pathType.BezierSeed] = (seed: IPathBezierSeed) => {\n    return models.BezierCurve.computeLength(seed);\n};\n\n/** Measures the length of a path. */\nexport function pathLength(pathToMeasure: IPath): number {\n    if (pathToMeasure) {\n        const fn = pathLengthMap[pathToMeasure.type];\n        if (fn) {\n            return fn(pathToMeasure);\n        }\n    }\n    return 0;\n}\n\nfunction cloneMeasure(measureToclone: IMeasure): IMeasure {\n    return {\n        high: point.clone(measureToclone.high),\n        low: point.clone(measureToclone.low)\n    };\n}\n\nfunction increase(baseMeasure: IMeasure, addMeasure: IMeasure): IMeasure {\n    const getExtreme = (basePoint: IPoint, newPoint: IPoint, fn: IMathMinMax) => {\n        if (!newPoint) return basePoint;\n        if (!basePoint) return newPoint;\n        return [\n            fn(basePoint[0], newPoint[0]),\n            fn(basePoint[1], newPoint[1])\n        ];\n    };\n\n    baseMeasure.high = getExtreme(baseMeasure.high, addMeasure.high, Math.max);\n    baseMeasure.low = getExtreme(baseMeasure.low, addMeasure.low, Math.min);\n\n    return baseMeasure;\n}\n\n/** Augment a measurement with center and width/height. */\nexport function augment(measureToAugment: IMeasure): IMeasureWithCenter {\n    const m = measureToAugment as IMeasureWithCenter;\n\n    m.center = point.average(m.high, m.low);\n    m.width = m.high[0] - m.low[0];\n    m.height = m.high[1] - m.low[1];\n\n    return m;\n}\n\n/** Measures the smallest rectangle which contains a model. */\nexport function modelExtents(modelToMeasure: IModel): IMeasureWithCenter | null {\n    let measure: IMeasure = { low: null, high: null };\n\n    model.walk(modelToMeasure, {\n        onPath: (walkedPath: any) => {\n            const m = pathExtents(walkedPath.pathContext, walkedPath.offset);\n            increase(measure, m);\n        }\n    });\n\n    if (!measure.high) return null;\n\n    return augment(measure);\n}\n\n// Re-export isPointEqual from equal module for convenience\nexport { isPointEqual } from './equal.js';\n","import { IPoint } from './schema.js';\nimport { round } from './maker.js';\nimport * as measure from './measure-minimal.js';\nimport KDBush from 'kdbush';\n\n/** Compare keys to see if they are equal. */\nexport interface ICollectionKeyComparer<K> {\n    (a: K, b: K): boolean;\n}\n\n    /**\n     * A collection for items that share a common key.\n     */\nexport interface ICollection<K, T> {\n        key: K;\n        items: T[];\n    }\n\n    /**\n     * Collects items that share a common key.\n     */\nexport class Collector<K, T> {\n        public collections: ICollection<K, T>[] = [];\n\n        constructor(private comparer?: ICollectionKeyComparer<K>) {\n        }\n\n        public addItemToCollection(key: K, item: T) {\n            let found = this.findCollection(key);\n            if (found) {\n                found.push(item);\n            } else {\n                let collection: ICollection<K, T> = { key: key, items: [item] };\n                this.collections.push(collection);\n            }\n        }\n\n        public findCollection(key: K, action?: (index: number) => void): T[] {\n            for (let i = 0; i < this.collections.length; i++) {\n                let collection = this.collections[i];\n                if (this.comparer(key, collection.key)) {\n\n                    if (action) {\n                        action(i);\n                    }\n\n                    return collection.items;\n                }\n            }\n            return null;\n        }\n\n        public removeCollection(key: K): boolean {\n\n            if (this.findCollection(key, (index: number) => { this.collections.splice(index, 1); })) {\n                return true;\n            }\n\n            return false;\n        }\n\n        public removeItemFromCollection(key: K, item: T): boolean {\n\n            let collection = this.findCollection(key);\n\n            if (!collection) return;\n\n            for (let i = 0; i < collection.length; i++) {\n                if (collection[i] === item) {\n                    collection.splice(i, 1);\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public getCollectionsOfMultiple(cb: (key: K, items: T[]) => void) {\n            for (let i = 0; i < this.collections.length; i++) {\n                let collection = this.collections[i];\n                if (collection.items.length > 1) {\n                    cb(collection.key, collection.items);\n                }\n            }\n        }\n    }\n\n    /**\n     * @private\n     */\n    // using typed KDBush from the ESM package\n\n    /**\n     * The element type stored in the index of a PointGraph.\n     */\nexport interface IPointGraphIndexElement {\n\n        /**\n         * The point.\n         */\n        point: IPoint;\n\n        /**\n         * The id of this point.\n         */\n        pointId: number;\n\n        /**\n         * Array of other pointId's merged with this one.\n         */\n        merged?: number[];\n\n        /**\n         * Array of valueId's for this point.\n         */\n        valueIds: number[];\n\n        /**\n         * This point's ordinal position in the kd-tree.\n         */\n        kdId?: number;\n    }\n\n    /**\n     * A graph of items which may be located on the same points.\n     */\nexport class PointGraph<T> {\n\n        /**\n         * Number of points inserted\n         */\n        public insertedCount: number;\n\n        /**\n         * Map of unique points by x, then y, to a point id. This will remain intact even after merging.\n         */\n        public graph: { [x: number]: { [y: number]: number } };\n\n        /**\n         * Index of points by id.\n         */\n        public index: { [pointId: number]: IPointGraphIndexElement };\n\n        /**\n         * Map of point ids which once existed but have been merged into another id due to close proximity.\n         */\n        public merged: { [pointId: number]: number };\n\n        /**\n         * List of values inserted at points.\n         */\n        public values: T[];\n\n        /**\n         * KD tree object.\n         */\n        private kdbush: KDBush;\n\n        constructor() {\n            this.reset();\n        }\n\n        /**\n         * Reset the stored points, graphs, lists, to initial state.\n         */\n        public reset() {\n            this.insertedCount = 0;\n            this.graph = {};\n            this.index = {};\n            this.merged = {};\n            this.values = [];\n        }\n\n        /**\n         * Insert a value.\n         * @param value Value associated with this point.\n         * @returns valueId of the inserted value.\n         */\n        public insertValue(value: T) {\n            this.values.push(value);\n            return this.values.length - 1;\n        }\n\n        /**\n         * Insert a value at a point.\n         * @param p Point.\n         * @param value Value associated with this point.\n         */\n        public insertValueIdAtPoint(valueId: number, p: IPoint) {\n            const x = p[0], y = p[1];\n            if (!this.graph[x]) {\n                this.graph[x] = {};\n            }\n            const pgx = this.graph[x];\n            const existed = (y in pgx);\n            let el: IPointGraphIndexElement;\n            let pointId: number;\n            if (!existed) {\n                pgx[y] = pointId = this.insertedCount++;\n                el = {\n                    pointId,\n                    point: p,\n                    valueIds: [valueId]\n                };\n                this.index[pointId] = el;\n            } else {\n                pointId = pgx[y];\n                if (pointId in this.merged) {\n                    pointId = this.merged[pointId];\n                }\n                el = this.index[pointId];\n                el.valueIds.push(valueId);\n            }\n            return { existed, pointId };\n        }\n\n        /**\n         * Merge points within a given distance from each other. Call this after inserting values.\n         * @param withinDistance Distance to consider points equal.\n         */\n        public mergePoints(withinDistance: number) {\n            const points: IPoint[] = [];\n            const kEls: IPointGraphIndexElement[] = [];\n            for (let pointId in this.index) {\n                let el = this.index[pointId];\n                let p = el.point;\n                el.kdId = points.length;\n                points.push(p);\n                kEls.push(el);\n            }\n            // kdbush v4.x API: pre-allocate, add points, then finish\n            this.kdbush = new KDBush(points.length);\n            for (const point of points) {\n                this.kdbush.add(point[0], point[1]);\n            }\n            this.kdbush.finish();\n            for (let pointId in this.index) {\n                if (pointId in this.merged) continue;\n                let el = this.index[pointId];\n                let mergeIds = this.kdbush.within(el.point[0], el.point[1], withinDistance);\n                mergeIds.forEach(kdId => {\n                    if (kdId === el.kdId) return;\n                    this.mergeIndexElements(el, kEls[kdId]);\n                });\n            }\n        }\n\n        /**\n         * Finds all points which have only one value associated. Then, merge to the nearest other point within this set.\n         * Call this after inserting values.\n         * @param withinDistance Distance to consider points equal.\n         */\n        public mergeNearestSinglePoints(withinDistance: number) {\n            const singles: IPointGraphIndexElement[] = [];\n            for (let pointId in this.index) {\n                let el = this.index[pointId];\n                if (el.valueIds.length === 1) {\n                    singles.push(el);\n                }\n            }\n            // kdbush v4.x API: pre-allocate, add points, then finish\n            this.kdbush = new KDBush(singles.length);\n            for (const single of singles) {\n                this.kdbush.add(single.point[0], single.point[1]);\n            }\n            this.kdbush.finish();\n            singles.forEach(el => {\n                if (el.pointId in this.merged) return;\n                let mergeIds = this.kdbush.within(el.point[0], el.point[1], withinDistance);\n                let byDistance: { el: IPointGraphIndexElement, distance: number }[] = [];\n                mergeIds.forEach(i => {\n                    const other = singles[i];\n                    if (other.pointId === el.pointId) return;\n                    byDistance.push({ el: other, distance: measure.pointDistance(other.point, el.point) });\n                });\n                byDistance.sort((a, b) => a.distance - b.distance);\n                for (let i = 0; i < byDistance.length; i++) {\n                    let other = byDistance[i].el;\n                    if (other.pointId in this.merged) continue;\n                    if (other.merged && other.merged.length > 0) {\n                        this.mergeIndexElements(other, el);\n                    } else {\n                        this.mergeIndexElements(el, other);\n                    }\n                    return;\n                }\n            });\n        }\n\n        private mergeIndexElements(keep: IPointGraphIndexElement, remove: IPointGraphIndexElement) {\n            keep.merged = keep.merged || [];\n            keep.merged.push(remove.pointId);\n            this.merged[remove.pointId] = keep.pointId;\n            keep.valueIds.push.apply(keep.valueIds, remove.valueIds);\n            delete this.index[remove.pointId];\n            return keep.pointId;\n        }\n\n        /**\n         * Iterate over points in the index.\n         * @param cb Callback for each point in the index.\n         */\n        public forEachPoint(cb: (p: IPoint, values: T[], pointId?: number, el?: IPointGraphIndexElement) => void) {\n            for (let pointId = 0; pointId < this.insertedCount; pointId++) {\n                let el = this.index[pointId];\n                if (!el) continue;\n                let length = el.valueIds.length;\n                if (length > 0) {\n                    cb(el.point, el.valueIds.map(i => this.values[i]), pointId, el);\n                }\n            }\n        }\n\n        /**\n         * Gets the id of a point, after merging.\n         * @param p Point to look up id.\n         */\n        public getIdOfPoint(p: IPoint) {\n            const px = this.graph[p[0]];\n            if (px) {\n                const pointId = px[p[1]];\n                if (pointId >= 0) {\n                    if (pointId in this.merged) {\n                        return this.merged[pointId];\n                    } else {\n                        return pointId;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Get the index element of a point, after merging.\n         * @param p Point to look up index element.\n         */\n        public getElementAtPoint(p: IPoint) {\n            const pointId = this.getIdOfPoint(p);\n            if (pointId >= 0) {\n                return this.index[pointId];\n            }\n        }\n    }\n\n","/**\n * Chain finding and manipulation functions for Maker.js\n * Chains are paths that connect at endpoints\n */\n\nimport { IModel, IPath, IPoint, IPathArc, IPathBezierSeed, IPathMap } from './schema.js';\nimport {\n    extendObject, isObject, round, cloneObject, pathType,\n    IChain, IChainLink, IWalkPath, IWalkModel, IWalkOptions,\n    IFindChainsOptions, IChainCallback, IChainsMap, IContainChainsOptions\n} from './maker.js';\nimport * as point from './point.js';\nimport * as path from './path.js';\nimport * as angle from './angle.js';\nimport * as measure from './measure-minimal.js';\nimport { PointGraph, IPointGraphIndexElement } from './collect.js';\nimport * as model from './model.js';\nimport * as models from '../models/index.js';\n\n/**\n * @private\n */\nfunction getOpposedLink(linkedPaths: IChainLink[], pathContext: IPath): IChainLink {\n    if (linkedPaths[0].walkedPath.pathContext === pathContext) {\n        return linkedPaths[1];\n    }\n    return linkedPaths[0];\n}\n\n    /**\n     * @private\n     */\nfunction followLinks(pointGraph: PointGraph<IChainLink>, chainFound: (chain: IChain, checkEndless: boolean) => void, chainNotFound?: (path: IWalkPath) => void) {\n\n    const followLink = (initialLink: IChainLink | undefined, chain: IChain, firstLink: IChainLink) => {\n\n        let currLink = initialLink;\n        while (currLink) {\n\n            chain.links.push(currLink);\n            chain.pathLength += currLink.pathLength;\n\n            const next = currLink.reversed ? 0 : 1;\n            const nextPoint = currLink.endPoints[next];\n            const nextEl = pointGraph.getElementAtPoint(nextPoint);\n            if (!nextEl || nextEl.valueIds.length === 0) {\n                break;\n            }\n\n            const items = nextEl.valueIds.map(valueIndex => pointGraph.values[valueIndex]);\n            const nextLink = getOpposedLink(items, currLink.walkedPath.pathContext);\n\n            //remove the first 2 items, which should be currLink and nextLink\n            nextEl.valueIds.splice(0, 2);\n\n            if (!nextLink) {\n                break;\n            }\n\n            if (nextLink.walkedPath.pathContext === firstLink.walkedPath.pathContext) {\n                if (chain.links.length > 1) {\n                    chain.endless = true;\n                }\n                break;\n            }\n\n            currLink = nextLink;\n        }\n\n    };\n\n    pointGraph.forEachPoint((p: IPoint, values: IChainLink[], _pointId?: number, el?: IPointGraphIndexElement) => {\n\n        if (!el || el.valueIds.length === 0) {\n            return;\n        }\n\n        const chain: IChain = {\n            links: [],\n            endless: false,\n            pathLength: 0\n        };\n\n        const firstValue = values[0];\n        if (!firstValue) {\n            return;\n        }\n\n        followLink(firstValue, chain, firstValue);\n\n        if (chain.endless) {\n            chainFound(chain, false);\n            return;\n        }\n\n        //need to go in reverse\n        chain.links.reverse();\n\n        const firstLink = chain.links[0];\n        if (!firstLink) {\n            return;\n        }\n\n        chain.links.forEach((link: IChainLink) => { link.reversed = !link.reversed; });\n\n        //remove the last link, it will be added in the call\n        const lastLink = chain.links[chain.links.length - 1];\n        if (lastLink) {\n            chain.pathLength -= lastLink.pathLength;\n        }\n        const currLink = chain.links.pop();\n\n        followLink(currLink, chain, firstLink);\n\n        if (chain.links.length > 1) {\n            chainFound(chain, true);\n        } else {\n            const singleLink = chain.links[0];\n            if (singleLink) {\n                chainNotFound?.(singleLink.walkedPath);\n            }\n        }\n    });\n}\n\n/**\n * Find a single chain within a model, across all layers. Shorthand of findChains; useful when you know there is only one chain to find in your model.\n * \n * @param modelContext The model to search for a chain.\n * @returns A chain object or null if chains were not found.\n */\nexport function findSingleChain(modelContext: IModel) {\n    let singleChain: IChain = null;\n\n    findChains(modelContext,\n        (chains: IChain[], loose: IWalkPath[], layer: string) => {\n            singleChain = chains[0];\n        },\n        { byLayers: false }\n    );\n\n    return singleChain;\n}\n\n/**\n * @private\n */\nfunction linkEndpoint(link: IChainLink, beginning: boolean) {\n    const index = (beginning === link.reversed) ? 1 : 0;\n    return link.endPoints[index];\n}\n\n/**\n * Find paths that have common endpoints and form chains.\n * \n * @param modelContext The model to search for chains.\n * @param options Optional options object.\n * @returns An array of chains, or a map (keyed by layer id) of arrays of chains - if options.byLayers is true.\n */\nexport function findChains(modelContext: IModel, options?: IFindChainsOptions): IChain[] | IChainsMap;\n\n/**\n * Find paths that have common endpoints and form chains.\n * \n * @param modelContext The model to search for chains.\n * @param callback Callback function when chains are found.\n * @param options Optional options object.\n * @returns An array of chains, or a map (keyed by layer id) of arrays of chains - if options.byLayers is true.\n */\nexport function findChains(modelContext: IModel, callback: IChainCallback, options?: IFindChainsOptions): IChain[] | IChainsMap;\n\nexport function findChains(modelContext: IModel, ...args: any[]): IChain[] | IChainsMap {\n\n        let options: IFindChainsOptions | undefined;\n        let callback: IChainCallback | undefined;\n\n        switch (args.length) {\n            case 1:\n                if (typeof args[0] === 'function') {\n                    callback = args[0];\n                } else {\n                    options = args[0];\n                }\n                break;\n\n            case 2:\n                callback = args[0];\n                options = args[1];\n                break;\n        }\n\n        const opts: IFindChainsOptions = {\n            pointMatchingDistance: 0.005\n        };\n        extendObject(opts, options);\n\n        const pointGraphsByLayer: Record<string, PointGraph<IChainLink>> = {};\n        const chainsByLayer: IChainsMap = {};\n        const ignored: Record<string, IWalkPath[]> = {};\n\n        const walkOptions: IWalkOptions = {\n            onPath(walkedPath: IWalkPath) {\n\n                const layer = opts.byLayers ? walkedPath.layer ?? '' : '';\n                if (!pointGraphsByLayer[layer]) {\n                    pointGraphsByLayer[layer] = new PointGraph<IChainLink>();\n                }\n\n                const pointGraph = pointGraphsByLayer[layer];\n                const pathLength = measure.pathLength(walkedPath.pathContext);\n\n                //circles are loops by nature\n                if (\n                    walkedPath.pathContext.type === pathType.Circle ||\n                    (walkedPath.pathContext.type === pathType.Arc && round(angle.ofArcSpan(walkedPath.pathContext as IPathArc) - 360) === 0) ||\n                    (walkedPath.pathContext.type === pathType.BezierSeed && measure.isPointEqual(walkedPath.pathContext.origin, (walkedPath.pathContext as IPathBezierSeed).end, opts.pointMatchingDistance))\n                ) {\n\n                    const chain: IChain = {\n                        links: [{\n                            walkedPath,\n                            reversed: null,\n                            endPoints: null,\n                            pathLength\n                        }],\n                        endless: true,\n                        pathLength\n                    };\n\n                    //store circles so that layers fire grouped\n                    chainsByLayer[layer] = chainsByLayer[layer] ?? [];\n                    chainsByLayer[layer].push(chain);\n\n                } else {\n\n                    //don't add lines which are 5x shorter than the tolerance\n                    if (pathLength < opts.pointMatchingDistance / 5) {\n\n                        ignored[layer] = ignored[layer] ?? [];\n                        ignored[layer].push(walkedPath);\n\n                        return;\n                    }\n\n                    //gather both endpoints from all non-circle segments\n                    const endPoints = point.fromPathEnds(walkedPath.pathContext, walkedPath.offset);\n\n                    for (let i = 0; i < 2; i += 1) {\n                        const link: IChainLink = {\n                            walkedPath,\n                            endPoints,\n                            reversed: i !== 0,\n                            pathLength\n                        };\n                        const valueId = pointGraph.insertValue(link);\n                        pointGraph.insertValueIdAtPoint(valueId, endPoints[i]);\n                    }\n                }\n            }\n        };\n\n        if (opts.shallow) {\n            walkOptions.beforeChildWalk = function () { return false; };\n        }\n\n        let beziers: IWalkModel[] | undefined;\n        if (opts.unifyBeziers) {\n            beziers = getBezierModels(modelContext);\n            swapBezierPathsWithSeeds(beziers, true, opts.pointMatchingDistance);\n        }\n\n        model.walk(modelContext, walkOptions);\n\n        for (const layer of Object.keys(pointGraphsByLayer)) {\n            const pointGraph = pointGraphsByLayer[layer];\n\n            pointGraph.mergeNearestSinglePoints(opts.pointMatchingDistance);\n\n            const loose: IWalkPath[] = [];\n\n            chainsByLayer[layer] = chainsByLayer[layer] ?? [];\n\n            //follow paths to find endless chains\n            followLinks(\n                pointGraph,\n                function (chain: IChain, checkEndless: boolean) {\n                    if (checkEndless) {\n                        chain.endless = measure.isPointEqual(linkEndpoint(chain.links[0], true), linkEndpoint(chain.links[chain.links.length - 1], false), opts.pointMatchingDistance);\n                    } else {\n                        chain.endless = !!chain.endless;\n                    }\n                    chainsByLayer[layer].push(chain);\n                },\n                function (walkedPath: IWalkPath) {\n                    loose.push(walkedPath);\n                }\n            );\n\n            //sort to return largest chains first\n            chainsByLayer[layer].sort((a: IChain, b: IChain) => b.pathLength - a.pathLength);\n\n            if (opts.contain) {\n                const containChainsOptions: IContainChainsOptions = isObject(opts.contain) ? opts.contain as IContainChainsOptions : { alternateDirection: false };\n                const containedChains = getContainment(chainsByLayer[layer], containChainsOptions);\n                chainsByLayer[layer] = containedChains;\n            }\n\n            callback?.(chainsByLayer[layer], loose, layer, ignored[layer]);\n        }\n\n        if (beziers) {\n            swapBezierPathsWithSeeds(beziers, false, opts.pointMatchingDistance);\n        }\n\n        if (opts.byLayers) {\n            return chainsByLayer;\n        } else {\n            return chainsByLayer[''];\n        }\n    }\n\n/**\n * @private\n */\nfunction getContainment(allChains: IChain[], opts: IContainChainsOptions) {\n\n    const chainsAsModels = allChains.map(c => toNewModel(c));\n    const parents: IChain[] = [];\n\n    //see which are inside of each other\n    allChains.forEach((chainContext, i1) => {\n        if (!chainContext.endless) return;\n\n        const wp = chainContext.links[0].walkedPath;\n        const firstPath = path.clone(wp.pathContext, wp.offset);\n\n        allChains.forEach((otherChain, i2) => {\n\n            if (chainContext === otherChain) return;\n            if (!otherChain.endless) return;\n\n            // TODO: isPointInsideModel needs to be imported from full measure.ts\n            // For now, skip this check - will be fixed when measure.ts is converted\n            // if (measure.isPointInsideModel(point.middle(firstPath), chainsAsModels[i2])) {\n            //     parents[i1] = otherChain;\n            // }\n        });\n    });\n\n    //convert parent to children\n    const result: IChain[] = [];\n    allChains.forEach((chainContext, i) => {\n        const parent = parents[i];\n\n        if (!parent) {\n            result.push(chainContext);\n        } else {\n            if (!parent.contains) {\n                parent.contains = [];\n            }\n            parent.contains.push(chainContext);\n        }\n    });\n\n    if (opts.alternateDirection) {\n\n        const alternate = (chains: IChain[], shouldBeClockwise: boolean) => {\n            chains.forEach((chainContext) => {\n\n                // TODO: isChainClockwise needs to be imported from full measure.ts\n                // For now, skip this check - will be fixed when measure.ts is converted\n                // const isClockwise = measure.isChainClockwise(chainContext);\n\n                // if (isClockwise !== null) {\n                //     if (!isClockwise && shouldBeClockwise || isClockwise && !shouldBeClockwise) {\n                //         reverse(chainContext);\n                //     }\n                // }\n\n                if (chainContext.contains) {\n                    alternate(chainContext.contains, !shouldBeClockwise);\n                }\n            });\n        };\n\n        alternate(result, true);\n    }\n\n    return result;\n}\n\n/**\n * @private\n */\nfunction getBezierModels(modelContext: IModel): IWalkModel[] {\n\n    const beziers: IWalkModel[] = [];\n\n    const checkIsBezier = (wm: IWalkModel) => {\n        // TODO: BezierCurve model class needs to be converted first\n        // For now, skip this check\n        // if (wm.childModel.type === models.BezierCurve.typeName) {\n        //     beziers.push(wm);\n        // }\n    };\n\n    const options: IWalkOptions = {\n        beforeChildWalk: (walkedModel: IWalkModel): boolean => {\n            checkIsBezier(walkedModel);\n            return true;\n        }\n    };\n\n    const rootModel: IWalkModel = {\n        childId: '',\n        childModel: modelContext,\n        layer: modelContext.layer,\n        offset: modelContext.origin,\n        parentModel: null,\n        route: [],\n        routeKey: ''\n    };\n\n    checkIsBezier(rootModel);\n\n    model.walk(modelContext, options);\n\n    return beziers;\n}\n\n/**\n * @private\n */\nfunction swapBezierPathsWithSeeds(beziers: IWalkModel[], swap: boolean, pointMatchingDistance: number) {\n    const tempKey = 'tempPaths';\n    const tempLayerKey = 'tempLayer';\n\n    beziers.forEach(wm => {\n        // TODO: BezierCurve model class needs to be converted first\n        // For now, skip this operation\n        // const b = wm.childModel as models.BezierCurve;\n\n        // Bezier operations commented out until BezierCurve model is converted\n    });\n}\n\n// Chain manipulation functions\n\n/**\n * Shift the links of an endless chain.\n * \n * @param chainContext Chain to cycle through. Must be endless.\n * @param amount Optional number of links to shift. May be negative to cycle backwards.\n * @returns The chainContext for cascading.\n */\nexport function cycle(chainContext: IChain, amount = 1) {\n    if (!chainContext.endless) return;\n    const n = Math.abs(amount);\n    const { links } = chainContext;\n    if (links.length === 0) {\n        return chainContext;\n    }\n    for (let i = 0; i < n; i += 1) {\n        if (amount < 0) {\n            const moved = links.shift();\n            if (moved) {\n                links.push(moved);\n            }\n        } else {\n            const moved = links.pop();\n            if (moved) {\n                links.unshift(moved);\n            }\n        }\n    }\n\n    return chainContext;\n}\n\n/**\n * Reverse the links of a chain.\n * \n * @param chainContext Chain to reverse.\n * @returns The chainContext for cascading.\n */\nexport function reverse(chainContext: IChain) {\n    chainContext.links.reverse();\n    chainContext.links.forEach(link => { link.reversed = !link.reversed; });\n    return chainContext;\n}\n\n/**\n * Set the beginning of an endless chain to a known routeKey of a path.\n * \n * @param chainContext Chain to cycle through. Must be endless.\n * @param routeKey RouteKey of the desired path to start the chain with.\n * @returns The chainContext for cascading.\n */\nexport function startAt(chainContext: IChain, routeKey: string) {\n    if (!chainContext.endless) return;\n    let index = -1;\n    for (let i = 0; i < chainContext.links.length; i++) {\n        if (chainContext.links[i].walkedPath.routeKey === routeKey) {\n            index = i;\n            break;\n        }\n    }\n    if (index > 0) {\n        cycle(chainContext, index);\n    }\n\n    return chainContext;\n}\n\n/**\n * Convert a chain to a new model, independent of any model from where the chain was found.\n * \n * @param chainContext Chain to convert to a model.\n * @param detachFromOldModel Flag to remove the chain's paths from their current parent model. If false, each path will be cloned. If true, the original path will be re-parented into the resulting new model. Default is false.\n * @returns A new model containing paths from the chain.\n */\nexport function toNewModel(chainContext: IChain, detachFromOldModel = false): IModel {\n    const result: IModel = { paths: {} };\n\n    for (const link of chainContext.links) {\n        const wp = link.walkedPath;\n\n        if (wp.pathContext.type === pathType.BezierSeed) {\n\n            if (detachFromOldModel) {\n                delete wp.modelContext.paths[wp.pathId];\n            }\n\n            if (!result.models) {\n                result.models = {};\n            }\n\n            // TODO: BezierCurve model needs to be converted first\n            // const modelId = model.getSimilarModelId(result, wp.pathId);\n            // result.models[modelId] = model.moveRelative(new models.BezierCurve(wp.pathContext as IPathBezierSeed), wp.offset);\n\n        } else {\n            let newPath: IPath;\n            if (detachFromOldModel) {\n                newPath = wp.pathContext;\n                delete wp.modelContext.paths[wp.pathId];\n            } else {\n                newPath = path.clone(wp.pathContext);\n            }\n\n            const pathId = model.getSimilarPathId(result, wp.pathId);\n            result.paths[pathId] = path.moveRelative(newPath, wp.offset);\n        }\n    }\n\n    return result;\n}\n\n/**\n * @private\n */\nfunction removeDuplicateEnds(endless: boolean, points: IPoint[]) {\n    if (!endless || points.length < 2) return;\n    if (measure.isPointEqual(points[0], points[points.length - 1], .00001)) {\n        points.pop();\n    }\n}\n\n/**\n * Get points along a chain of paths.\n * \n * @param chainContext Chain of paths to get points from.\n * @param distance Numeric distance along the chain between points, or numeric array of distances along the chain between each point.\n * @param maxPoints Maximum number of points to retrieve.\n * @returns Array of points which are on the chain spread at a uniform interval.\n */\nexport function toPoints(chainContext: IChain, distanceOrDistances: number | number[], maxPoints?: number): IPoint[] {\n    const result: IPoint[] = [];\n    let di = 0;\n    let t = 0;\n    let distanceArray: number[];\n\n    if (Array.isArray(distanceOrDistances)) {\n        distanceArray = distanceOrDistances as number[];\n    }\n\n    for (const link of chainContext.links) {\n        const wp = link.walkedPath;\n        const len = link.pathLength;\n\n        while (round(len - t) > 0) {\n            let r = t / len;\n            if (link.reversed) {\n                r = 1 - r;\n            }\n\n            result.push(point.add(point.middle(wp.pathContext, r), wp.offset));\n\n            if (maxPoints && result.length >= maxPoints) return result;\n\n            let distance: number;\n            if (distanceArray) {\n                distance = distanceArray[di];\n                di++;\n\n                if (di > distanceArray.length) {\n                    return result;\n                }\n\n            } else {\n                distance = distanceOrDistances as number;\n            }\n\n            t += distance;\n        }\n\n        t -= len;\n    }\n\n    removeDuplicateEnds(chainContext.endless, result);\n    return result;\n}\n\n/**\n * Get key points (a minimal a number of points) along a chain of paths.\n * \n * @param chainContext Chain of paths to get points from.\n * @param maxArcFacet The maximum length between points on an arc or circle.\n * @returns Array of points which are on the chain.\n */\nexport function toKeyPoints(chainContext: IChain, maxArcFacet?: number): IPoint[] {\n    const result: IPoint[] = [];\n\n    for (let i = 0; i < chainContext.links.length; i++) {\n        const link = chainContext.links[i];\n        const wp = link.walkedPath;\n        const keyPoints = path.toKeyPoints(wp.pathContext, maxArcFacet);\n        if (keyPoints.length > 0) {\n            if (link.reversed) {\n                keyPoints.reverse();\n            }\n            if (i > 0) {\n                keyPoints.shift();\n            }\n\n            const offsetPathPoints = keyPoints.map(p => point.add(p, wp.offset));\n            result.push.apply(result, offsetPathPoints);\n        }\n    }\n\n    removeDuplicateEnds(chainContext.endless, result);\n    return result;\n}\n","import type { IModel, IModelMap, IPathMap, IPoint, IPath, IPathBezierSeed, IPathArc, IPathArcInBezierCurve, IBezierRange } from '../core/schema.js';\nimport type { IChain, IWalkPath, IFindChainsOptions, IKit } from '../core/maker.js';\nimport { pathType, round, isPoint } from '../core/maker.js';\nimport * as point from '../core/point.js';\nimport * as path from '../core/path.js';\nimport * as angle from '../core/angle.js';\nimport * as measure from '../core/measure.js';\nimport * as equal from '../core/equal.js';\nimport * as chain from '../core/chain.js';\nimport * as model from '../core/model.js';\nimport * as paths from '../core/paths.js';\n\n// Import Bezier.js v6.x - uses named export at runtime\n// @ts-ignore - type definitions expect default export but runtime uses named export\nimport { Bezier } from 'bezier-js';\n\n// Define types locally since @types/bezier-js doesn't match v6.x export pattern\ndeclare namespace BezierJs {\n  interface Point {\n    x: number;\n    y: number;\n    z?: number;\n  }\n  interface Bezier {\n    points: Point[];\n    extrema(): { values: number[] };\n    get(t: number): Point;\n    split(t1: number, t2: number): Bezier;\n    length(): number;\n    compute(t: number): Point;\n  }\n}\n\nfunction getScratch(seed: IPathBezierSeed) {\n  const points: IPoint[] = [seed.origin];\n  points.push(...seed.controls);\n  points.push(seed.end);\n\n  const bezierJsPoints = points.map(function (p: IPoint) {\n    const bp: BezierJs.Point = {\n      x: p[0],\n      y: p[1]\n    };\n    return bp;\n  });\n\n  // Construct a fresh Bezier instance each time. This avoids relying on global state\n  // or attempting to re-invoke a class constructor via apply.\n  return new Bezier(bezierJsPoints);\n}\n\nfunction BezierToSeed(b: BezierJs.Bezier, range?: IBezierRange): IPathBezierSeed {\n  const points = b.points.map(getIPoint);\n  const seed = new BezierSeed(points) as IPathBezierSeed;\n  if (range) {\n    seed.parentRange = range;\n  }\n  return seed;\n}\n\nfunction seedToBezier(seed: IPathBezierSeed): BezierJs.Bezier {\n  const coords: number[] = [];\n\n  coords.push(seed.origin[0], seed.origin[1]);\n  coords.push(seed.controls[0][0], seed.controls[0][1]);\n  if (seed.controls.length > 1) {\n    coords.push(seed.controls[1][0], seed.controls[1][1]);\n  }\n  coords.push(seed.end[0], seed.end[1]);\n\n  return new Bezier(coords);\n}\n\nfunction getExtrema(b: BezierJs.Bezier) {\n  const extrema = b\n    .extrema()\n    .values\n    // round the numbers so we can compare them to each other\n    .map(m => round(m))\n    // remove duplicates\n    .filter((value, index, self) => self.indexOf(value) === index)\n    // and put them in order\n    .sort();\n\n  if (extrema.length === 0) return [0, 1];\n\n  // ensure leading zero\n  if (extrema[0] !== 0) {\n    extrema.unshift(0);\n  }\n\n  // ensure ending 1\n  if (extrema[extrema.length - 1] !== 1) {\n    extrema.push(1);\n  }\n\n  return extrema;\n}\n\nfunction getIPoint(p: BezierJs.Point): IPoint {\n  return [p.x, p.y];\n}\n\nclass TPoint {\n  public point: IPoint;\n\n  constructor(b: BezierJs.Bezier, public t: number, offset?: IPoint) {\n    this.point = point.add(getIPoint(b.get(t)), offset);\n  }\n}\n\nfunction getError(b: BezierJs.Bezier, startT: number, endT: number, arc: IPathArc, arcReversed: boolean): number {\n  const tSpan = endT - startT;\n\n  function m(ratio: number) {\n    const t = startT + tSpan * ratio;\n    const bp = getIPoint(b.get(t));\n    const ap = point.middle(arc, arcReversed ? 1 - ratio : ratio);\n    return measure.pointDistance(ap, bp);\n  }\n\n  return m(0.25) + m(0.75);\n}\n\nfunction getLargestArc(b: BezierJs.Bezier, startT: number, endT: number, accuracy: number): IPathArcInBezierCurve {\n  let arc: IPathArc;\n  let lastGoodArc: IPathArc;\n  const start = new TPoint(b, startT);\n  const end = new TPoint(b, endT);\n  let upper = end;\n  let lower = start;\n  let count = 0;\n  let test = upper;\n  let reversed: boolean;\n\n  while (count < 100) {\n    const middle = getIPoint(b.get((start.t + test.t) / 2));\n\n    // if the 3 points are linear, this may throw\n    try {\n      arc = new paths.Arc(start.point, middle, test.point);\n    } catch (e) {\n      if (lastGoodArc) {\n        return lastGoodArc as IPath as IPathArcInBezierCurve;\n      } else {\n        break;\n      }\n    }\n\n    // only need to test once to see if this arc is polar / clockwise\n    if (reversed === undefined) {\n      reversed = equal.isPointEqual(start.point, point.fromAngleOnCircle(arc.endAngle, arc));\n    }\n\n    // now we have a valid arc, measure the error.\n    const error = getError(b, startT, test.t, arc, reversed);\n\n    // if error is within accuracy, this becomes the lower\n    if (error <= accuracy) {\n      (arc as IPath as IPathArcInBezierCurve).bezierData = {\n        startT: startT,\n        endT: test.t\n      };\n      lower = test;\n      lastGoodArc = arc;\n    } else {\n      upper = test;\n    }\n\n    // exit if lower is the end\n    if (\n      lower.t === upper.t ||\n      (lastGoodArc && lastGoodArc !== arc && angle.ofArcSpan(arc) - angle.ofArcSpan(lastGoodArc) < 0.5)\n    ) {\n      return lastGoodArc as IPath as IPathArcInBezierCurve;\n    }\n\n    count++;\n    test = new TPoint(b, (lower.t + upper.t) / 2);\n  }\n\n  // arc failed, so return a line\n  const line = new paths.Line(start.point, test.point) as IPath as IPathArcInBezierCurve;\n  line.bezierData = {\n    startT: startT,\n    endT: test.t\n  };\n  return line;\n}\n\nfunction getArcs(bc: BezierCurve, b: BezierJs.Bezier, accuracy: number, startT: number, endT: number, base: number): number {\n  let added = 0;\n  let arc: IPathArcInBezierCurve;\n\n  while (startT < endT) {\n    arc = getLargestArc(b, startT, endT, accuracy);\n    // add an arc\n\n    startT = arc.bezierData.endT;\n\n    const len = measure.pathLength(arc);\n    if (len < 0.0001) {\n      continue;\n    }\n\n    bc.paths[arc.type + '_' + (base + added)] = arc;\n\n    added++;\n  }\n\n  return added;\n}\n\nfunction getActualBezierRange(\n  curve: BezierCurve,\n  arc: IPathArcInBezierCurve,\n  endpoints: IPoint[],\n  offset: IPoint,\n  pointMatchingDistance: number\n): IBezierRange | null {\n  const b = getScratch(curve.seed);\n  const tPoints = [arc.bezierData.startT, arc.bezierData.endT].map(t => new TPoint(b, t, offset));\n  const ends = endpoints.slice();\n\n  // clipped arcs will still have endpoints closer to the original endpoints\n  const endpointDistancetoStart = ends.map(e => measure.pointDistance(e, tPoints[0].point));\n  if (endpointDistancetoStart[0] > endpointDistancetoStart[1]) ends.reverse();\n\n  for (let i = 2; i--; ) {\n    if (!equal.isPointEqual(ends[i], tPoints[i].point, pointMatchingDistance)) {\n      return null;\n    }\n  }\n\n  return arc.bezierData;\n}\n\ninterface IAddToLayer {\n  (pathToAdd: IPath, layer: string, clone?: boolean): void;\n}\n\nfunction getChainBezierRange(\n  curve: BezierCurve,\n  c: IChain,\n  layer: string,\n  addToLayer: IAddToLayer,\n  pointMatchingDistance: number\n): IBezierRange | null {\n  const endLinks = [c.links[0], c.links[c.links.length - 1]];\n  if (\n    (endLinks[0].walkedPath.pathContext as IPathArcInBezierCurve).bezierData.startT >\n    (endLinks[1].walkedPath.pathContext as IPathArcInBezierCurve).bezierData.startT\n  ) {\n    chain.reverse(c);\n    endLinks.reverse();\n  }\n\n  const actualBezierRanges = endLinks.map(endLink =>\n    getActualBezierRange(\n      curve,\n      endLink.walkedPath.pathContext as IPathArcInBezierCurve,\n      endLink.endPoints,\n      endLink.walkedPath.offset,\n      pointMatchingDistance\n    )\n  );\n\n  const result: IBezierRange = {\n    startT: actualBezierRanges[0] ? actualBezierRanges[0].startT : null,\n    endT: actualBezierRanges[1] ? actualBezierRanges[1].endT : null\n  };\n\n  if (result.startT !== null && result.endT !== null) {\n    return result;\n  } else if (c.links.length > 2) {\n    if (result.startT === null) {\n      // exclude the first from the chain\n      addToLayer(c.links[0].walkedPath.pathContext, layer, true);\n      result.startT = (c.links[1].walkedPath.pathContext as IPathArcInBezierCurve).bezierData.startT;\n    }\n\n    if (result.endT === null) {\n      // exclude the last from the chain\n      addToLayer(c.links[c.links.length - 1].walkedPath.pathContext, layer, true);\n      result.endT = (c.links[c.links.length - 2].walkedPath.pathContext as IPathArcInBezierCurve).bezierData.endT;\n    }\n\n    return result;\n  }\n  return null;\n}\n\n/**\n * Class for bezier seed.\n */\nexport class BezierSeed implements IPathBezierSeed {\n  public type: string;\n  public origin: IPoint;\n  public end: IPoint;\n  public controls: IPoint[];\n\n  /**\n   * Class for bezier seed, created from point array.\n   *\n   * @param points Array of points, with the first being the origin, and the last being the end, and points between used as control points.\n   */\n  constructor(points: IPoint[]);\n\n  /**\n   * Class for quadratic bezier seed.\n   *\n   * @param origin The origin point of the curve.\n   * @param control The control point of the curve.\n   * @param end The end point of the curve.\n   */\n  constructor(origin: IPoint, control: IPoint, end: IPoint);\n\n  /**\n   * Class for cubic bezier seed.\n   *\n   * @param origin The origin point of the curve.\n   * @param controls The control points of the curve.\n   * @param end The end point of the curve.\n   */\n  constructor(origin: IPoint, controls: IPoint[], end: IPoint);\n\n  /**\n   * Class for cubic bezier seed.\n   *\n   * @param origin The origin point of the curve.\n   * @param control1 The control point of the curve origin.\n   * @param control2 The control point of the curve end.\n   * @param end The end point of the curve.\n   */\n  constructor(origin: IPoint, control1: IPoint, control2: IPoint, end: IPoint);\n\n  constructor(...args: any[]) {\n    this.type = pathType.BezierSeed;\n\n    switch (args.length) {\n      case 1: // point array\n        const points = args[0] as IPoint[];\n\n        this.origin = points[0];\n\n        if (points.length === 3) {\n          this.controls = [points[1]];\n          this.end = points[2];\n        } else if (points.length === 4) {\n          this.controls = [points[1], points[2]];\n          this.end = points[3];\n        } else {\n          this.end = points[1];\n        }\n\n        break;\n\n      case 3: // quadratic or cubic\n        if (Array.isArray(args[1])) {\n          this.controls = args[1] as IPoint[];\n        } else {\n          this.controls = [args[1] as IPoint];\n        }\n\n        this.end = args[2] as IPoint;\n        break;\n\n      case 4: // cubic params\n        this.controls = [args[1] as IPoint, args[2] as IPoint];\n        this.end = args[3] as IPoint;\n        break;\n    }\n  }\n}\n\nexport class BezierCurve implements IModel {\n  public models: IModelMap;\n  public paths: IPathMap;\n  public origin: IPoint;\n  public type = BezierCurve.typeName;\n  public seed: IPathBezierSeed;\n  public accuracy: number;\n\n  constructor(points: IPoint[], accuracy?: number);\n  constructor(seed: IPathBezierSeed, accuracy?: number);\n  constructor(origin: IPoint, control: IPoint, end: IPoint, accuracy?: number);\n  constructor(origin: IPoint, controls: IPoint[], end: IPoint, accuracy?: number);\n  constructor(origin: IPoint, control1: IPoint, control2: IPoint, end: IPoint, accuracy?: number);\n\n  constructor(...args: any[]) {\n    const isArrayArg0 = Array.isArray(args[0]);\n\n    switch (args.length) {\n      case 2:\n        if (isArrayArg0) {\n          this.accuracy = args[1] as number;\n        } else {\n          // seed\n          this.seed = args[0] as IPathBezierSeed;\n          this.accuracy = args[1] as number;\n          break;\n        }\n      // fall through to point array\n\n      case 1: // point array or seed\n        if (isArrayArg0) {\n          const points = args[0] as IPoint[];\n          this.seed = new BezierSeed(points);\n        } else {\n          this.seed = args[0] as IPathBezierSeed;\n        }\n        break;\n\n      default:\n        switch (args.length) {\n          case 4:\n            if (isPoint(args[3])) {\n              this.seed = new BezierSeed(args as IPoint[]);\n              break;\n            } else {\n              this.accuracy = args[3] as number;\n              // fall through\n            }\n          case 3:\n            if (isArrayArg0) {\n              this.seed = new BezierSeed(args.slice(0, 3) as IPoint[]);\n            }\n            break;\n\n          case 5:\n            this.accuracy = args[4] as number;\n            this.seed = new BezierSeed(args.slice(0, 4) as IPoint[]);\n            break;\n        }\n        break;\n    }\n\n    this.paths = {};\n\n    if (measure.isBezierSeedLinear(this.seed)) {\n      // use a line and exit\n\n      const line = new paths.Line(point.clone(this.seed.origin), point.clone(this.seed.end));\n      (line as IPath as IPathArcInBezierCurve).bezierData = {\n        startT: 0,\n        endT: 1\n      };\n\n      this.paths = {\n        '0': line\n      };\n      return;\n    }\n\n    const b = seedToBezier(this.seed);\n    const extrema = getExtrema(b);\n\n    this.paths = {};\n\n    // use arcs\n\n    if (!this.accuracy) {\n      // get a default accuracy relative to the size of the bezier\n      const len = b.length();\n\n      // set the default to be a combination of fast rendering and good smoothing.\n      this.accuracy = len / 100;\n    }\n\n    let count = 0;\n    for (let i = 1; i < extrema.length; i++) {\n      const extremaSpan = extrema[i] - extrema[i - 1];\n      count += getArcs(this, b, this.accuracy * extremaSpan, extrema[i - 1], extrema[i], count);\n    }\n  }\n\n  public static typeName = 'BezierCurve';\n\n  public static getBezierSeeds(curve: BezierCurve, options: IFindChainsOptions = {}): IPath[] | { [layer: string]: IPath[] } {\n    options.shallow = true;\n    options.unifyBeziers = false;\n\n    const seedsByLayer: { [layer: string]: IPath[] } = {};\n\n    const addToLayer: IAddToLayer = (pathToAdd: IPath, layer: string, clone = false) => {\n      if (!seedsByLayer[layer]) {\n        seedsByLayer[layer] = [];\n      }\n      seedsByLayer[layer].push(clone ? path.clone(pathToAdd) : pathToAdd);\n    };\n\n    chain.findChains(\n      curve,\n      function (chains: IChain[], loose: IWalkPath[], layer: string) {\n        chains.forEach(c => {\n          const range = getChainBezierRange(curve, c, layer, addToLayer, options.pointMatchingDistance);\n          if (range) {\n            const b = getScratch(curve.seed);\n            const piece = b.split(range.startT, range.endT);\n            addToLayer(BezierToSeed(piece), layer);\n          } else {\n            c.links.forEach(link => addToLayer(link.walkedPath.pathContext, layer, true));\n          }\n        });\n\n        loose.forEach(wp => {\n          if (wp.pathContext.type === pathType.Line) {\n            // bezier is linear\n            return addToLayer(wp.pathContext, layer, true);\n          }\n          const range = getActualBezierRange(\n            curve,\n            wp.pathContext as IPathArcInBezierCurve,\n            point.fromPathEnds(wp.pathContext),\n            wp.offset,\n            options.pointMatchingDistance\n          );\n          if (range) {\n            const b = getScratch(curve.seed);\n            const piece = b.split(range.startT, range.endT);\n            addToLayer(BezierToSeed(piece), layer);\n          } else {\n            addToLayer(wp.pathContext, layer, true);\n          }\n        });\n      },\n      options\n    );\n\n    if (options.byLayers) {\n      return seedsByLayer;\n    } else {\n      return seedsByLayer[''];\n    }\n  }\n\n  public static computeLength(seed: IPathBezierSeed): number {\n    const b = seedToBezier(seed);\n    return b.length();\n  }\n\n  public static computePoint(seed: IPathBezierSeed, t: number): IPoint {\n    const s = getScratch(seed);\n    const computedPoint = s.compute(t);\n    return getIPoint(computedPoint);\n  }\n}\n\n(BezierCurve as any as IKit).metaParameters = [\n  {\n    title: 'points',\n    type: 'select',\n    value: [\n      [\n        [100, 0],\n        [-80, -60],\n        [100, 220],\n        [100, 60]\n      ],\n      [\n        [0, 0],\n        [100, 0],\n        [100, 100]\n      ],\n      [\n        [0, 0],\n        [20, 0],\n        [80, 100],\n        [100, 100]\n      ]\n    ]\n  }\n];\n","import { IModel, IPoint, IPath, ICaption, IPathLine, IPathBezierSeed } from './schema.js';\nimport { cloneObject, isPath, pathType } from './maker.js';\nimport type { IWalkOptions, IModelPathCallback, IWalkPath, IWalkModel, IChain, IChainCallback, IFindChainsOptions, IChainsMap } from './maker.js';\nimport * as point from './point.js';\nimport * as path from './path.js';\nimport * as paths from './paths.js';\nimport * as units from './units.js';\nimport * as measure from './measure-minimal.js';\nimport { BezierCurve } from '../models/BezierCurve-esm.js';\nimport { findChains as chainFindChains, findSingleChain as chainFindSingleChain } from './chain.js';\n\nexport function findChains(modelContext: IModel, callbackOrOptions?: IChainCallback | IFindChainsOptions, maybeOptions?: IFindChainsOptions): IChain[] | IChainsMap {\n    if (typeof callbackOrOptions === 'function') {\n        return chainFindChains(modelContext, callbackOrOptions as IChainCallback, maybeOptions);\n    }\n    return chainFindChains(modelContext, callbackOrOptions as IFindChainsOptions);\n}\n\nexport function findSingleChain(modelContext: IModel): IChain {\n    return chainFindSingleChain(modelContext);\n}\n\n/** Add a Caption object to a model. */\nexport function addCaption(modelContext: IModel, text: string, leftAnchorPoint?: IPoint, rightAnchorPoint?: IPoint) {\n    if (!leftAnchorPoint) {\n        leftAnchorPoint = point.zero();\n    }\n    if (!rightAnchorPoint) {\n        rightAnchorPoint = point.clone(leftAnchorPoint);\n    }\n    modelContext.caption = { text, anchor: new paths.Line(leftAnchorPoint, rightAnchorPoint) };\n    return modelContext;\n}\n\n    /**\n     * Add a path as a child. This is basically equivalent to:\n     * ```\n     * parentModel.paths[childPathId] = childPath;\n     * ```\n     * with additional checks to make it safe for cascading.\n     *\n     * @param modelContext The model to add to.\n     * @param pathContext The path to add.\n     * @param pathId The id of the path.\n     * @param overWrite Optional flag to overwrite any path referenced by pathId. Default is false, which will create an id similar to pathId.\n     * @returns The original model (for cascading).\n     */\nexport function addPath(modelContext: IModel, pathContext: IPath, pathId: string, overWrite = false): IModel {\n        const id = overWrite ? pathId : getSimilarPathId(modelContext, pathId);\n        modelContext.paths = modelContext.paths || {};\n        modelContext.paths[id] = pathContext;\n        return modelContext;\n    }\n\n    /**\n     * Add a model as a child. This is basically equivalent to:\n     * ```\n     * parentModel.models[childModelId] = childModel;\n     * ```\n     * with additional checks to make it safe for cascading.\n     *\n     * @param parentModel The model to add to.\n     * @param childModel The model to add.\n     * @param childModelId The id of the child model.\n     * @param overWrite Optional flag to overwrite any model referenced by childModelId. Default is false, which will create an id similar to childModelId.\n     * @returns The original model (for cascading).\n     */\nexport function addModel(parentModel: IModel, childModel: IModel, childModelId: string, overWrite = false): IModel {\n        const id = overWrite ? childModelId : getSimilarModelId(parentModel, childModelId);\n        parentModel.models = parentModel.models || {};\n        parentModel.models[id] = childModel;\n        return parentModel;\n    }\n\n    /**\n     * Add a model as a child of another model. This is basically equivalent to:\n     * ```\n     * parentModel.models[childModelId] = childModel;\n     * ```\n     * with additional checks to make it safe for cascading.\n     *\n     * @param childModel The model to add.\n     * @param parentModel The model to add to.\n     * @param childModelId The id of the child model.\n     * @param overWrite Optional flag to overwrite any model referenced by childModelId. Default is false, which will create an id similar to childModelId.\n     * @returns The original model (for cascading).\n     */\nexport function addTo(childModel: IModel, parentModel: IModel, childModelId: string, overWrite = false): IModel {\n        addModel(parentModel, childModel, childModelId, overWrite);\n        return childModel;\n    }\n\n    /**\n     * Clone a model. Alias of makerjs.cloneObject(modelToClone)\n     *\n     * @param modelToClone The model to clone.\n     * @returns A clone of the model you passed.\n     */\nexport function clone(modelToClone: IModel): IModel {\n        return cloneObject(modelToClone);\n    }\n\n    /**\n     * Count the number of child models within a given model.\n     *\n     * @param modelContext The model containing other models.\n     * @returns Number of child models.\n     */\nexport function countChildModels(modelContext: IModel): number {\n        let count = 0;\n\n        if (modelContext.models) {\n            for (const id in modelContext.models) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    /**\n     * Gets all Caption objects, in absolute position, in this model and its children.\n     * @param modelContext The model to search for Caption objects.\n     * @returns Array of Caption objects.\n     */\nexport function getAllCaptionsOffset(modelContext: IModel) {\n        const captions: (ICaption & { layer?: string })[] = [];\n\n        function tryAddCaption(m: IModel, offset: IPoint, layer: string) {\n            if (m.caption) {\n                captions.push({ text: m.caption.text, anchor: path.clone(m.caption.anchor, point.add(m.origin, offset)) as IPathLine, layer: (m.caption.anchor.layer || layer) });\n            }\n        }\n\n        tryAddCaption(modelContext, modelContext.origin, modelContext.layer);\n        walk(modelContext, {\n            afterChildWalk: wm => tryAddCaption(wm.childModel, wm.offset, wm.layer)\n        });\n\n        return captions;\n    }\n\n    /**\n     * @private\n     */\n    function getSimilarId(map: { [id: string]: any }, id: string): string {\n        if (!map) return id;\n        let i = 0;\n        let newId = id;\n        while (newId in map) {\n            i++;\n            newId = [id, i].join('_');\n        }\n        return newId;\n    }\n\n    /**\n     * Get an unused id in the models map with the same prefix.\n     *\n     * @param modelContext The model containing the models map.\n     * @param modelId The id to use directly (if unused), or as a prefix.\n     */\nexport function getSimilarModelId(modelContext: IModel, modelId: string): string {\n        return getSimilarId(modelContext.models, modelId);\n    }\n\n    /**\n     * Get an unused id in the paths map with the same prefix.\n     *\n     * @param modelContext The model containing the paths map.\n     * @param pathId The id to use directly (if unused), or as a prefix.\n     */\nexport function getSimilarPathId(modelContext: IModel, pathId: string): string {\n        return getSimilarId(modelContext.paths, pathId);\n    }\n\n    /**\n     * Set the layer of a model. This is equivalent to:\n     * ```\n     * modelContext.layer = layer;\n     * ```\n     *\n     * @param modelContext The model to set the layer.\n     * @param layer The layer name.\n     * @returns The original model (for cascading).\n     */\nexport function layer(modelContext: IModel, layer: string): IModel {\n        modelContext.layer = layer;\n        return modelContext;\n    }\n\n    /**\n     * Moves all of a model's children (models and paths, recursively) in reference to a single common origin. Useful when points between children need to connect to each other.\n     *\n     * @param modelToOriginate The model to originate.\n     * @param origin Optional offset reference point.\n     * @returns The original model (for cascading).\n     */\nexport function originate(modelToOriginate: IModel, origin?: IPoint) {\n\n        function innerOriginate(m: IModel, o: IPoint) {\n            if (!m) return;\n\n            const newOrigin = point.add(m.origin, o);\n\n            if (m.type === BezierCurve.typeName) {\n                path.moveRelative((m as BezierCurve).seed, newOrigin);\n            }\n\n            if (m.paths) {\n                for (let id in m.paths) {\n                    path.moveRelative(m.paths[id], newOrigin);\n                }\n            }\n\n            if (m.models) {\n                for (let id in m.models) {\n                    innerOriginate(m.models[id], newOrigin);\n                }\n            }\n\n            if (m.caption) {\n                path.moveRelative(m.caption.anchor, newOrigin);\n            }\n\n            m.origin = point.zero();\n        }\n\n        innerOriginate(modelToOriginate, origin ? point.subtract([0, 0], origin) : [0, 0]);\n\n        if (origin) {\n            modelToOriginate.origin = origin;\n        }\n\n        return modelToOriginate;\n    }\n\n    /**\n     * Center a model at [0, 0].\n     *\n     * @param modelToCenter The model to center.\n     * @param centerX Boolean to center on the x axis. Default is true.\n     * @param centerY Boolean to center on the y axis. Default is true.\n     * @returns The original model (for cascading).\n     */\nexport function center(modelToCenter: IModel, centerX = true, centerY = true) {\n        const m = measure.modelExtents(modelToCenter);\n        const o = modelToCenter.origin || [0, 0];\n        if (centerX) o[0] -= m.center[0];\n        if (centerY) o[1] -= m.center[1];\n        modelToCenter.origin = o;\n        return modelToCenter;\n    }\n\n    /**\n     * Create a clone of a model, mirrored on either or both x and y axes.\n     *\n     * @param modelToMirror The model to mirror.\n     * @param mirrorX Boolean to mirror on the x axis.\n     * @param mirrorY Boolean to mirror on the y axis.\n     * @returns Mirrored model.\n     */\nexport function mirror(modelToMirror: IModel, mirrorX: boolean, mirrorY: boolean): IModel {\n        let newModel: IModel = {};\n\n        if (!modelToMirror) return null;\n\n        if (modelToMirror.origin) {\n            newModel.origin = point.mirror(modelToMirror.origin, mirrorX, mirrorY);\n        }\n\n        if (modelToMirror.type) {\n            newModel.type = modelToMirror.type;\n        }\n\n        if ('layer' in modelToMirror) {\n            newModel.layer = modelToMirror.layer;\n        }\n\n        if (modelToMirror.units) {\n            newModel.units = modelToMirror.units;\n        }\n\n        if (modelToMirror.type === BezierCurve.typeName) {\n            newModel.type = BezierCurve.typeName;\n            (newModel as BezierCurve).seed = path.mirror((modelToMirror as BezierCurve).seed, mirrorX, mirrorY) as IPathBezierSeed;\n        }\n\n        if (modelToMirror.paths) {\n            newModel.paths = {};\n            for (let id in modelToMirror.paths) {\n                const pathToMirror = modelToMirror.paths[id];\n                if (!pathToMirror) continue;\n                const pathMirrored = path.mirror(pathToMirror, mirrorX, mirrorY);\n                if (!pathMirrored) continue;\n                newModel.paths[id] = pathMirrored;\n            }\n        }\n\n        if (modelToMirror.models) {\n            newModel.models = {};\n            for (let id in modelToMirror.models) {\n                const childModelToMirror = modelToMirror.models[id];\n                if (!childModelToMirror) continue;\n                const childModelMirrored = mirror(childModelToMirror, mirrorX, mirrorY);\n                if (!childModelMirrored) continue;\n                newModel.models[id] = childModelMirrored;\n            }\n        }\n\n        if (modelToMirror.caption) {\n            newModel.caption = cloneObject(modelToMirror.caption);\n            newModel.caption.anchor = path.mirror(modelToMirror.caption.anchor, mirrorX, mirrorY) as IPathLine;\n        }\n\n        return newModel;\n    }\n\n    /**\n     * Move a model to an absolute point. Note that this is also accomplished by directly setting the origin property. This function exists for cascading.\n     *\n     * @param modelToMove The model to move.\n     * @param origin The new position of the model.\n     * @returns The original model (for cascading).\n     */\nexport function move(modelToMove: IModel, origin: IPoint): IModel {\n        modelToMove.origin = point.clone(origin);\n        return modelToMove;\n    }\n\n    /**\n     * Move a model's origin by a relative amount.\n     *\n     * @param modelToMove The model to move.\n     * @param delta The x & y adjustments as a point object.\n     * @returns The original model (for cascading).\n     */\nexport function moveRelative(modelToMove: IModel, delta: IPoint): IModel {\n\n        if (modelToMove) {\n            modelToMove.origin = point.add(modelToMove.origin || point.zero(), delta);\n        }\n\n        return modelToMove;\n    }\n\n    /**\n     * Prefix the ids of paths in a model.\n     *\n     * @param modelToPrefix The model to prefix.\n     * @param prefix The prefix to prepend on paths ids.\n     * @returns The original model (for cascading).\n     */\nexport function prefixPathIds(modelToPrefix: IModel, prefix: string) {\n\n        let walkedPaths: IWalkPath[] = [];\n\n        //first collect the paths because we don't want to modify keys during an iteration on keys\n        walk(modelToPrefix, {\n            onPath: function (walkedPath: IWalkPath) {\n                walkedPaths.push(walkedPath);\n            }\n        });\n\n        //now modify the ids in our own iteration\n        for (let i = 0; i < walkedPaths.length; i++) {\n            const walkedPath = walkedPaths[i];\n            delete walkedPath.modelContext.paths[walkedPath.pathId];\n            walkedPath.modelContext.paths[prefix + walkedPath.pathId] = walkedPath.pathContext;\n        }\n\n        return modelToPrefix;\n    }\n\n    /**\n     * Rotate a model.\n     *\n     * @param modelToRotate The model to rotate.\n     * @param angleInDegrees The amount of rotation, in degrees.\n     * @param rotationOrigin The center point of rotation.\n     * @returns The original model (for cascading).\n     */\nexport function rotate(modelToRotate: IModel, angleInDegrees: number, rotationOrigin: IPoint = [0, 0]): IModel {\n        if (!modelToRotate || !angleInDegrees) return modelToRotate;\n\n        const offsetOrigin = point.subtract(rotationOrigin, modelToRotate.origin);\n\n        if (modelToRotate.type === BezierCurve.typeName) {\n            path.rotate((modelToRotate as BezierCurve).seed, angleInDegrees, offsetOrigin);\n        }\n\n        if (modelToRotate.paths) {\n            for (let id in modelToRotate.paths) {\n                path.rotate(modelToRotate.paths[id], angleInDegrees, offsetOrigin);\n            }\n        }\n\n        if (modelToRotate.models) {\n            for (let id in modelToRotate.models) {\n                rotate(modelToRotate.models[id], angleInDegrees, offsetOrigin);\n            }\n        }\n\n        if (modelToRotate.caption) {\n            path.rotate(modelToRotate.caption.anchor, angleInDegrees, offsetOrigin);\n        }\n\n        return modelToRotate;\n    }\n\n    /**\n     * Scale a model.\n     *\n     * @param modelToScale The model to scale.\n     * @param scaleValue The amount of scaling.\n     * @param scaleOrigin Optional boolean to scale the origin point. Typically false for the root model.\n     * @returns The original model (for cascading).\n     */\nexport function scale(modelToScale: IModel, scaleValue: number, scaleOrigin = false): IModel {\n\n        if (scaleOrigin && modelToScale.origin) {\n            modelToScale.origin = point.scale(modelToScale.origin, scaleValue);\n        }\n\n        if (modelToScale.type === BezierCurve.typeName) {\n            path.scale((modelToScale as BezierCurve).seed, scaleValue);\n        }\n\n        if (modelToScale.paths) {\n            for (let id in modelToScale.paths) {\n                path.scale(modelToScale.paths[id], scaleValue);\n            }\n        }\n\n        if (modelToScale.models) {\n            for (let id in modelToScale.models) {\n                scale(modelToScale.models[id], scaleValue, true);\n            }\n        }\n\n        if (modelToScale.caption) {\n            path.scale(modelToScale.caption.anchor, scaleValue);\n        }\n\n        return modelToScale;\n    }\n\n    /**\n     * @private\n     */\n    function addDistortedPath(parentModel: IModel, pathToDistort: IPath, pathId: string, layer: string, scaleX: number, scaleY: number, bezierAccuracy?: number) {\n        const distortedPath = path.distort(pathToDistort, scaleX, scaleY);\n        layer = layer || pathToDistort.layer;\n        if (layer) {\n            distortedPath.layer = layer;\n        }\n        if (isPath(distortedPath)) {\n            if (distortedPath.type === pathType.BezierSeed) {\n                const curve = new BezierCurve(distortedPath as IPathBezierSeed, bezierAccuracy);\n                addModel(parentModel, curve, pathId);\n            } else {\n                addPath(parentModel, distortedPath as IPath, pathId);\n            }\n        } else {\n            addModel(parentModel, distortedPath as IModel, pathId);\n        }\n    }\n\n    /**\n     * Create a distorted copy of a model - scale x and y individually.\n     *\n     * @param modelToDistort The model to distort.\n     * @param scaleX The amount of x scaling.\n     * @param scaleY The amount of y scaling.\n     * @param scaleOrigin Optional boolean to scale the origin point. Typically false for the root model.\n     * @param bezierAccuracy Optional accuracy of Bezier curves.\n     * @returns New model (for cascading).\n     */\nexport function distort(modelToDistort: IModel, scaleX: number, scaleY: number, scaleOrigin = false, bezierAccuracy?: number) {\n        const distorted: IModel = {};\n        if (modelToDistort.layer) {\n            distorted.layer = modelToDistort.layer;\n        }\n\n        if (scaleOrigin && modelToDistort.origin) {\n            distorted.origin = point.distort(modelToDistort.origin, scaleX, scaleY);\n        }\n\n        if (modelToDistort.type === BezierCurve.typeName) {\n            const b = modelToDistort as BezierCurve;\n            const bezierPartsByLayer = BezierCurve.getBezierSeeds(b, { byLayers: true, pointMatchingDistance: bezierAccuracy });\n            for (let layer in bezierPartsByLayer) {\n                let pathArray = bezierPartsByLayer[layer]\n                pathArray.forEach((p, i) => {\n                    addDistortedPath(distorted, p, i.toString(), layer, scaleX, scaleY, bezierAccuracy);\n                })\n            }\n        } else if (modelToDistort.paths) {\n            for (let pathId in modelToDistort.paths) {\n                let pathToDistort = modelToDistort.paths[pathId];\n                addDistortedPath(distorted, pathToDistort, pathId, null, scaleX, scaleY, bezierAccuracy);\n            }\n        }\n\n        if (modelToDistort.models) {\n            for (let childId in modelToDistort.models) {\n                let childModel = modelToDistort.models[childId];\n                let distortedChild = distort(childModel, scaleX, scaleY, true, bezierAccuracy);\n                addModel(distorted, distortedChild, childId);\n            }\n        }\n\n        if (modelToDistort.caption) {\n            distorted.caption = cloneObject(modelToDistort.caption);\n            distorted.caption.anchor = path.distort(modelToDistort.caption.anchor, scaleX, scaleY) as IPathLine;\n        }\n\n        return distorted;\n    }\n\n    /**\n     * Convert a model to match a different unit system.\n     *\n     * @param modeltoConvert The model to convert.\n     * @param destUnitType The unit system.\n     * @returns The scaled model (for cascading).\n     */\nexport function convertUnits(modeltoConvert: IModel, destUnitType: string): IModel {\n\n        if (modeltoConvert.units && units.isValidUnit(modeltoConvert.units) && units.isValidUnit(destUnitType)) {\n            const ratio = units.conversionScale(modeltoConvert.units, destUnitType);\n\n            if (ratio != 1) {\n                scale(modeltoConvert, ratio);\n\n                //update the model with its new unit type\n                modeltoConvert.units = destUnitType;\n            }\n        }\n\n        return modeltoConvert;\n    }\n\n    /**\n     * DEPRECATED - use model.walk instead.\n     * Recursively walk through all paths for a given model.\n     *\n     * @param modelContext The model to walk.\n     * @param callback Callback for each path.\n     */\nexport function walkPaths(modelContext: IModel, callback: IModelPathCallback) {\n\n        if (modelContext.paths) {\n            for (let pathId in modelContext.paths) {\n                if (!modelContext.paths[pathId]) continue;\n                callback(modelContext, pathId, modelContext.paths[pathId]);\n            }\n        }\n\n        if (modelContext.models) {\n            for (let id in modelContext.models) {\n                if (!modelContext.models[id]) continue;\n                walkPaths(modelContext.models[id], callback);\n            }\n        }\n    }\n\n    /**\n     * Recursively walk through all child models and paths for a given model.\n     *\n     * @param modelContext The model to walk.\n     * @param options Object containing callbacks.\n     * @returns The original model (for cascading).\n     */\nexport function walk(modelContext: IModel, options: IWalkOptions) {\n\n        if (!modelContext) return;\n\n        function walkRecursive(modelContext: IModel, layer: string, offset: IPoint, route: string[], routeKey: string) {\n\n            const newOffset = point.add(modelContext.origin, offset);\n            layer = (layer != undefined) ? layer : '';\n\n            if (modelContext.paths) {\n                for (let pathId in modelContext.paths) {\n\n                    const pathContext = modelContext.paths[pathId];\n                    if (!pathContext) continue;\n\n                    let walkedPath: IWalkPath = {\n                        modelContext: modelContext,\n                        layer: (pathContext.layer != undefined) ? pathContext.layer : layer,\n                        offset: newOffset,\n                        pathContext: pathContext,\n                        pathId: pathId,\n                        route: route.concat(['paths', pathId]),\n                        routeKey: routeKey + (routeKey ? '.' : '') + 'paths' + JSON.stringify([pathId])\n                    };\n\n                    if (options.onPath) options.onPath(walkedPath);\n                }\n            }\n\n            if (modelContext.models) {\n                for (let modelId in modelContext.models) {\n\n                    const childModel = modelContext.models[modelId];\n                    if (!childModel) continue;\n\n                    let walkedModel: IWalkModel = {\n                        parentModel: modelContext,\n                        layer: (childModel.layer != undefined) ? childModel.layer : layer,\n                        offset: newOffset,\n                        route: route.concat(['models', modelId]),\n                        routeKey: routeKey + (routeKey ? '.' : '') + 'models' + JSON.stringify([modelId]),\n                        childId: modelId,\n                        childModel: childModel\n                    };\n\n                    if (options.beforeChildWalk) {\n                        if (!options.beforeChildWalk(walkedModel)) continue;\n                    }\n\n                    walkRecursive(walkedModel.childModel, walkedModel.layer, newOffset, walkedModel.route, walkedModel.routeKey);\n\n                    if (options.afterChildWalk) {\n                        options.afterChildWalk(walkedModel);\n                    }\n                }\n            }\n        }\n\n        walkRecursive(modelContext, modelContext.layer, [0, 0], [], '');\n\n        return modelContext;\n    }\n\n    /**\n     * Move a model so its bounding box begins at [0, 0].\n     *\n     * @param modelToZero The model to zero.\n     * @param zeroX Boolean to zero on the x axis. Default is true.\n     * @param zeroY Boolean to zero on the y axis. Default is true.\n     * @returns The original model (for cascading).\n     */\nexport function zero(modelToZero: IModel, zeroX = true, zeroY = true) {\n        const m = measure.modelExtents(modelToZero);\n        const z = modelToZero.origin || [0, 0];\n        if (zeroX) z[0] -= m.low[0];\n        if (zeroY) z[1] -= m.low[1];\n        modelToZero.origin = z;\n        return modelToZero;\n    }\n","import { IPoint, IPath, IPathLine, IPathCircle, IPathArc, IPathBezierSeed, IPathArcInBezierCurve, IModel } from './schema.js';\nimport { pathType } from './maker.js';\nimport * as point from './point.js';\nimport * as angle from './angle.js';\n\n// Import only 'paths' to avoid runtime ReferenceError in UMD bundle\nimport * as paths from './paths.js';\nimport * as model from './model.js';\n\n// TEMP: These will be available after respective modules are converted\ndeclare const models: any;\ndeclare const measure: any;\ndeclare const chain: any;\n\n// TEMP: These interfaces will be moved to a shared location\nexport interface IChain {\n    links: Array<{ walkedPath: { pathId: string; pathContext: IPath; }; }>;\n}\nexport interface IWalkPath {\n    pathContext: IPath;\n}\n\n/** Add a path to a model. */\nexport function addTo(childPath: IPath, parentModel: IModel, pathId: string, overwrite = false): IPath {\n    model.addPath(parentModel, childPath, pathId, overwrite);\n    return childPath;\n}\n\nfunction copyLayer(pathA: IPath, pathB: IPath) {\n    if (pathA && pathB && typeof pathA.layer !== 'undefined') {\n        pathB.layer = pathA.layer;\n    }\n    if (pathA && pathB && ('bezierData' in pathA)) {\n        (<IPathArcInBezierCurve>pathB).bezierData = (<IPathArcInBezierCurve>pathA).bezierData;\n    }\n}\n\nconst copyPropsMap: { [pathType: string]: (src: IPath, dest: IPath, offset?: IPoint) => void } = {};\n\ncopyPropsMap[pathType.Circle] = (srcCircle: IPathCircle, destCircle: IPathCircle, offset?: IPoint) => {\n    destCircle.radius = srcCircle.radius;\n};\n\ncopyPropsMap[pathType.Arc] = (srcArc: IPathArc, destArc: IPathArc, offset?: IPoint) => {\n    copyPropsMap[pathType.Circle](srcArc, destArc, offset);\n    destArc.startAngle = srcArc.startAngle;\n    destArc.endAngle = srcArc.endAngle;\n};\n\ncopyPropsMap[pathType.Line] = (srcLine: IPathLine, destLine: IPathLine, offset?: IPoint) => {\n    destLine.end = point.add(srcLine.end, offset);\n};\n\ncopyPropsMap[pathType.BezierSeed] = (srcSeed: IPathBezierSeed, destSeed: IPathBezierSeed, offset?: IPoint) => {\n    copyPropsMap[pathType.Line](srcSeed, destSeed, offset);\n    destSeed.controls = srcSeed.controls.map(p => point.add(p, offset));\n};\n\n/** Create a clone of a path. This is faster than cloneObject. */\nexport function clone(pathToClone: IPath, offset?: IPoint): IPath {\n    const result: IPath = { type: pathToClone.type, origin: point.add(pathToClone.origin, offset) };\n    const fn = copyPropsMap[pathToClone.type];\n    if (fn) {\n        fn(pathToClone, result, offset);\n    }\n    copyLayer(pathToClone, result);\n    return result;\n}\n\n/** Copy the schema properties of one path to another. */\nexport function copyProps(srcPath: IPath, destPath: IPath): IPath {\n    const fn = copyPropsMap[srcPath.type];\n    if (fn) {\n        destPath.origin = point.clone(srcPath.origin);\n        fn(srcPath, destPath);\n    }\n    copyLayer(srcPath, destPath);\n    return srcPath;\n}\n\nconst mirrorMap: { [pathType: string]: (pathToMirror: IPath, origin: IPoint, mirrorX: boolean, mirrorY: boolean) => IPath } = {};\n\nmirrorMap[pathType.Line] = (line: IPathLine, origin: IPoint, mirrorX: boolean, mirrorY: boolean) => {\n    return new paths.Line(origin, point.mirror(line.end, mirrorX, mirrorY));\n};\n\nmirrorMap[pathType.Circle] = (circle: IPathCircle, origin: IPoint, mirrorX: boolean, mirrorY: boolean) => {\n    return new paths.Circle(origin, circle.radius);\n};\n\nmirrorMap[pathType.Arc] = (arc: IPathArc, origin: IPoint, mirrorX: boolean, mirrorY: boolean) => {\n    const startAngle = angle.mirror(arc.startAngle, mirrorX, mirrorY);\n    const endAngle = angle.mirror(angle.ofArcEnd(arc), mirrorX, mirrorY);\n    const xor = mirrorX != mirrorY;\n    return new paths.Arc(origin, arc.radius, xor ? endAngle : startAngle, xor ? startAngle : endAngle);\n};\n\nmirrorMap[pathType.BezierSeed] = (seed: IPathBezierSeed, origin: IPoint, mirrorX: boolean, mirrorY: boolean) => {\n    const mirrored = mirrorMap[pathType.Line](seed, origin, mirrorX, mirrorY) as IPathBezierSeed;\n    mirrored.type = pathType.BezierSeed;\n    mirrored.controls = seed.controls.map(c => point.mirror(c, mirrorX, mirrorY));\n    return mirrored;\n};\n\n/** Set the layer of a path. */\nexport function layer(pathContext: IPath, layer: string): IPath {\n    pathContext.layer = layer;\n    return pathContext;\n}\n\n/** Create a clone of a path, mirrored on either or both x and y axes. */\nexport function mirror(pathToMirror: IPath, mirrorX: boolean, mirrorY: boolean): IPath {\n    let newPath: IPath = null;\n    if (pathToMirror) {\n        const origin = point.mirror(pathToMirror.origin, mirrorX, mirrorY);\n        const fn = mirrorMap[pathToMirror.type];\n        if (fn) {\n            newPath = fn(pathToMirror, origin, mirrorX, mirrorY);\n        }\n    }\n    copyLayer(pathToMirror, newPath);\n    return newPath;\n}\n\nconst moveMap: { [pathType: string]: (pathToMove: IPath, origin: IPoint) => void } = {};\n\nmoveMap[pathType.Line] = (line: IPathLine, origin: IPoint) => {\n    const delta = point.subtract(line.end, line.origin);\n    line.end = point.add(origin, delta);\n};\n\n/** Move a path to an absolute point. */\nexport function move(pathToMove: IPath, origin: IPoint): IPath {\n    if (pathToMove) {\n        const fn = moveMap[pathToMove.type];\n        if (fn) {\n            fn(pathToMove, origin);\n        }\n        pathToMove.origin = origin;\n    }\n    return pathToMove;\n}\n\nconst moveRelativeMap: { [pathType: string]: (pathToMove: IPath, delta: IPoint, subtract: boolean) => void } = {};\n\nmoveRelativeMap[pathType.Line] = (line: IPathLine, delta: IPoint, subtract: boolean) => {\n    line.end = point.add(line.end, delta, subtract);\n};\n\nmoveRelativeMap[pathType.BezierSeed] = (seed: IPathBezierSeed, delta: IPoint, subtract: boolean) => {\n    moveRelativeMap[pathType.Line](seed, delta, subtract);\n    seed.controls = seed.controls.map(c => point.add(c, delta, subtract));\n};\n\n/** Move a path's origin by a relative amount. */\nexport function moveRelative(pathToMove: IPath, delta: IPoint, subtract?: boolean): IPath {\n    if (pathToMove && delta) {\n        pathToMove.origin = point.add(pathToMove.origin, delta, subtract);\n        const fn = moveRelativeMap[pathToMove.type];\n        if (fn) {\n            fn(pathToMove, delta, subtract);\n        }\n    }\n    return pathToMove;\n}\n\n/** Move some paths relatively during a task execution, then unmove them. */\nexport function moveTemporary(pathsToMove: IPath[], deltas: IPoint[], task: Function) {\n    let subtract = false;\n    const moveFunc = (pathToOffset: IPath, i: number) => {\n        if (deltas[i]) {\n            moveRelative(pathToOffset, deltas[i], subtract);\n        }\n    };\n    pathsToMove.map(moveFunc);\n    task();\n    subtract = true;\n    pathsToMove.map(moveFunc);\n}\n\nconst rotateMap: { [pathType: string]: (pathToRotate: IPath, angleInDegrees: number, rotationOrigin: IPoint) => void } = {};\n\nrotateMap[pathType.Line] = (line: IPathLine, angleInDegrees: number, rotationOrigin: IPoint) => {\n    line.end = point.rotate(line.end, angleInDegrees, rotationOrigin);\n};\n\nrotateMap[pathType.Arc] = (arc: IPathArc, angleInDegrees: number, rotationOrigin: IPoint) => {\n    arc.startAngle = angle.noRevolutions(arc.startAngle + angleInDegrees);\n    arc.endAngle = angle.noRevolutions(arc.endAngle + angleInDegrees);\n};\n\nrotateMap[pathType.BezierSeed] = (seed: IPathBezierSeed, angleInDegrees: number, rotationOrigin: IPoint) => {\n    rotateMap[pathType.Line](seed, angleInDegrees, rotationOrigin);\n    seed.controls = seed.controls.map(c => point.rotate(c, angleInDegrees, rotationOrigin));\n};\n\n/** Rotate a path. */\nexport function rotate(pathToRotate: IPath, angleInDegrees: number, rotationOrigin: IPoint = [0, 0]): IPath {\n    if (!pathToRotate || !angleInDegrees) return pathToRotate;\n    pathToRotate.origin = point.rotate(pathToRotate.origin, angleInDegrees, rotationOrigin);\n    const fn = rotateMap[pathToRotate.type];\n    if (fn) {\n        fn(pathToRotate, angleInDegrees, rotationOrigin);\n    }\n    return pathToRotate;\n}\n\nconst scaleMap: { [pathType: string]: (pathValue: IPath, scaleValue: number) => void } = {};\n\nscaleMap[pathType.Line] = (line: IPathLine, scaleValue: number) => {\n    line.end = point.scale(line.end, scaleValue);\n};\n\nscaleMap[pathType.BezierSeed] = (seed: IPathBezierSeed, scaleValue: number) => {\n    scaleMap[pathType.Line](seed, scaleValue);\n    seed.controls = seed.controls.map(c => point.scale(c, scaleValue));\n};\n\nscaleMap[pathType.Circle] = (circle: IPathCircle, scaleValue: number) => {\n    circle.radius *= scaleValue;\n};\n\nscaleMap[pathType.Arc] = scaleMap[pathType.Circle];\n\n/** Scale a path. */\nexport function scale(pathToScale: IPath, scaleValue: number): IPath {\n    if (!pathToScale || scaleValue === 1 || !scaleValue) return pathToScale;\n    pathToScale.origin = point.scale(pathToScale.origin, scaleValue);\n    const fn = scaleMap[pathToScale.type];\n    if (fn) {\n        fn(pathToScale, scaleValue);\n    }\n    return pathToScale;\n}\n\nconst distortMap: { [pathType: string]: (pathValue: IPath, scaleX: number, scaleY: number) => IModel | IPath } = {};\n\ndistortMap[pathType.Arc] = (arc: IPathArc, scaleX: number, scaleY: number) => {\n    return new models.EllipticArc(arc, scaleX, scaleY);\n};\n\ndistortMap[pathType.Circle] = (circle: IPathCircle, scaleX: number, scaleY: number) => {\n    const ellipse = new models.Ellipse(circle.radius * scaleX, circle.radius * scaleY);\n    ellipse.origin = point.distort(circle.origin, scaleX, scaleY);\n    return ellipse;\n};\n\ndistortMap[pathType.Line] = (line: IPathLine, scaleX: number, scaleY: number) => {\n    return new paths.Line([line.origin, line.end].map(p => point.distort(p, scaleX, scaleY)));\n};\n\ndistortMap[pathType.BezierSeed] = (seed: IPathBezierSeed, scaleX: number, scaleY: number) => {\n    const d = point.distort;\n    return {\n        type: pathType.BezierSeed,\n        origin: d(seed.origin, scaleX, scaleY),\n        controls: seed.controls.map(c => d(c, scaleX, scaleY)),\n        end: d(seed.end, scaleX, scaleY)\n    } as IPathBezierSeed;\n};\n\n/** Distort a path - scale x and y individually. */\nexport function distort(pathToDistort: IPath, scaleX: number, scaleY: number): IModel | IPath {\n    if (!pathToDistort || !scaleX || !scaleY) return null;\n    const fn = distortMap[pathToDistort.type];\n    if (fn) {\n        const distorted = fn(pathToDistort, scaleX, scaleY);\n        if (typeof pathToDistort.layer !== 'undefined') {\n            distorted.layer = pathToDistort.layer;\n        }\n        return distorted;\n    }\n    return null;\n}\n\n/** Connect 2 lines at their slope intersection point. */\nexport function converge(lineA: IPathLine, lineB: IPathLine, useOriginA?: boolean, useOriginB?: boolean): IPoint {\n    const p = point.fromSlopeIntersection(lineA, lineB);\n    if (p) {\n        const lines = [lineA, lineB];\n        const useOrigin = [useOriginA, useOriginB];\n        if (arguments.length === 2) {\n            lines.forEach((line, i) => {\n                useOrigin[i] = (point.closest(p, [line.origin, line.end]) === line.origin);\n            });\n        }\n        const setPoint = (line: IPathLine, useOrigin: boolean) => {\n            const setP: IPoint = useOrigin ? line.origin : line.end;\n            setP[0] = p[0];\n            setP[1] = p[1];\n        };\n        lines.forEach((line, i) => {\n            setPoint(line, useOrigin[i]);\n        });\n    }\n    return p;\n}\n\nconst alterMap: { [pathType: string]: (pathValue: IPath, pathLength: number, distance: number, useOrigin: boolean) => void } = {};\n\nalterMap[pathType.Arc] = (arc: IPathArc, pathLength: number, distance: number, useOrigin: boolean) => {\n    const span = angle.ofArcSpan(arc);\n    const delta = ((pathLength + distance) * span / pathLength) - span;\n    if (useOrigin) {\n        arc.startAngle -= delta;\n    } else {\n        arc.endAngle += delta;\n    }\n};\n\nalterMap[pathType.Circle] = (circle: IPathCircle, pathLength: number, distance: number, useOrigin: boolean) => {\n    circle.radius *= (pathLength + distance) / pathLength;\n};\n\nalterMap[pathType.Line] = (line: IPathLine, pathLength: number, distance: number, useOrigin: boolean) => {\n    const delta = point.scale(point.subtract(line.end, line.origin), distance / pathLength);\n    if (useOrigin) {\n        line.origin = point.subtract(line.origin, delta);\n    } else {\n        line.end = point.add(line.end, delta);\n    }\n};\n\n/** Alter a path by lengthening or shortening it. */\nexport function alterLength(pathToAlter: IPath, distance: number, useOrigin = false): IPath {\n    if (!pathToAlter || !distance) return null;\n    const fn = alterMap[pathToAlter.type];\n    if (fn) {\n        const pathLength = measure.pathLength(pathToAlter);\n        if (!pathLength || -distance >= pathLength) return null;\n        fn(pathToAlter, pathLength, distance, useOrigin);\n        return pathToAlter;\n    }\n    return null;\n}\n\n/** Get points along a path. */\nexport function toPoints(pathContext: IPath, numberOfPoints: number): IPoint[] {\n    if (numberOfPoints == 1) {\n        return [point.middle(pathContext)];\n    }\n    const points: IPoint[] = [];\n    let base = numberOfPoints;\n    if (pathContext.type != pathType.Circle) base--;\n    for (let i = 0; i < numberOfPoints; i++) {\n        points.push(point.middle(pathContext, i / base));\n    }\n    return points;\n}\n\nconst numberOfKeyPointsMap: { [type: string]: (pathContext: IPath, maxPointDistance?: number) => number } = {};\n\nnumberOfKeyPointsMap[pathType.Line] = (line: IPathLine) => 2;\n\nnumberOfKeyPointsMap[pathType.Circle] = (circle: IPathCircle, maxPointDistance?: number) => {\n    const len = measure.pathLength(circle);\n    if (!len) return 0;\n    maxPointDistance = maxPointDistance || len;\n    return Math.max(8, Math.ceil(len / (maxPointDistance || len)));\n};\n\nnumberOfKeyPointsMap[pathType.Arc] = (arc: IPathArc, maxPointDistance?: number) => {\n    const len = measure.pathLength(arc);\n    if (!len) return 0;\n    const minPoints = Math.ceil(angle.ofArcSpan(arc) / 45) + 1;\n    return Math.max(minPoints, Math.ceil(len / (maxPointDistance || len)));\n};\n\n/** Get key points (a minimal a number of points) along a path. */\nexport function toKeyPoints(pathContext: IPath, maxArcFacet?: number): IPoint[] {\n    if (pathContext.type == pathType.BezierSeed) {\n        const curve = new models.BezierCurve(pathContext as IPathBezierSeed);\n        let curveKeyPoints: IPoint[];\n        model.findChains(curve, (chains: IChain[], loose: IWalkPath[], layer: string) => {\n            if (chains.length == 1) {\n                const c = chains[0];\n                switch (c.links[0].walkedPath.pathId) {\n                    case 'arc_0':\n                    case 'line_0':\n                        break;\n                    default:\n                        chain.reverse(c);\n                }\n                curveKeyPoints = chain.toKeyPoints(c);\n            } else if (loose.length === 1) {\n                curveKeyPoints = toKeyPoints(loose[0].pathContext);\n            }\n        });\n        return curveKeyPoints;\n    } else {\n        const fn = numberOfKeyPointsMap[pathContext.type];\n        if (fn) {\n            const numberOfKeyPoints = fn(pathContext, maxArcFacet);\n            if (numberOfKeyPoints) {\n                return toPoints(pathContext, numberOfKeyPoints);\n            }\n        }\n    }\n    return [];\n}\n\n/** Center a path at [0, 0]. */\nexport function center(pathToCenter: IPath) {\n    const m = measure.pathExtents(pathToCenter);\n    const c = point.average(m.high, m.low);\n    const o = point.subtract(pathToCenter.origin || [0, 0], c);\n    move(pathToCenter, o);\n    return pathToCenter;\n}\n\n/** Move a path so its bounding box begins at [0, 0]. */\nexport function zero(pathToZero: IPath) {\n    const m = measure.pathExtents(pathToZero);\n    const z = point.subtract(pathToZero.origin || [0, 0], m.low);\n    move(pathToZero, z);\n    return pathToZero;\n}\n","import { IPoint, IPath, IPathLine, IPathCircle, IPathArc, IPathIntersection, IPathIntersectionOptions } from './schema.js';\nimport { pathType, round } from './maker.js';\nimport * as point from './point.js';\nimport * as angle from './angle.js';\nimport * as measure from './measure.js';\nimport * as solvers from './solvers.js';\nimport { Line, Circle } from './paths.js';\nimport { moveTemporary, rotate } from './path.js';\nimport * as equal from './equal.js';\n\n/**\n * @private\n */\ninterface IPathIntersectionMap {\n    [type: string]: { [type: string]: (path1: IPath, path2: IPath, options: IPathIntersectionOptions, swapOffsets?: boolean) => IPathIntersection };\n}\n\n/**\n * @private\n */\nconst map: IPathIntersectionMap = {};\n\nmap[pathType.Arc] = {};\nmap[pathType.Circle] = {};\nmap[pathType.Line] = {};\n\nmap[pathType.Arc][pathType.Arc] = (arc1: IPathArc, arc2: IPathArc, options: IPathIntersectionOptions, swapOffsets: boolean) => {\n    let result: IPathIntersection = null;\n\n    moveTemp([arc1, arc2], options, swapOffsets, () => {\n\n        const angles = circleToCircle(arc1, arc2, options);\n        if (angles) {\n            const arc1Angles = getAnglesWithinArc(angles[0], arc1, options);\n            const arc2Angles = getAnglesWithinArc(angles[1], arc2, options);\n            if (arc1Angles && arc2Angles) {\n\n                //must correspond to the same angle indexes\n                if (arc1Angles.length === 1 || arc2Angles.length === 1) {\n\n                    for (let i1 = 0; i1 < arc1Angles.length; i1++) {\n                        for (let i2 = 0; i2 < arc2Angles.length; i2++) {\n\n                            const p1 = point.fromAngleOnCircle(arc1Angles[i1], arc1);\n                            const p2 = point.fromAngleOnCircle(arc2Angles[i2], arc2);\n\n                            //if they do not correspond then they don't intersect\n                            if (equal.isPointEqual(p1, p2, .0001)) {\n\n                                result = {\n                                    intersectionPoints: [p1],\n                                    path1Angles: [arc1Angles[i1]],\n                                    path2Angles: [arc2Angles[i2]]\n                                };\n\n                                return;\n                            }\n                        }\n                    }\n\n                } else {\n\n                    result = {\n                        intersectionPoints: pointsFromAnglesOnCircle(arc1Angles, arc1),\n                        path1Angles: arc1Angles,\n                        path2Angles: arc2Angles\n                    };\n                }\n            }\n        } else {\n            if (options.out_AreOverlapped) {\n                //overlapped for circle, reset and see if arcs actually overlap.\n\n                options.out_AreOverlapped = measure.isArcOverlapping(arc1, arc2, options.excludeTangents);\n            }\n        }\n    });\n\n    return result;\n};\n\nmap[pathType.Arc][pathType.Circle] = (arc: IPathArc, circle: IPathArc, options: IPathIntersectionOptions, swapOffsets: boolean) => {\n    let result: IPathIntersection = null;\n\n    moveTemp([arc, circle], options, swapOffsets, () => {\n\n        const angles = circleToCircle(arc, circle, options);\n        if (angles) {\n            const arcAngles = getAnglesWithinArc(angles[0], arc, options);\n            if (arcAngles) {\n                let circleAngles: number[];\n\n                //if both points are on arc, use both on circle\n                if (arcAngles.length == 2) {\n                    circleAngles = angles[1];\n                } else {\n                    //use the corresponding point on circle \n                    const index = findCorrespondingAngleIndex(angles[0], arcAngles[0]);\n                    circleAngles = [angles[1][index]];\n                }\n\n                result = {\n                    intersectionPoints: pointsFromAnglesOnCircle(arcAngles, arc),\n                    path1Angles: arcAngles,\n                    path2Angles: circleAngles\n                };\n            }\n        }\n    });\n\n    return result;\n};\n\nmap[pathType.Arc][pathType.Line] = (arc: IPathArc, line: IPathLine, options: IPathIntersectionOptions, swapOffsets: boolean) => {\n    let result: IPathIntersection = null;\n\n    moveTemp([arc, line], options, swapOffsets, () => {\n\n        const angles = lineToCircle(line, arc, options);\n        if (angles) {\n            const arcAngles = getAnglesWithinArc(angles, arc, options);\n            if (arcAngles) {\n                result = {\n                    intersectionPoints: pointsFromAnglesOnCircle(arcAngles, arc),\n                    path1Angles: arcAngles\n                };\n            }\n        }\n    });\n\n    return result;\n};\n\nmap[pathType.Circle][pathType.Arc] = (circle: IPathCircle, arc: IPathArc, options: IPathIntersectionOptions) => {\n    const result = map[pathType.Arc][pathType.Circle](arc, circle, options, true);\n    if (result) {\n        return swapAngles(result);\n    }\n    return null;\n};\n\nmap[pathType.Circle][pathType.Circle] = (circle1: IPathCircle, circle2: IPathCircle, options: IPathIntersectionOptions, swapOffsets: boolean) => {\n    let result: IPathIntersection = null;\n\n    moveTemp([circle1, circle2], options, swapOffsets, () => {\n\n        const angles = circleToCircle(circle1, circle2, options);\n        if (angles) {\n            result = {\n                intersectionPoints: pointsFromAnglesOnCircle(angles[0], circle1),\n                path1Angles: angles[0],\n                path2Angles: angles[1]\n            };\n        }\n    });\n\n    return result;\n};\n\nmap[pathType.Circle][pathType.Line] = (circle: IPathCircle, line: IPathLine, options: IPathIntersectionOptions, swapOffsets: boolean) => {\n    let result: IPathIntersection = null;\n\n    moveTemp([circle, line], options, swapOffsets, () => {\n\n        const angles = lineToCircle(line, circle, options);\n        if (angles) {\n            result = {\n                intersectionPoints: pointsFromAnglesOnCircle(angles, circle),\n                path1Angles: angles\n            };\n        }\n    });\n\n    return result;\n};\n\nmap[pathType.Line][pathType.Arc] = (line: IPathLine, arc: IPathArc, options: IPathIntersectionOptions) => {\n    const result = map[pathType.Arc][pathType.Line](arc, line, options, true);\n    if (result) {\n        return swapAngles(result);\n    }\n    return null;\n};\n\nmap[pathType.Line][pathType.Circle] = (line: IPathLine, circle: IPathCircle, options: IPathIntersectionOptions) => {\n    const result = map[pathType.Circle][pathType.Line](circle, line, options, true);\n    if (result) {\n        return swapAngles(result);\n    }\n    return null;\n};\n\nmap[pathType.Line][pathType.Line] = (line1: IPathLine, line2: IPathLine, options: IPathIntersectionOptions, swapOffsets: boolean) => {\n    let result: IPathIntersection = null;\n\n    moveTemp([line1, line2], options, swapOffsets, () => {\n\n        const intersectionPoint = point.fromSlopeIntersection(line1, line2, options);\n        if (intersectionPoint) {\n\n            //we have the point of intersection of endless lines, now check to see if the point is between both segemnts\n            if (measure.isBetweenPoints(intersectionPoint, line1, options.excludeTangents) && measure.isBetweenPoints(intersectionPoint, line2, options.excludeTangents)) {\n                result = {\n                    intersectionPoints: [intersectionPoint]\n                };\n            }\n        }\n    });\n\n    return result;\n};\n\n/**\n * @private\n */\nfunction moveTemp(pathsToOffset: IPath[], options: IPathIntersectionOptions, swapOffsets: boolean, task: Function) {\n    const offsets = swapOffsets ? [options.path2Offset, options.path1Offset] : [options.path1Offset, options.path2Offset];\n    moveTemporary(pathsToOffset, offsets, task);\n}\n\n/**\n * @private\n */\nfunction swapAngles(result: IPathIntersection) {\n    const temp = result.path1Angles;\n\n    if (result.path2Angles) {\n        result.path1Angles = result.path2Angles;\n    } else {\n        delete result.path1Angles;\n    }\n\n    if (temp) {\n        result.path2Angles = temp;\n    }\n\n    return result;\n}\n\n/**\n * Find the point(s) where 2 paths intersect.\n * \n * @param path1 First path to find intersection.\n * @param path2 Second path to find intersection.\n * @param options Optional IPathIntersectionOptions.\n * @returns IPathIntersection object, with points(s) of intersection (and angles, when a path is an arc or circle); or null if the paths did not intersect.\n */\nexport function intersection(path1: IPath, path2: IPath, options: IPathIntersectionOptions = {}): IPathIntersection {\n\n    if (path1 && path2) {\n        const fn = map[path1.type][path2.type];\n        if (fn) {\n            return fn(path1, path2, options);\n        }\n    }\n    return null;\n}\n\n/**\n * @private\n */\nfunction findCorrespondingAngleIndex(circleAngles: number[], arcAngle: number): number {\n    for (let i = 2; i--;) {\n        if (circleAngles[i] === arcAngle) return i;\n    }\n    return -1;\n}\n\n/**\n * @private\n */\nfunction pointsFromAnglesOnCircle(anglesInDegrees: number[], circle: IPathCircle): IPoint[] {\n    const result: IPoint[] = [];\n    for (let i = 0; i < anglesInDegrees.length; i++) {\n        result.push(point.fromAngleOnCircle(anglesInDegrees[i], circle));\n    }\n    return result;\n}\n\n/**\n * @private\n */\nfunction getAnglesWithinArc(angles: number[], arc: IPathArc, options: IPathIntersectionOptions): number[] {\n\n    if (!angles) return null;\n\n    const anglesWithinArc: number[] = [];\n\n    for (let i = 0; i < angles.length; i++) {\n        if (measure.isBetweenArcAngles(angles[i], arc, options.excludeTangents)) {\n            anglesWithinArc.push(angles[i]);\n        }\n    }\n\n    if (anglesWithinArc.length == 0) return null;\n\n    return anglesWithinArc;\n}\n\n/**\n * @private\n */\nfunction lineToCircle(line: IPathLine, circle: IPathCircle, options: IPathIntersectionOptions): number[] {\n\n    const radius = round(circle.radius);\n\n    //no-op for degenerate circle\n    if (circle.radius <= 0) {\n        return null;\n    }\n\n    //clone the line\n    const clonedLine = new Line(point.subtract(line.origin, circle.origin), point.subtract(line.end, circle.origin));\n\n    //get angle of line\n    const lineAngleNormal = angle.ofLineInDegrees(line);\n\n    //use the positive horizontal angle\n    const lineAngle = (lineAngleNormal >= 180) ? lineAngleNormal - 360 : lineAngleNormal;\n\n    //rotate the line to horizontal\n    rotate(clonedLine, -lineAngle, point.zero());\n\n    //remember how to undo the rotation we just did\n    const unRotate = (resultAngle: number): number => {\n        const unrotated = resultAngle + lineAngle;\n        return round(angle.noRevolutions(unrotated));\n    }\n\n    //line is horizontal, get the y value from any point\n    const lineY = round(clonedLine.origin[1]);\n    const lineYabs = Math.abs(lineY);\n\n    //if y is greater than radius, there is no intersection\n    if (lineYabs > radius) {\n        return null;\n    }\n\n    const anglesOfIntersection: number[] = [];\n\n    //if horizontal Y is the same as the radius, we know it's 90 degrees\n    if (lineYabs == radius) {\n\n        if (options.excludeTangents) {\n            return null;\n        }\n\n        anglesOfIntersection.push(unRotate(lineY > 0 ? 90 : 270));\n\n    } else {\n\n        const intersectionBetweenEndpoints = (x: number, angleOfX: number) => {\n            if (measure.isBetween(round(x), round(clonedLine.origin[0]), round(clonedLine.end[0]), options.excludeTangents)) {\n                anglesOfIntersection.push(unRotate(angleOfX));\n            }\n        }\n\n        //find angle where line intersects\n        const intersectRadians = Math.asin(lineY / radius);\n        const intersectDegrees = angle.toDegrees(intersectRadians);\n\n        //line may intersect in 2 places\n        const intersectX = Math.cos(intersectRadians) * radius;\n        intersectionBetweenEndpoints(-intersectX, 180 - intersectDegrees);\n        intersectionBetweenEndpoints(intersectX, intersectDegrees);\n    }\n\n    if (anglesOfIntersection.length > 0) {\n        return anglesOfIntersection;\n    }\n\n    return null;\n}\n\n/**\n * @private\n */\nfunction circleToCircle(circle1: IPathCircle, circle2: IPathCircle, options: IPathIntersectionOptions): number[][] {\n\n    //no-op if either circle is degenerate\n    if (circle1.radius <= 0 || circle2.radius <= 0) {\n        return null;\n    }\n\n    //see if circles are the same\n    if (circle1.radius == circle2.radius && equal.isPointEqual(circle1.origin, circle2.origin, .0001)) {\n        options.out_AreOverlapped = true;\n        return null;\n    }\n\n    //clone circle1 and move to origin\n    const c1 = new Circle(point.zero(), circle1.radius);\n\n    //clone circle2 and move relative to circle1\n    const c2 = new Circle(point.subtract(circle2.origin, circle1.origin), circle2.radius);\n\n    //rotate circle2 to horizontal, c2 will be to the right of the origin.\n    const c2Angle = angle.ofPointInDegrees(point.zero(), c2.origin);\n    rotate(c2, -c2Angle, point.zero());\n\n    const unRotate = (resultAngle: number): number => {\n        const unrotated = resultAngle + c2Angle;\n        return angle.noRevolutions(unrotated);\n    }\n\n    //get X of c2 origin\n    const x = c2.origin[0];\n\n    //see if circles are tangent interior on left side\n    if (round(c2.radius - x - c1.radius) == 0) {\n\n        if (options.excludeTangents) {\n            return null;\n        }\n\n        return [[unRotate(180)], [unRotate(180)]];\n    }\n\n    //see if circles are tangent interior on right side\n    if (round(c2.radius + x - c1.radius) == 0) {\n\n        if (options.excludeTangents) {\n            return null;\n        }\n\n        return [[unRotate(0)], [unRotate(0)]];\n    }\n\n    //see if circles are tangent exterior\n    if (round(x - c2.radius - c1.radius) == 0) {\n\n        if (options.excludeTangents) {\n            return null;\n        }\n\n        return [[unRotate(0)], [unRotate(180)]];\n    }\n\n    //see if c2 is outside of c1\n    if (round(x - c2.radius) > c1.radius) {\n        return null;\n    }\n\n    //see if c2 is within c1\n    if (round(x + c2.radius) < c1.radius) {\n        return null;\n    }\n\n    //see if c1 is within c2\n    if (round(x - c2.radius) < -c1.radius) {\n        return null;\n    }\n\n    const bothAngles = (oneAngle: number): number[] => {\n        return [unRotate(oneAngle), unRotate(angle.mirror(oneAngle, false, true))];\n    }\n\n    const c1IntersectionAngle = solvers.solveTriangleSSS(c2.radius, c1.radius, x);\n    const c2IntersectionAngle = solvers.solveTriangleSSS(c1.radius, x, c2.radius);\n\n    return [bothAngles(c1IntersectionAngle), bothAngles(180 - c2IntersectionAngle)];\n}\n","import { IPathCircle } from './schema.js';\nimport { round } from './maker.js';\nimport * as angle from './angle.js';\nimport * as paths from './paths.js';\nimport * as measure from './measure.js';\nimport { intersection } from './intersect.js';\n\nconst equilateral = Math.sqrt(3) / 2;\n\n/** Solves for the altitude of an equilateral triangle when you know its side length. */\nexport function equilateralAltitude(sideLength: number) {\n    return sideLength * equilateral;\n}\n\n/** Solves for the side length of an equilateral triangle when you know its altitude. */\nexport function equilateralSide(altitude: number) {\n    return altitude / equilateral;\n}\n\n/** Solves for the angle of a triangle when you know lengths of 3 sides. */\nexport function solveTriangleSSS(lengthA: number, lengthB: number, lengthC: number): number {\n    return angle.toDegrees(Math.acos((lengthB * lengthB + lengthC * lengthC - lengthA * lengthA) / (2 * lengthB * lengthC)));\n}\n\n/** Solves for the length of a side of a triangle when you know length of one side and 2 angles. */\nexport function solveTriangleASA(oppositeAngleInDegrees: number, lengthOfSideBetweenAngles: number, otherAngleInDegrees: number): number {\n    const angleOppositeSide = 180 - oppositeAngleInDegrees - otherAngleInDegrees;\n    return (lengthOfSideBetweenAngles * Math.sin(angle.toRadians(oppositeAngleInDegrees))) / Math.sin(angle.toRadians(angleOppositeSide));\n}\n\n/** Solves for the angles of the tangent lines between 2 circles. */\nexport function circleTangentAngles(a: IPathCircle, b: IPathCircle, inner = false): number[] {\n    const connect = new paths.Line(a.origin, b.origin);\n    const distance = measure.pointDistance(a.origin, b.origin);\n\n    // no tangents if either circle encompasses the other\n    if (a.radius >= distance + b.radius || b.radius >= distance + a.radius) return null;\n\n    // no inner tangents when circles touch or overlap\n    if (inner && (a.radius + b.radius >= distance)) return null;\n\n    let tangentAngles: number[];\n\n    if (!inner && round(a.radius - b.radius) == 0) {\n        tangentAngles = [90, 270];\n    } else {\n        // solve for circles on the x axis at the distance\n        const d2 = distance / 2;\n        const between = new paths.Circle([d2, 0], d2);\n        const diff = new paths.Circle(a.radius > b.radius ? [0, 0] : [distance, 0], inner ? (a.radius + b.radius) : Math.abs(a.radius - b.radius));\n        const int = intersection(diff, between);\n\n        if (!int || !int.path1Angles) return null;\n\n        tangentAngles = int.path1Angles;\n    }\n\n    const connectAngle = angle.ofLineInDegrees(connect);\n\n    // add the line's angle to the result\n    return tangentAngles.map(a => angle.noRevolutions(a + connectAngle));\n}","// ES Module imports\nimport type {\n    IModel, IModelMap, IPath, IPathArc, IPathBezierSeed, IPathCircle, IPathLine, IPoint\n} from './schema.js';\nimport type {\n    IMeasure, IMeasureWithCenter, IMeasureMap, ISlope, IBoundingHex,\n    IPathIntersectionOptions, IMeasurePointInsideOptions, IWalkOptions, IWalkPath, IWalkModel, IChain\n} from './maker.js';\nimport { pathType, cloneObject, createRouteKey, round } from './maker.js';\nimport * as angle from './angle.js';\nimport * as point from './point.js';\nimport * as path from './path.js';\nimport * as paths from './paths.js';\nimport * as model from './model.js';\nimport * as chain from './chain.js';\nimport * as solvers from './solvers.js';\nimport * as models from '../models/index.js';\nimport { isPointEqual, isPointDistinct, isPointOnSlope } from './equal.js';\nimport { intersection } from './intersect.js';\nimport grahamScanModule from 'graham_scan';\n\ninterface IGrahamScan {\n    addPoint(x: number, y: number): void;\n    getHull(): { x: number; y: number }[];\n}\n\ntype GrahamScanConstructor = new () => IGrahamScan;\nconst GrahamScan = (grahamScanModule as unknown as { default?: GrahamScanConstructor }).default ?? (grahamScanModule as unknown as GrahamScanConstructor);\n\n/**\n * Interface to Math.min and Math.max functions.\n * \n * @private\n */\ninterface IMathMinMax {\n    (...values: number[]): number;\n}\n\n/**\n * Increase a measurement by an additional measurement.\n * \n * @param baseMeasure The measurement to increase.\n * @param addMeasure The additional measurement.\n * @param augmentBaseMeasure Optional flag to call measure.augment on the measurement.\n * @returns The increased original measurement (for cascading).\n */\nexport function increase(baseMeasure: IMeasure, addMeasure: IMeasure, augmentBaseMeasure?: boolean): IMeasure {\n\n        function getExtreme(basePoint: IPoint, newPoint: IPoint, fn: IMathMinMax) {\n\n            if (!newPoint) return;\n\n            for (var i = 2; i--;) {\n                if (newPoint[i] == null) continue;\n\n                if (basePoint[i] == null) {\n                    basePoint[i] = newPoint[i];\n                } else {\n                    basePoint[i] = fn(basePoint[i], newPoint[i]);\n                }\n            }\n\n        }\n\n        if (addMeasure) {\n            getExtreme(baseMeasure.low, addMeasure.low, Math.min);\n            getExtreme(baseMeasure.high, addMeasure.high, Math.max);\n        }\n\n        if (augmentBaseMeasure) {\n            augment(baseMeasure);\n        }\n\n        return baseMeasure;\n    }\n\n    /**\n     * Check for arc being concave or convex towards a given point.\n     * \n     * @param arc The arc to test.\n     * @param towardsPoint The point to test.\n     * @returns Boolean true if arc is concave towards point.\n     */\n    export function isArcConcaveTowardsPoint(arc: IPathArc, towardsPoint: IPoint): boolean {\n\n        if (pointDistance(arc.origin, towardsPoint) <= arc.radius) {\n            return true;\n        }\n\n        var midPointToNearPoint = new paths.Line(point.middle(arc), towardsPoint);\n        var options: IPathIntersectionOptions = {};\n        const intersectionPoint = intersection(midPointToNearPoint, new paths.Chord(arc), options);\n\n        if (intersectionPoint || options.out_AreOverlapped) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * DEPRECATED - use isArcSpanOverlapping() instead.\n     */\n    export function isArcOverlapping(arcA: IPathArc, arcB: IPathArc, excludeTangents: boolean): boolean {\n        return isArcSpanOverlapping(arcA, arcB, excludeTangents);\n    }\n\n    /**\n     * Check for arc overlapping another arc.\n     * \n     * @param arcA The arc to test.\n     * @param arcB The arc to check for overlap.\n     * @param excludeTangents Boolean to exclude exact endpoints and only look for deep overlaps.\n     * @returns Boolean true if arcA is overlapped with arcB.\n     */\n    export function isArcSpanOverlapping(arcA: IPathArc, arcB: IPathArc, excludeTangents: boolean): boolean {\n        var pointsOfIntersection: IPoint[] = [];\n\n        function checkAngles(a: IPathArc, b: IPathArc) {\n\n            function checkAngle(n: number) {\n                return isBetweenArcAngles(n, a, excludeTangents);\n            }\n\n            return checkAngle(b.startAngle) || checkAngle(b.endAngle);\n        }\n\n        return checkAngles(arcA, arcB) || checkAngles(arcB, arcA) || (arcA.startAngle == arcB.startAngle && arcA.endAngle == arcB.endAngle);\n    }\n\n    /**\n     * Check if a given number is between two given limits.\n     * \n     * @param valueInQuestion The number to test.\n     * @param limitA First limit.\n     * @param limitB Second limit.\n     * @param exclusive Flag to exclude equaling the limits.\n     * @returns Boolean true if value is between (or equal to) the limits.\n     */\n    export function isBetween(valueInQuestion: number, limitA: number, limitB: number, exclusive: boolean): boolean {\n        if (exclusive) {\n            return Math.min(limitA, limitB) < valueInQuestion && valueInQuestion < Math.max(limitA, limitB);\n        } else {\n            return Math.min(limitA, limitB) <= valueInQuestion && valueInQuestion <= Math.max(limitA, limitB);\n        }\n    }\n\n    /**\n     * Check if a given angle is between an arc's start and end angles.\n     * \n     * @param angleInQuestion The angle to test.\n     * @param arc Arc to test against.\n     * @param exclusive Flag to exclude equaling the start or end angles.\n     * @returns Boolean true if angle is between (or equal to) the arc's start and end angles.\n     */\n    export function isBetweenArcAngles(angleInQuestion: number, arc: IPathArc, exclusive: boolean): boolean {\n\n        var startAngle = angle.noRevolutions(arc.startAngle);\n        var span = angle.ofArcSpan(arc);\n        var endAngle = startAngle + span;\n\n        angleInQuestion = angle.noRevolutions(angleInQuestion);\n\n        //computed angles will not be negative, but the arc may have specified a negative angle, so check against one revolution forward and backward\n        return (isBetween(angleInQuestion, startAngle, endAngle, exclusive) || isBetween(angleInQuestion, startAngle + 360, endAngle + 360, exclusive) || isBetween(angleInQuestion, startAngle - 360, endAngle - 360, exclusive))\n    }\n\n    /**\n     * Check if a given point is between a line's end points.\n     * \n     * @param pointInQuestion The point to test.\n     * @param line Line to test against.\n     * @param exclusive Flag to exclude equaling the origin or end points.\n     * @returns Boolean true if point is between (or equal to) the line's origin and end points.\n     */\n    export function isBetweenPoints(pointInQuestion: IPoint, line: IPathLine, exclusive: boolean): boolean {\n        var oneDimension = false;\n        for (var i = 2; i--;) {\n            if (round(line.origin[i] - line.end[i], .000001) == 0) {\n                if (oneDimension) return false;\n                oneDimension = true;\n                continue;\n            }\n            var origin_value = round(line.origin[i]);\n            var end_value = round(line.end[i]);\n            if (!isBetween(round(pointInQuestion[i]), origin_value, end_value, exclusive)) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Check if a given bezier seed has all points on the same slope.\n     * \n     * @param seed The bezier seed to test.\n     * @param exclusive Optional boolean to test only within the boundary of the endpoints.\n     * @returns Boolean true if bezier seed has control points on the line slope and between the line endpoints.\n     */\n    export function isBezierSeedLinear(seed: IPathBezierSeed, exclusive?: boolean): boolean {\n\n        //create a slope from the endpoints\n        var slope = lineSlope(seed);\n\n        for (var i = 0; i < seed.controls.length; i++) {\n            if (!(isPointOnSlope(seed.controls[i], slope))) {\n                if (!exclusive) return false;\n                if (isBetweenPoints(seed.controls[i], seed, false)) return false;\n            }\n        }\n\n        return true;\n    }\n\n\n    /**\n     * @private\n     */\n    function serializePoint(p: number[]) {\n        return p.join(',');\n    }\n\n    /**\n     * Check for flow of paths in a chain being clockwise or not.\n     * \n     * @param chainContext The chain to test.\n     * @param out_result Optional output object, if provided, will be populated with convex hull results.\n     * @returns Boolean true if paths in the chain flow clockwise.\n     */\n    export function isChainClockwise(chainContext: IChain, out_result?: { hullPoints?: IPoint[], keyPoints?: IPoint[] }): boolean {\n\n        //cannot do non-endless or circle\n        if (!chainContext.endless || chainContext.links.length === 1) {\n            return null;\n        }\n\n        var keyPoints = chain.toKeyPoints(chainContext);\n\n        return isPointArrayClockwise(keyPoints, out_result);\n    }\n\n    /**\n     * Check for array of points being clockwise or not.\n     * \n     * @param points The array of points to test.\n     * @param out_result Optional output object, if provided, will be populated with convex hull results.\n     * @returns Boolean true if points flow clockwise.\n     */\n    export function isPointArrayClockwise(points: IPoint[], out_result?: { hullPoints?: IPoint[], keyPoints?: IPoint[] }) {\n        const convexHull = new GrahamScan();\n        var pointsInOrder: string[] = [];\n\n        function add(endPoint: IPoint) {\n            convexHull.addPoint(endPoint[0], endPoint[1]);\n            pointsInOrder.push(serializePoint(endPoint as number[]));\n        }\n\n        points.forEach(add);\n\n        //we only need to deal with 3 points\n        var hull = convexHull.getHull();\n        var hullPoints = hull.slice(0, 3).map((p): string => serializePoint([p.x, p.y]));\n        var ordered: string[] = [];\n        pointsInOrder.forEach(p => {\n            if (~hullPoints.indexOf(p)) ordered.push(p);\n        });\n\n        //now make sure endpoints of hull are endpoints of ordered. do this by managing the middle point\n        switch (ordered.indexOf(hullPoints[1])) {\n            case 0:\n                //shift down\n                ordered.unshift(ordered.pop());\n                break;\n            case 2:\n                //shift up\n                ordered.push(ordered.shift());\n                break;\n        }\n\n        if (out_result) {\n            out_result.hullPoints = hull.map(p => [p.x, p.y]);\n            out_result.keyPoints = points;\n        }\n\n        //the hull is counterclockwise, so the result is clockwise if the first elements do not match\n        return hullPoints[0] != ordered[0];\n    }\n\n    /**\n     * Check for line overlapping another line.\n     * \n     * @param lineA The line to test.\n     * @param lineB The line to check for overlap.\n     * @param excludeTangents Boolean to exclude exact endpoints and only look for deep overlaps.\n     * @returns Boolean true if lineA is overlapped with lineB.\n     */\n    export function isLineOverlapping(lineA: IPathLine, lineB: IPathLine, excludeTangents: boolean): boolean {\n        var pointsOfIntersection: IPoint[] = [];\n\n        function checkPoints(index: number, a: IPathLine, b: IPathLine) {\n\n            function checkPoint(p: IPoint) {\n                return isBetweenPoints(p, a, excludeTangents);\n            }\n\n            return checkPoint(b.origin) || checkPoint(b.end);\n        }\n\n        return checkPoints(0, lineA, lineB) || checkPoints(1, lineB, lineA);\n    }\n\n    /**\n     * Check for measurement overlapping another measurement.\n     * \n     * @param measureA The measurement to test.\n     * @param measureB The measurement to check for overlap.\n     * @returns Boolean true if measureA is overlapped with measureB.\n     */\n    export function isMeasurementOverlapping(measureA: IMeasure, measureB: IMeasure): boolean {\n        for (var i = 2; i--;) {\n            if (!(round(measureA.low[i] - measureB.high[i]) <= 0 && round(measureA.high[i] - measureB.low[i]) >= 0)) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Gets the slope of a line.\n     */\n    export function lineSlope(line: IPathLine): ISlope {\n        var dx = line.end[0] - line.origin[0];\n        if (round(dx, .000001) == 0) {\n            return {\n                line: line,\n                hasSlope: false\n            };\n        }\n\n        var dy = line.end[1] - line.origin[1];\n\n        var slope = dy / dx;\n        var yIntercept = line.origin[1] - slope * line.origin[0];\n\n        return {\n            line: line,\n            hasSlope: true,\n            slope: slope,\n            yIntercept: yIntercept\n        };\n    }\n\n    /**\n     * Calculates the distance between two points.\n     * \n     * @param a First point.\n     * @param b Second point.\n     * @returns Distance between points.\n     */\n    export function pointDistance(a: IPoint, b: IPoint): number {\n        var dx = b[0] - a[0];\n        var dy = b[1] - a[1];\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * @private\n     */\n    function getExtremePoint(a: IPoint, b: IPoint, fn: IMathMinMax): IPoint {\n        return [\n            fn(a[0], b[0]),\n            fn(a[1], b[1])\n        ];\n    }\n\n    /**\n     * @private\n     */\n    var pathExtentsMap: { [pathType: string]: (pathToMeasure: IPath) => IMeasure } = {};\n\n    pathExtentsMap[pathType.Line] = function (line: IPathLine): IMeasure {\n        return {\n            low: getExtremePoint(line.origin, line.end, Math.min),\n            high: getExtremePoint(line.origin, line.end, Math.max)\n        }\n    }\n\n    pathExtentsMap[pathType.Circle] = function (circle: IPathCircle): IMeasure {\n        var r = circle.radius;\n        return {\n            low: point.add(circle.origin, [-r, -r]),\n            high: point.add(circle.origin, [r, r])\n        }\n    }\n\n    pathExtentsMap[pathType.Arc] = function (arc: IPathArc): IMeasure {\n        var r = arc.radius;\n        var arcPoints = point.fromArc(arc);\n\n        function extremeAngle(xyAngle: number[], value: number, fn: IMathMinMax): IPoint {\n            var extremePoint = getExtremePoint(arcPoints[0], arcPoints[1], fn);\n\n            for (var i = 2; i--;) {\n                if (isBetweenArcAngles(xyAngle[i], arc, false)) {\n                    extremePoint[i] = value + arc.origin[i];\n                }\n            }\n\n            return extremePoint;\n        }\n\n        return {\n            low: extremeAngle([180, 270], -r, Math.min),\n            high: extremeAngle([360, 90], r, Math.max)\n        }\n    }\n\n    /**\n     * Calculates the smallest rectangle which contains a path.\n     * \n     * @param pathToMeasure The path to measure.\n     * @returns object with low and high points.\n     */\n    export function pathExtents(pathToMeasure: IPath, addOffset?: IPoint): IMeasure {\n\n        if (pathToMeasure) {\n            var fn = pathExtentsMap[pathToMeasure.type];\n            if (fn) {\n                var m = fn(pathToMeasure);\n\n                if (addOffset) {\n                    m.high = point.add(m.high, addOffset);\n                    m.low = point.add(m.low, addOffset);\n                }\n\n                return m;\n            }\n        }\n\n        return { low: null, high: null };\n    }\n\n    /**\n     * @private\n     */\n    var pathLengthMap: { [pathType: string]: (pathToMeasure: IPath) => number } = {};\n\n    pathLengthMap[pathType.Line] = function (line: IPathLine) {\n        return pointDistance(line.origin, line.end);\n    }\n\n    pathLengthMap[pathType.Circle] = function (circle: IPathCircle) {\n        return 2 * Math.PI * circle.radius;\n    }\n\n    pathLengthMap[pathType.Arc] = function (arc: IPathArc) {\n        var value = pathLengthMap[pathType.Circle](arc);\n        var pct = angle.ofArcSpan(arc) / 360;\n        value *= pct;\n        return value;\n    }\n\n    pathLengthMap[pathType.BezierSeed] = function (seed: IPathBezierSeed) {\n        // BezierCurve not yet converted to ES modules\n        if ('BezierCurve' in models && (models as any).BezierCurve?.computeLength) {\n            return (models as any).BezierCurve.computeLength(seed);\n        }\n        return 0;\n    }\n\n    /**\n     * Measures the length of a path.\n     * \n     * @param pathToMeasure The path to measure.\n     * @returns Length of the path.\n     */\n    export function pathLength(pathToMeasure: IPath): number {\n\n        if (pathToMeasure) {\n            var fn = pathLengthMap[pathToMeasure.type];\n            if (fn) {\n                return fn(pathToMeasure);\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n     * Measures the length of all paths in a model.\n     * \n     * @param modelToMeasure The model containing paths to measure.\n     * @returns Length of all paths in the model.\n     */\n    export function modelPathLength(modelToMeasure: IModel): number {\n        var total = 0;\n\n        model.walk(modelToMeasure, {\n            onPath: function (walkedPath: IWalkPath) {\n                total += pathLength(walkedPath.pathContext);\n            }\n        });\n\n        return total;\n    }\n\n    /**\n     * @private\n     */\n    function cloneMeasure(measureToclone: IMeasure): IMeasure {\n        return {\n            high: point.clone(measureToclone.high),\n            low: point.clone(measureToclone.low)\n        };\n    }\n\n    /**\n     * Measures the smallest rectangle which contains a model.\n     * \n     * @param modelToMeasure The model to measure.\n     * @param atlas Optional atlas to save measurements.\n     * @returns object with low and high points.\n     */\n    export function modelExtents(modelToMeasure: IModel, atlas?: Atlas): IMeasureWithCenter | null {\n\n        function increaseParentModel(childRoute: string[], childMeasurement: IMeasure) {\n\n            if (!childMeasurement) return;\n\n            //to get the parent route, just traverse backwards 2 to remove id and 'paths' / 'models'\n            var parentRoute = childRoute.slice(0, -2);\n            var parentRouteKey = createRouteKey(parentRoute);\n\n            if (!(parentRouteKey in atlas.modelMap)) {\n                //just start with the known size\n                atlas.modelMap[parentRouteKey] = cloneMeasure(childMeasurement);\n            } else {\n                increase(atlas.modelMap[parentRouteKey], childMeasurement);\n            }\n        }\n\n        if (!atlas) atlas = new Atlas(modelToMeasure);\n\n        var walkOptions: IWalkOptions = {\n            onPath: function (walkedPath: IWalkPath) {\n\n                //trust that the path measurement is good\n                if (!(walkedPath.routeKey in atlas.pathMap)) {\n                    atlas.pathMap[walkedPath.routeKey] = pathExtents(walkedPath.pathContext, walkedPath.offset);\n                }\n\n                increaseParentModel(walkedPath.route, atlas.pathMap[walkedPath.routeKey]);\n            },\n            afterChildWalk: function (walkedModel: IWalkModel) {\n                //model has been updated by all its children, update parent\n                increaseParentModel(walkedModel.route, atlas.modelMap[walkedModel.routeKey]);\n            }\n        };\n\n        model.walk(modelToMeasure, walkOptions);\n\n        atlas.modelsMeasured = true;\n\n        var m = atlas.modelMap[''] as IMeasureWithCenter;\n\n        if (m) {\n            return augment(m);\n        }\n\n        return null;\n    }\n\n\n    /**\n     * Augment a measurement - add more properties such as center point, height and width.\n     * \n     * @param measureToAugment The measurement to augment.\n     * @returns Measurement object with augmented properties.\n     */\n    export function augment(measureToAugment: IMeasure): IMeasureWithCenter {\n\n        var m = measureToAugment as IMeasureWithCenter;\n\n        m.center = point.average(m.high, m.low);\n        m.width = m.high[0] - m.low[0];\n        m.height = m.high[1] - m.low[1];\n\n        return m;\n    }\n\n    /**\n     * A list of maps of measurements.\n     * \n     * @param modelToMeasure The model to measure.\n     * @param atlas Optional atlas to save measurements.\n     * @returns object with low and high points.\n     */\n    export class Atlas {\n\n        /**\n         * Flag that models have been measured.\n         */\n        public modelsMeasured = false;\n\n        /**\n         * Map of model measurements, mapped by routeKey.\n         */\n        public modelMap: IMeasureMap = {};\n\n        /**\n         * Map of path measurements, mapped by routeKey.\n         */\n        public pathMap: IMeasureMap = {};\n\n        /**\n         * Constructor.\n         * @param modelContext The model to measure.\n         */\n        constructor(public modelContext: IModel) {\n        }\n\n        public measureModels() {\n            if (!this.modelsMeasured) {\n                modelExtents(this.modelContext, this);\n            }\n        }\n    }\n\n    /**\n     * @private\n     */\n    function loopIndex(base: number, i: number) {\n        if (i >= base) return i - base;\n        if (i < 0) return i + base;\n        return i;\n    }\n\n    /**\n     * @private\n     */\n    function yAtX(slope: ISlope, x: number) {\n        return slope.slope * x + slope.yIntercept;\n    }\n\n    /**\n     * @private\n     */\n    function pointOnSlopeAtX(line: IPathLine, x: number): IPoint {\n        var slope = lineSlope(line);\n        return [x, yAtX(slope, x)];\n    }\n\n    /**\n     * @private\n     */\n    interface IAngledBoundary {\n        index: number;\n        rotation: number;\n        center: IPoint;\n        width: number;\n        height: number;\n        top: IPathLine;\n        middle: IPathLine;\n        bottom: IPathLine;\n    }\n\n    /**\n     * @private\n     */\n    function isCircular(bounds: IAngledBoundary[]) {\n        for (var i = 1; i < 3; i++) {\n            if (!isPointEqual(bounds[0].center, bounds[i].center, .000001) || !(round(bounds[0].width - bounds[i].width) === 0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @private\n     */\n    function getAngledBounds(index: number, modelToMeasure: IModel, rotateModel: number, rotatePaths: number) {\n        model.rotate(modelToMeasure, rotateModel);\n        var m = modelExtents(modelToMeasure);\n        var result: IAngledBoundary = {\n            index: index,\n            rotation: rotatePaths,\n            center: point.rotate(m.center, rotatePaths),\n\n            //model is sideways, so width is based on Y, height is based on X\n            width: m.height,\n            height: m.width,\n\n            bottom: new paths.Line(m.low, [m.high[0], m.low[1]]),\n            middle: new paths.Line([m.low[0], m.center[1]], [m.high[0], m.center[1]]),\n            top: new paths.Line(m.high, [m.low[0], m.high[1]]),\n        };\n        [result.top, result.middle, result.bottom].forEach(line => path.rotate(line, rotatePaths));\n        return result;\n    }\n\n    /**\n     * @private\n     */\n    interface IHexSolution {\n        radius: number,\n        origin: IPoint,\n        type: string,\n        index?: number,\n    }\n\n    /**\n     * @private\n     */\n    function hexSolution(lines: IPathLine[], bounds: IAngledBoundary[]): IHexSolution {\n        var tip = lines[1].origin;\n        var tipX = tip[0];\n        var left = lines[3].origin[0];\n        var right = lines[0].origin[0];\n\n        //see if left edge is in bounds if right edge is on the hex boundary\n        var altRight = tipX - right;\n        if ((right - left) > 2 * altRight) return null;\n\n        //see if right edge is in bounds if left edge is on the hex boundary\n        var altLeft = (tipX - left) / 3;\n        if (altRight < altLeft) return null;\n\n        var altitudeViaSide = Math.min(altLeft, altRight);\n        var radiusViaSide = solvers.equilateralSide(altitudeViaSide);\n\n        //find peaks, then find highest peak\n        var peakPoints = [point.fromSlopeIntersection(lines[1], lines[2]), point.fromSlopeIntersection(lines[4], lines[5])];\n        var peakRadii = peakPoints.map(p => Math.abs(p[1] - tip[1]));\n        var peakNum = (peakRadii[0] > peakRadii[1]) ? 0 : 1;    //top = 0, bottom = 1\n        var radiusViaPeak = peakRadii[peakNum];\n\n        if (radiusViaPeak > radiusViaSide) {\n            var altitudeViaPeak = solvers.equilateralAltitude(radiusViaPeak);\n            var peakX = tipX - 2 * altitudeViaPeak;\n\n            //see if it will contain right side\n            if (right > peakX + altitudeViaPeak) return null;\n\n            //see if it will contain left side\n            if (left < peakX - altitudeViaPeak) return null;\n\n            //at this point, [tipX - 2 * altitudeViaPeak, tip[1]] is a solution for origin.\n            //but we want to best center the result by sliding along the boundary middle, balancing the smallest gap\n            var leftGap = left - peakX + altitudeViaPeak;\n            var peakGap = 2 * altitudeViaPeak - bounds[peakNum + 1].width;\n            var minHalfGap = Math.min(leftGap, peakGap) / 2;\n\n            return {\n                origin: pointOnSlopeAtX(bounds[2 - peakNum].middle, peakX + minHalfGap),\n                radius: radiusViaPeak,\n                type: 'peak ' + peakNum\n            };\n\n        } else {\n\n            return {\n                origin: [tipX - 2 * altitudeViaSide, tip[1]],\n                radius: radiusViaSide,\n                type: 'side'\n            };\n        }\n\n    }\n\n    /**\n     * Measures the minimum bounding hexagon surrounding a model. The hexagon is oriented such that the right and left sides are vertical, and the top and bottom are pointed.\n     * \n     * @param modelToMeasure The model to measure.\n     * @returns IBoundingHex object which is a hexagon model, with an additional radius property.\n     */\n    export function boundingHexagon(modelToMeasure: IModel): IBoundingHex {\n        var clone = cloneObject(modelToMeasure) as IModel;\n        model.originate(clone);\n        var originalMeasure = modelExtents(clone);\n        var bounds: IAngledBoundary[] = [];\n        var scratch: IModel = { paths: {} };\n\n        model.center(clone);\n\n        function result(radius: number, origin: IPoint, notes: string): IBoundingHex {\n            return {\n                radius: radius,\n                paths: new models.Polygon(6, radius, 30).paths,\n                origin: point.add(origin, originalMeasure.center),\n                //models: { scratch: scratch },\n                notes: notes\n            };\n        }\n\n        var boundRotations = [[90, -90], [-60, -30], [-60, 30]];\n\n        while (boundRotations.length) {\n            var rotation = boundRotations.shift();\n            var bound = getAngledBounds(bounds.length, clone, rotation[0], rotation[1]);\n\n            var side = solvers.equilateralSide(bound.width / 2);\n            if (side >= bound.height) {\n                return result(side, bound.center, 'solved by bound ' + bounds.length);\n            }\n\n            bounds.push(bound);\n        }\n\n        //model.rotate(clone, 30);\n        //scratch.models = { clone: clone };\n\n        //check for a circular solution\n        if (isCircular(bounds)) {\n            return result(solvers.equilateralSide(bounds[0].width / 2), bounds[0].center, 'solved as circular');\n        }\n\n        var perimeters = bounds.map(b => b.top).concat(bounds.map(b => b.bottom));\n\n        perimeters.forEach((p, i) => {\n            scratch.paths[i] = p;\n\n            //converge alternate lines to form two triangles\n            path.converge(perimeters[loopIndex(6, i + 2)], p, true);\n        });\n\n        bounds.forEach((b, i) => {\n            scratch.paths['m' + i] = b.middle;\n        });\n\n        var boundCopy = bounds.slice();\n        var solution: IHexSolution;\n\n        //solve a hexagon for every tip, keeping the smallest one\n        for (var i = 0; i < 6; i++) {\n\n            //rotate the scratch area so that we always reference the tip at polar 0\n            if (i > 0) {\n                perimeters.push(perimeters.shift());\n                boundCopy.push(boundCopy.shift());\n                model.rotate(scratch, -60);\n            }\n\n            var s = hexSolution(perimeters, boundCopy);\n            if (s) {\n                if (!solution || s.radius < solution.radius) {\n                    solution = s;\n                    solution.index = i;\n                }\n            }\n        }\n\n        var p = point.rotate(solution.origin, solution.index * 60);\n\n        return result(solution.radius, p, 'solved by ' + solution.index + ' as ' + solution.type);\n    }\n\n    /**\n     * @private\n     */\n    function addUniquePoints(pointArray: IPoint[], pointsToAdd: IPoint[]): number {\n\n        var added = 0;\n\n        pointsToAdd.forEach(p => {\n            if (!isPointDistinct(p, pointArray, .00000001)) return;\n            pointArray.push(p);\n            added++;\n        });\n\n        return added;\n    }\n\n    /**\n     * @private\n     */\n    function getFarPoint(modelContext: IModel, farPoint?: IPoint, measureAtlas?: Atlas) {\n        if (farPoint) return farPoint;\n\n        var high = modelExtents(modelContext).high;\n        if (high) {\n            return point.add(high, [1, 1]);\n        }\n\n        return [7654321, 1234567];\n    }\n\n    /**\n     * Check to see if a point is inside of a model.\n     * \n     * @param pointToCheck The point to check.\n     * @param modelContext The model to check against.\n     * @param options Optional IMeasurePointInsideOptions object.\n     * @returns Boolean true if the path is inside of the modelContext.\n     */\n    export function isPointInsideModel(pointToCheck: IPoint, modelContext: IModel, options: IMeasurePointInsideOptions = {}): boolean {\n        if (!options.farPoint) {\n            options.farPoint = getFarPoint(modelContext, options.farPoint, options.measureAtlas);\n        }\n\n        options.out_intersectionPoints = [];\n\n        var isInside: boolean;\n        var lineToFarPoint = new paths.Line(pointToCheck, options.farPoint);\n        var measureFarPoint = pathExtents(lineToFarPoint);\n\n        var walkOptions: IWalkOptions = {\n            onPath: function (walkedPath: IWalkPath) {\n\n                if (options.measureAtlas && !isMeasurementOverlapping(measureFarPoint, options.measureAtlas.pathMap[walkedPath.routeKey])) {\n                    return;\n                }\n\n                var intersectOptions: IPathIntersectionOptions = { path2Offset: walkedPath.offset };\n                const farInt = intersection(lineToFarPoint, walkedPath.pathContext, intersectOptions);\n\n                if (farInt) {\n                    var added = addUniquePoints(options.out_intersectionPoints, farInt.intersectionPoints);\n\n                    //if number of intersections is an odd number, flip the flag.\n                    if (added % 2 == 1) {\n                        isInside = !!!isInside;\n                    }\n                }\n            },\n            beforeChildWalk: function (innerWalkedModel: IWalkModel): boolean {\n\n                if (!options.measureAtlas) {\n                    return true;\n                }\n\n                //see if there is a model measurement. if not, it is because the model does not contain paths.\n                var innerModelMeasurement = options.measureAtlas.modelMap[innerWalkedModel.routeKey];\n                return innerModelMeasurement && isMeasurementOverlapping(measureFarPoint, innerModelMeasurement);\n            }\n        };\n        model.walk(modelContext, walkOptions);\n\n        return !!isInside;\n    }\n\n    /** Re-export point equality functions for backward compatibility with makerjs API. */\n    export { isPointEqual, isPointDistinct, isPointOnSlope } from './equal.js';\n","import { IPoint, IPath, IPathLine, IPathCircle, IPathArc, IPathBezierSeed } from './schema.js';\nimport { round, pathType } from './maker.js';\nimport type { ISlope, IPathIntersectionBaseOptions } from './maker.js';\nimport * as angle from './angle.js';\nimport * as measure from './measure.js';\nimport * as equal from './equal.js';\n\n// TEMP: These will be available after respective modules are converted\ndeclare const models: any;\n\n/** Add two points together and return the result as a new point object. */\nexport function add(a: IPoint, b: IPoint, subtract?: boolean): IPoint {\n    const newPoint = clone(a);\n    if (!b) return newPoint;\n    for (let i = 2; i--;) {\n        if (subtract) {\n            newPoint[i] -= b[i];\n        } else {\n            newPoint[i] += b[i];\n        }\n    }\n    return newPoint;\n}\n\n/** Get the average of two points. */\nexport function average(a: IPoint, b: IPoint): IPoint {\n    const avg = (i: number): number => (a[i] + b[i]) / 2;\n    return [avg(0), avg(1)];\n}\n\n/** Clone a point into a new point. */\nexport function clone(pointToClone: IPoint): IPoint {\n    if (!pointToClone) return zero();\n    return [pointToClone[0], pointToClone[1]];\n}\n\n/** From an array of points, find the closest point to a given reference point. */\nexport function closest(referencePoint: IPoint, pointOptions: IPoint[]): IPoint {\n    const smallest = { index: 0, distance: -1 };\n    for (let i = 0; i < pointOptions.length; i++) {\n        const distance = measure.pointDistance(referencePoint, pointOptions[i]);\n        if (smallest.distance == -1 || distance < smallest.distance) {\n            smallest.distance = distance;\n            smallest.index = i;\n        }\n    }\n    return pointOptions[smallest.index];\n}\n\nconst zero_cos: { [index: number]: boolean } = {};\nzero_cos[Math.PI / 2] = true;\nzero_cos[3 * Math.PI / 2] = true;\n\nconst zero_sin: { [index: number]: boolean } = {};\nzero_sin[Math.PI] = true;\nzero_sin[2 * Math.PI] = true;\n\n/** Get a point from its polar coordinates. */\nexport function fromPolar(angleInRadians: number, radius: number): IPoint {\n        return [\n            (angleInRadians in zero_cos) ? 0 : round(radius * Math.cos(angleInRadians)),\n            (angleInRadians in zero_sin) ? 0 : round(radius * Math.sin(angleInRadians))\n        ];\n    }\n\n/** Get a point on a circle or arc path, at a given angle. */\nexport function fromAngleOnCircle(angleInDegrees: number, circle: IPathCircle): IPoint {\n        return add(circle.origin, fromPolar(angle.toRadians(angleInDegrees), circle.radius));\n    }\n\n/** Get the two end points of an arc path. */\nexport function fromArc(arc: IPathArc): IPoint[] {\n        return [fromAngleOnCircle(arc.startAngle, arc), fromAngleOnCircle(arc.endAngle, arc)];\n    }\n\nconst pathEndsMap: { [type: string]: (pathValue: IPath) => IPoint[] } = {};\n\npathEndsMap[pathType.Arc] = (arc: IPathArc) => fromArc(arc);\npathEndsMap[pathType.Line] = (line: IPathLine) => [line.origin, line.end];\npathEndsMap[pathType.BezierSeed] = pathEndsMap[pathType.Line];\n\n/** Get the two end points of a path. */\nexport function fromPathEnds(pathContext: IPath, pathOffset?: IPoint): IPoint[] {\n    let result: IPoint[] = null;\n    const fn = pathEndsMap[pathContext.type];\n    if (fn) {\n        result = fn(pathContext);\n        if (pathOffset) {\n            result = result.map((p: IPoint) => add(p, pathOffset));\n        }\n    }\n    return result;\n}\n\nfunction verticalIntersectionPoint(verticalLine: IPathLine, nonVerticalSlope: ISlope): IPoint {\n    const x = verticalLine.origin[0];\n    const y = nonVerticalSlope.slope * x + nonVerticalSlope.yIntercept;\n    return [x, y];\n}\n\n/** Calculates the intersection of slopes of two lines. */\nexport function fromSlopeIntersection(lineA: IPathLine, lineB: IPathLine, options: IPathIntersectionBaseOptions = {}): IPoint {\n    const slopeA = measure.lineSlope(lineA);\n    const slopeB = measure.lineSlope(lineB);\n\n    if (equal.isSlopeParallel(slopeA, slopeB)) {\n        if (equal.isSlopeEqual(slopeA, slopeB)) {\n            options.out_AreOverlapped = measure.isLineOverlapping(lineA, lineB, options.excludeTangents);\n        }\n        return null;\n    }\n\n    let pointOfIntersection: IPoint;\n    if (!slopeA.hasSlope) {\n        pointOfIntersection = verticalIntersectionPoint(lineA, slopeB);\n    } else if (!slopeB.hasSlope) {\n        pointOfIntersection = verticalIntersectionPoint(lineB, slopeA);\n    } else {\n        const x = (slopeB.yIntercept - slopeA.yIntercept) / (slopeA.slope - slopeB.slope);\n        const y = slopeA.slope * x + slopeA.yIntercept;\n        pointOfIntersection = [x, y];\n    }\n    return pointOfIntersection;\n}\n\nfunction midCircle(circle: IPathCircle, midAngle: number) {\n    return add(circle.origin, fromPolar(angle.toRadians(midAngle), circle.radius));\n}\n\nconst middleMap: { [type: string]: (pathValue: IPath, ratio: number) => IPoint } = {};\n\nmiddleMap[pathType.Arc] = (arc: IPathArc, ratio: number) => {\n    const midAngle = angle.ofArcMiddle(arc, ratio);\n    return midCircle(arc, midAngle);\n};\n\nmiddleMap[pathType.Circle] = (circle: IPathCircle, ratio: number) => midCircle(circle, 360 * ratio);\n\nmiddleMap[pathType.Line] = (line: IPathLine, ratio: number) => {\n    const ration = (a: number, b: number): number => a + (b - a) * ratio;\n    return [ration(line.origin[0], line.end[0]), ration(line.origin[1], line.end[1])];\n};\n\nmiddleMap[pathType.BezierSeed] = (seed: IPathBezierSeed, ratio: number) => models.BezierCurve.computePoint(seed, ratio);\n\n/** Get the middle point of a path. */\nexport function middle(pathContext: IPath, ratio = .5): IPoint {\n    let midPoint: IPoint = null;\n    const fn = middleMap[pathContext.type];\n    if (fn) {\n        midPoint = fn(pathContext, ratio);\n    }\n    return midPoint;\n}\n\n/** Create a clone of a point, mirrored on either or both x and y axes. */\nexport function mirror(pointToMirror: IPoint, mirrorX: boolean, mirrorY: boolean): IPoint {\n    const p = clone(pointToMirror);\n    if (mirrorX) p[0] = -p[0];\n    if (mirrorY) p[1] = -p[1];\n    return p;\n}\n\n/** Round the values of a point. */\nexport function rounded(pointContext: IPoint, accuracy?: number): IPoint {\n        return [round(pointContext[0], accuracy), round(pointContext[1], accuracy)];\n    }\n\n/** Rotate a point. */\nexport function rotate(pointToRotate: IPoint, angleInDegrees: number, rotationOrigin: IPoint = [0, 0]): IPoint {\n    const pointAngleInRadians = angle.ofPointInRadians(rotationOrigin, pointToRotate);\n    const d = measure.pointDistance(rotationOrigin, pointToRotate);\n    const rotatedPoint = fromPolar(pointAngleInRadians + angle.toRadians(angleInDegrees), d);\n    return add(rotationOrigin, rotatedPoint);\n}\n\n/** Scale a point's coordinates. */\nexport function scale(pointToScale: IPoint, scaleValue: number): IPoint {\n    const p = clone(pointToScale);\n    for (let i = 2; i--;) {\n        p[i] *= scaleValue;\n    }\n    return p;\n}\n\n/** Distort a point's coordinates. */\nexport function distort(pointToDistort: IPoint, scaleX: number, scaleY: number): IPoint {\n        return [pointToDistort[0] * scaleX, pointToDistort[1] * scaleY];\n    }\n\n/** Subtract a point from another point, and return the result as a new point. */\nexport function subtract(a: IPoint, b: IPoint): IPoint {\n        return add(a, b, true);\n    }\n\n/** A point at 0,0 coordinates. */\nexport function zero(): IPoint {\n    return [0, 0];\n}\n\n/** Test to see if an object implements the required properties of a point. */\nexport { isPoint } from './maker.js';\n","import { IPoint, IPathLine, IPathCircle, IPathArc } from './schema.js';\nimport { pathType, round, isNumber, isPoint } from './maker.js';\nimport * as point from './point.js';\nimport * as angle from './angle.js';\nimport * as path from './path.js';\nimport { intersection } from './intersect.js';\nimport * as measure from './measure.js';\n\nconst distance2D = (a: IPoint, b: IPoint) => {\n    const dx = b[0] - a[0];\n    const dy = b[1] - a[1];\n    return Math.sqrt(dx * dx + dy * dy);\n};\n\ninterface IArcSpan {\n    origin: IPoint;\n    startAngle: number;\n    endAngle: number;\n    size: number;\n}\n\n/** Class for arc path. */\nexport class Arc implements IPathArc {\n        public origin: IPoint;\n        public radius: number;\n        public startAngle: number;\n        public endAngle: number;\n        public type: string;\n\n        /**\n         * Class for arc path, created from origin point, radius, start angle, and end angle.\n         * \n         * @param origin The center point of the arc.\n         * @param radius The radius of the arc.\n         * @param startAngle The start angle of the arc.\n         * @param endAngle The end angle of the arc.\n         */\n        constructor(origin: IPoint, radius: number, startAngle: number, endAngle: number);\n\n        /**\n         * Class for arc path, created from 2 points, radius, large Arc flag, and clockwise flag.\n         * \n         * @param pointA First end point of the arc.\n         * @param pointB Second end point of the arc.\n         * @param radius The radius of the arc.\n         * @param largeArc Boolean flag to indicate clockwise direction.\n         * @param clockwise Boolean flag to indicate clockwise direction.\n         */\n        constructor(pointA: IPoint, pointB: IPoint, radius: number, largeArc: boolean, clockwise: boolean);\n\n        /**\n         * Class for arc path, created from 2 points and optional boolean flag indicating clockwise.\n         * \n         * @param pointA First end point of the arc.\n         * @param pointB Second end point of the arc.\n         * @param clockwise Boolean flag to indicate clockwise direction.\n         */\n        constructor(pointA: IPoint, pointB: IPoint, clockwise?: boolean);\n\n        /**\n         * Class for arc path, created from 3 points.\n         * \n         * @param pointA First end point of the arc.\n         * @param pointB Middle point on the arc.\n         * @param pointC Second end point of the arc.\n         */\n        constructor(pointA: IPoint, pointB: IPoint, pointC: IPoint);\n\n        constructor(...args: any[]) {\n\n            function getSpan(origin: IPoint): IArcSpan {\n                var startAngle = angle.ofPointInDegrees(origin, args[clockwise ? 1 : 0]);\n                var endAngle = angle.ofPointInDegrees(origin, args[clockwise ? 0 : 1]);\n\n                if (endAngle < startAngle) {\n                    endAngle += 360;\n                }\n\n                return {\n                    origin: origin,\n                    startAngle: startAngle,\n                    endAngle: endAngle,\n                    size: endAngle - startAngle\n                };\n            }\n\n            switch (args.length) {\n\n                case 5:\n                    //SVG style arc designation\n\n                    var pointA = args[0] as IPoint;\n                    var pointB = args[1] as IPoint;\n                    this.radius = args[2] as number;\n                    var largeArc = args[3] as boolean;\n                    var clockwise = args[4] as boolean;\n                    var span: IArcSpan;\n\n                    //make sure arc can reach. if not, scale up.\n                    var smallestRadius = distance2D(pointA, pointB) / 2;\n                    if (round(this.radius - smallestRadius) <= 0) {\n                        this.radius = smallestRadius;\n\n                        span = getSpan(point.average(pointA, pointB));\n\n                    } else {\n\n                        //find the 2 potential origins\n                        let intersectionPoints = intersection(\n                            new Circle(pointA, this.radius),\n                            new Circle(pointB, this.radius)\n                        )?.intersectionPoints ?? [pointA, pointB];\n\n                        var spans: IArcSpan[] = [];\n\n                        for (var i = intersectionPoints.length; i--;) {\n                            span = getSpan(intersectionPoints[i])\n\n                            //insert sorted by size ascending\n                            if (spans.length == 0 || span.size > spans[0].size) {\n                                spans.push(span);\n                            } else {\n                                spans.unshift(span);\n                            }\n                        }\n\n                        var index = largeArc ? 1 : 0;\n                        span = spans[index];\n                    }\n\n                    this.origin = span.origin;\n                    this.startAngle = span.startAngle;\n                    this.endAngle = span.endAngle;\n\n                    break;\n\n                case 4:\n                    this.origin = args[0];\n                    this.radius = args[1];\n                    this.startAngle = args[2];\n                    this.endAngle = args[3];\n                    break;\n\n                case 3:\n\n                    if (isPoint(args[2])) {\n                        //from 3 points\n\n                        Circle.apply(this, args);\n\n                        var angles: number[] = [];\n                        for (let i = 0; i < 3; i++) {\n                            angles.push(angle.ofPointInDegrees(this.origin, args[i]));\n                        }\n\n                        this.startAngle = angles[0];\n                        this.endAngle = angles[2];\n\n                        //swap start and end angles if this arc does not contain the midpoint\n                        if (!measure.isBetweenArcAngles(angles[1], this as any, false)) {\n                            this.startAngle = angles[2];\n                            this.endAngle = angles[0];\n                        }\n\n                        //do not fall through if this was 3 points\n                        break;\n                    }\n\n                //fall through to below if 2 points\n\n                case 2:\n                    //from 2 points (and optional clockwise flag)\n                    var clockwise = args[2] as boolean;\n\n                    Circle.call(this, args[0], args[1]);\n\n                    this.startAngle = angle.ofPointInDegrees(this.origin, args[clockwise ? 1 : 0]);\n                    this.endAngle = angle.ofPointInDegrees(this.origin, args[clockwise ? 0 : 1]);\n\n                    break;\n            }\n\n            //do this after Circle.apply / Circle.call to make sure this is an arc\n            this.type = pathType.Arc;\n        }\n    }\n\n    /**\n     * Class for circle path.\n     */\n    export class Circle implements IPathCircle {\n        public type: string;\n        public origin: IPoint;\n        public radius: number;\n\n        /**\n         * Class for circle path, created from radius. Origin will be [0, 0].\n         * \n         * Example:\n         * ```\n         * var c = new makerjs.paths.Circle(7);\n         * ```\n         *\n         * @param radius The radius of the circle.\n         */\n        constructor(radius: number);\n\n        /**\n         * Class for circle path, created from origin point and radius.\n         *\n         * Example:\n         * ```\n         * var c = new makerjs.paths.Circle([10, 10], 7);\n         * ```\n         *\n         * @param origin The center point of the circle.\n         * @param radius The radius of the circle.\n         */\n        constructor(origin: IPoint, radius: number);\n\n        /**\n         * Class for circle path, created from 2 points.\n         *\n         * Example:\n         * ```\n         * var c = new makerjs.paths.Circle([5, 15], [25, 15]);\n         * ```\n         *\n         * @param pointA First point on the circle.\n         * @param pointB Second point on the circle.\n         */\n        constructor(pointA: IPoint, pointB: IPoint);\n\n        /**\n         * Class for circle path, created from 3 points.\n         *\n         * Example:\n         * ```\n         * var c = new makerjs.paths.Circle([0, 0], [0, 10], [20, 0]);\n         * ```\n         *\n         * @param pointA First point on the circle.\n         * @param pointB Second point on the circle.\n         * @param pointC Third point on the circle.\n         */\n        constructor(pointA: IPoint, pointB: IPoint, pointC: IPoint);\n\n        constructor(...args: any[]) {\n            this.type = pathType.Circle;\n\n            switch (args.length) {\n\n                case 1:\n                    this.origin = [0, 0];\n                    this.radius = args[0] as number;\n                    break;\n\n                case 2:\n                    if (isNumber(args[1])) {\n                        this.origin = args[0];\n                        this.radius = args[1];\n\n                    } else {\n                        //Circle from 2 points\n                        this.origin = point.average(args[0], args[1]);\n                        this.radius = distance2D(this.origin, args[0]);\n                    }\n                    break;\n\n                default:\n                    //Circle from 3 points\n\n                    //create 2 lines with 2nd point in common\n                    var lines: IPathLine[] = [\n                        new Line(args[0], args[1]),\n                        new Line(args[1], args[2])\n                    ];\n\n                    //create perpendicular lines\n                    var perpendiculars: IPathLine[] = [];\n                    for (var i = 2; i--;) {\n                        var midpoint = point.middle(lines[i]);\n                        perpendiculars.push(<IPathLine>path.rotate(lines[i], 90, midpoint));\n                    }\n\n                    //find intersection of slopes of perpendiculars\n                    var origin = point.fromSlopeIntersection(perpendiculars[0], perpendiculars[1]);\n\n                    if (origin) {\n                        this.origin = origin;\n\n                        //radius is distance to any of the 3 points\n                        this.radius = measure.pointDistance(this.origin, args[0]);\n\n                    } else {\n                        throw 'invalid parameters - attempted to construct a circle from 3 points on a line: ' + JSON.stringify(args);\n                    }\n\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Class for line path.\n     */\n    export class Line implements IPathLine {\n        public type: string;\n        public origin: IPoint;\n        public end: IPoint;\n\n        /**\n         * Class for line path, constructed from array of 2 points.\n         * \n         * @param points Array of 2 points.\n         */\n        constructor(points: IPoint[]);\n\n        /**\n         * Class for line path, constructed from 2 points.\n         * \n         * @param origin The origin point of the line.\n         * @param end The end point of the line.\n         */\n        constructor(origin: IPoint, end: IPoint);\n\n        constructor(...args: any[]) {\n            this.type = pathType.Line;\n\n            switch (args.length) {\n\n                case 1:\n                    var points = args[0] as IPoint[];\n                    this.origin = points[0];\n                    this.end = points[1];\n                    break;\n\n                case 2:\n                    this.origin = args[0] as IPoint;\n                    this.end = args[1] as IPoint;\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Class for chord, which is simply a line path that connects the endpoints of an arc.\n     * \n     * @param arc Arc to use as the basic for the chord.\n     */\n    export class Chord implements IPathLine {\n        public type: string;\n        public origin: IPoint;\n        public end: IPoint;\n\n        constructor(arc: IPathArc) {\n            var arcPoints = point.fromArc(arc);\n\n            this.type = pathType.Line;\n            this.origin = arcPoints[0];\n            this.end = arcPoints[1];\n        }\n    }\n\n    /**\n     * Class for a parallel line path.\n     * \n     * @param toLine A line to be parallel to.\n     * @param distance Distance between parallel and original line.\n     * @param nearPoint Any point to determine which side of the line to place the parallel.\n     */\n    export class Parallel implements IPathLine {\n        public type: string;\n        public origin: IPoint;\n        public end: IPoint;\n\n        constructor(toLine: IPathLine, distance: number, nearPoint: IPoint) {\n            this.type = pathType.Line;\n            this.origin = point.clone(toLine.origin);\n            this.end = point.clone(toLine.end);\n\n            var angleOfLine = angle.ofLineInDegrees(this);\n\n            function getNewOrigin(offsetAngle: number) {\n                var origin = point.add(toLine.origin, point.fromPolar(angle.toRadians(angleOfLine + offsetAngle), distance));\n                return {\n                    origin: origin,\n                    nearness: distance2D(origin, nearPoint)\n                };\n            }\n\n            var newOrigins = [getNewOrigin(-90), getNewOrigin(90)];\n            var newOrigin = (newOrigins[0].nearness < newOrigins[1].nearness) ? newOrigins[0].origin : newOrigins[1].origin;\n\n            path.move(this, newOrigin);\n        }\n    }\n","import { IModel, IPoint, IPathMap } from '../core/schema.js';\nimport { isPoint } from '../core/maker.js';\nimport type { IKit } from '../core/maker.js';\nimport * as paths from '../core/paths.js';\nimport * as measure from '../core/measure-minimal.js';\n\n// TEMP: These will be available after respective modules are converted\ndeclare const importer: any;\n\nfunction getPoints(arg: IPoint[] | number[] | string) {\n    let coords: number[];\n\n    if (Array.isArray(arg)) {\n        if (isPoint(arg[0])) {\n            return arg as IPoint[];\n        }\n        coords = arg as number[];\n    } else {\n        coords = importer.parseNumericList(arg as string);\n    }\n\n    const points: IPoint[] = [];\n    for (let i = 0; i < coords.length; i += 2) {\n        points.push([coords[i], coords[i + 1]]);\n    }\n\n    return points;\n}\n\nexport class ConnectTheDots implements IModel {\n    public paths: IPathMap = {};\n\n        /**\n         * Create a model by connecting points designated in a string. The model will be 'closed' - i.e. the last point will connect to the first point.\n         * \n         * Example:\n         * ```\n         * var c = new makerjs.models.ConnectTheDots('-10 0 10 0 0 20'); // 3 coordinates to form a triangle\n         * ```\n         * \n         * @param numericList String containing a list of numbers which can be delimited by spaces, commas, or anything non-numeric (Note: [exponential notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential) is allowed).\n         */\n        constructor(numericList: string);\n\n        /**\n         * Create a model by connecting points designated in a string. The model may be closed, or left open.\n         * \n         * Example:\n         * ```\n         * var c = new makerjs.models.ConnectTheDots(false, '-10 0 10 0 0 20'); // 3 coordinates to form a polyline\n         * ```\n         * \n         * @param isClosed Flag to specify if last point should connect to the first point.\n         * @param numericList String containing a list of numbers which can be delimited by spaces, commas, or anything non-numeric (Note: [exponential notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential) is allowed).\n         */\n        constructor(isClosed: boolean, numericList: string);\n\n        /**\n         * Create a model by connecting points designated in a numeric array. The model will be 'closed' - i.e. the last point will connect to the first point.\n         * \n         * Example:\n         * ```\n         * var c = new makerjs.models.ConnectTheDots([-10, 0, 10, 0, 0, 20]); // 3 coordinates to form a triangle\n         * ```\n         * \n         * @param coords Array of coordinates.\n         */\n        constructor(coords: number[]);\n\n        /**\n         * Create a model by connecting points designated in a numeric array. The model may be closed, or left open.\n         * \n         * Example:\n         * ```\n         * var c = new makerjs.models.ConnectTheDots(false, [-10, 0, 10, 0, 0, 20]); // 3 coordinates to form a polyline\n         * ```\n         * \n         * @param isClosed Flag to specify if last point should connect to the first point.\n         * @param coords Array of coordinates.\n         */\n        constructor(isClosed: boolean, coords: number[]);\n\n        /**\n         * Create a model by connecting points designated in an array of points. The model may be closed, or left open.\n         * \n         * Example:\n         * ```\n         * var c = new makerjs.models.ConnectTheDots(false, [[-10, 0], [10, 0], [0, 20]]); // 3 coordinates left open\n         * ```\n         * \n         * @param isClosed Flag to specify if last point should connect to the first point.\n         * @param points Array of IPoints.\n         */\n        constructor(isClosed: boolean, points: IPoint[]);\n\n        constructor(...args: any[]) {\n            let isClosed: boolean;\n            let points: IPoint[];\n\n            switch (args.length) {\n                case 1:\n                    isClosed = true;\n                    points = getPoints(args[0]);\n                    break;\n\n                case 2:\n                    isClosed = args[0] as boolean;\n                    points = getPoints(args[1]);\n                    break;\n            }\n\n            let lineIndex = 0;\n            const connect = (a: number, b: number, skipZeroDistance = false) => {\n                if (skipZeroDistance && measure.pointDistance(points[a], points[b]) == 0) return;\n                this.paths[\"ShapeLine\" + lineIndex] = new paths.Line(points[a], points[b]);\n                lineIndex++;\n            };\n\n            for (let i = 1; i < points.length; i++) {\n                connect(i - 1, i);\n            }\n\n            if (isClosed && points.length > 2) {\n                connect(points.length - 1, 0, true);\n            }\n        }\n    }\n\n(ConnectTheDots as any as IKit).metaParameters = [\n    { title: \"closed\", type: \"bool\", value: true },\n    {\n        title: \"points\", type: \"select\", value: [\n            [[0, 0], [40, 40], [60, 20], [100, 100], [60, 60], [40, 80]],\n            [[0, 0], [100, 0], [50, 87]],\n            [-10, 0, 10, 0, 0, 20],\n            '-10 0 10 0 0 20',\n        ]\n    }\n];\n","import { IModel, IPoint, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport * as paths from '../core/paths.js';\n\nexport class Holes implements IModel {\n    public paths: IPathMap = {};\n\n    /** Create an array of circles of the same radius from an array of center points. */\n    constructor(holeRadius: number, points: IPoint[], ids?: string[]) {\n        for (let i = 0; i < points.length; i++) {\n            const id = ids ? ids[i] : i.toString();\n            this.paths[id] = new paths.Circle(points[i], holeRadius);\n        }\n    }\n}\n\n(Holes as any as IKit).metaParameters = [\n    { title: \"holeRadius\", type: \"range\", min: .1, max: 10, step: .1, value: 1 },\n    {\n        title: \"points\", type: \"select\", value: [\n            [[0, 0], [10, 10], [20, 20], [30, 30], [40, 40], [50, 50], [60, 60], [70, 70], [80, 80]],\n            [[0, 0], [0, 25], [0, 50], [0, 75], [0, 100], [25, 50], [50, 50], [75, 50], [100, 100], [100, 75], [100, 50], [100, 25], [100, 0]]]\n    }\n];\n","import { IModel, IPoint, IPathMap } from '../core/schema.js';\nimport { isObject, isModel } from '../core/maker.js';\nimport type { IKit, IMeasure } from '../core/maker.js';\nimport * as point from '../core/point.js';\nimport * as measure from '../core/measure-minimal.js';\nimport { ConnectTheDots } from './ConnectTheDots.js';\n\nexport class Rectangle implements IModel {\n    public paths: IPathMap = {};\n    public origin: IPoint;\n\n    /**\n     * Create a rectangle from width and height.\n     *\n     * Example:\n     * ```\n     * //Create a rectangle from width and height\n     * import * as makerjs from 'maker.js';\n     * const model = new makerjs.models.Rectangle(50, 100);\n     * const svg = makerjs.exporter.toSVG(model);\n     * document.write(svg);\n     * ```\n     *\n     * @param width Width of the rectangle.\n     * @param height Height of the rectangle.\n     */\n    constructor(width: number, height: number);\n\n    /**\n     * Create a rectangle which will surround a model.\n     *\n     * Example:\n     * ```\n     * //Create a rectangle which will surround a model\n     * import * as makerjs from 'maker.js';\n     * const e = new makerjs.models.Ellipse(17, 10); // draw an ellipse so we have something to surround.\n     * const r = new makerjs.models.Rectangle(e, 3); // draws a rectangle surrounding the ellipse by 3 units.\n     * const svg = makerjs.exporter.toSVG({ models: { e, r } });\n     * document.write(svg);\n     * ```\n     *\n     * @param modelToSurround IModel object.\n     * @param margin Optional distance from the model.\n     */\n    constructor(modelToSurround: IModel, margin?: number);\n\n    /**\n     * Create a rectangle from a measurement.\n     *\n     * Example:\n     * ```\n     * //Create a rectangle from a measurement.\n     * import * as makerjs from 'maker.js';\n     * const e = new makerjs.models.Ellipse(17, 10); // draw an ellipse so we have something to measure.\n     * const m = makerjs.measure.modelExtents(e);    // measure the ellipse.\n     * const r = new makerjs.models.Rectangle(m);    // draws a rectangle surrounding the ellipse.\n     * const svg = makerjs.exporter.toSVG({ models: { e, r } });\n     * document.write(svg);\n     * ```\n     *\n     * @param measurement IMeasure object. See http://maker.js.org/docs/api/modules/makerjs.measure.html#pathextents and http://maker.js.org/docs/api/modules/makerjs.measure.html#modelextents to get measurements of paths and models.\n     */\n    constructor(measurement: IMeasure);\n\n    constructor(...args: any[]) {\n        let width: number;\n        let height: number;\n\n        if (args.length === 2 && !isObject(args[0])) {\n            width = args[0] as number;\n            height = args[1] as number;\n        } else {\n            let margin = 0;\n            let m: IMeasure;\n\n            if (isModel(args[0])) {\n                m = measure.modelExtents(args[0] as IModel);\n                if (args.length === 2) {\n                    margin = args[1] as number;\n                }\n            } else {\n                // use measurement\n                m = args[0] as IMeasure;\n            }\n\n            this.origin = point.subtract(m.low, [margin, margin]);\n\n            width = m.high[0] - m.low[0] + 2 * margin;\n            height = m.high[1] - m.low[1] + 2 * margin;\n        }\n\n        this.paths = new ConnectTheDots(true, [[0, 0], [width, 0], [width, height], [0, height]]).paths;\n    }\n}\n\n(Rectangle as any as IKit).metaParameters = [\n    { title: \"width\", type: \"range\", min: 1, max: 100, value: 50 },\n    { title: \"height\", type: \"range\", min: 1, max: 100, value: 100 }\n];\n","import { IModel, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport { Rectangle } from './Rectangle.js';\n\nexport class Square implements IModel {\n    public paths: IPathMap = {};\n\n    constructor(side: number) {\n        this.paths = new Rectangle(side, side).paths;\n    }\n}\n\n(Square as any as IKit).metaParameters = [\n    { title: \"side\", type: \"range\", min: 1, max: 100, value: 100 }\n];\n","import { IModel, IPoint, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport * as angle from '../core/angle.js';\nimport * as point from '../core/point.js';\nimport { ConnectTheDots } from './ConnectTheDots.js';\n\nexport class Polygon implements IModel {\n    public paths: IPathMap = {};\n\n    constructor(numberOfSides: number, radius: number, firstCornerAngleInDegrees?: number, circumscribed?: boolean) {\n        this.paths = new ConnectTheDots(true, Polygon.getPoints(numberOfSides, radius, firstCornerAngleInDegrees, circumscribed)).paths;\n    }\n\n    public static circumscribedRadius(radius: number, angleInRadians: number) {\n        return radius / Math.cos(angleInRadians / 2);\n    }\n\n    public static getPoints(numberOfSides: number, radius: number, firstCornerAngleInDegrees = 0, circumscribed = false): IPoint[] {\n        const points = [];\n\n        const a1 = angle.toRadians(firstCornerAngleInDegrees);\n        const a = 2 * Math.PI / numberOfSides;\n\n        if (circumscribed) {\n            radius = Polygon.circumscribedRadius(radius, a);\n        }\n\n        for (let i = 0; i < numberOfSides; i++) {\n            points.push(point.fromPolar(a * i + a1, radius));\n        }\n\n        return points;\n    }\n}\n\n(Polygon as any as IKit).metaParameters = [\n    { title: \"number of sides\", type: \"range\", min: 3, max: 24, value: 6 },\n    { title: \"radius\", type: \"range\", min: 1, max: 100, value: 50 },\n    { title: \"offset angle\", type: \"range\", min: 0, max: 180, value: 0 },\n    { title: \"radius on flats (vs radius on vertexes)\", type: \"bool\", value: false }\n];\n","import { IModel, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport * as point from '../core/point.js';\nimport * as paths from '../core/paths.js';\n\nexport class Ring implements IModel {\n    public paths: IPathMap = {};\n\n    constructor(outerRadius: number, innerRadius?: number) {\n        const radii = {\n            \"Ring_outer\": outerRadius,\n            \"Ring_inner\": innerRadius\n        };\n\n        for (const id in radii) {\n            const r = radii[id];\n            if (r === undefined || r <= 0) continue;\n            this.paths[id] = new paths.Circle(point.zero(), r);\n        }\n    }\n}\n\n(Ring as any as IKit).metaParameters = [\n    { title: \"outer radius\", type: \"range\", min: 0, max: 100, step: 1, value: 50 },\n    { title: \"inner radius\", type: \"range\", min: 0, max: 100, step: 1, value: 20 }\n];\n","import { IModel, IPoint, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport { Polygon } from './Polygon.js';\nimport { ConnectTheDots } from './ConnectTheDots.js';\n\nexport class Star implements IModel {\n    public paths: IPathMap = {};\n\n    constructor(numberOfPoints: number, outerRadius: number, innerRadius?: number, skipPoints: number = 2) {\n        if (!innerRadius) {\n            innerRadius = outerRadius * Star.InnerRadiusRatio(numberOfPoints, skipPoints);\n        }\n\n        const outerPoints = Polygon.getPoints(numberOfPoints, outerRadius);\n        const innerPoints = Polygon.getPoints(numberOfPoints, innerRadius, 180 / numberOfPoints);\n\n        const allPoints: IPoint[] = [];\n\n        for (let i = 0; i < numberOfPoints; i++) {\n            allPoints.push(outerPoints[i]);\n            allPoints.push(innerPoints[i]);\n        }\n\n        const model = new ConnectTheDots(true, allPoints);\n        this.paths = model.paths;\n        delete model.paths;\n    }\n\n    public static InnerRadiusRatio(numberOfPoints: number, skipPoints: number): number {\n        // formula from http://www.jdawiseman.com/papers/easymath/surds_star_inner_radius.html\n        // Cos(Pi()*m/n) / Cos(Pi()*(m-1)/n)\n        if (numberOfPoints > 0 && skipPoints > 1 && skipPoints < numberOfPoints / 2) {\n            return Math.cos(Math.PI * skipPoints / numberOfPoints) / Math.cos(Math.PI * (skipPoints - 1) / numberOfPoints);\n        }\n        return 0;\n    }\n}\n\n(Star as any as IKit).metaParameters = [\n    { title: \"number of sides\", type: \"range\", min: 3, max: 24, value: 8 },\n    { title: \"outer radius\", type: \"range\", min: 1, max: 100, value: 50 },\n    { title: \"inner radius\", type: \"range\", min: 0, max: 100, value: 15 },\n    { title: \"skip points (when inner radius is zero)\", type: \"range\", min: 0, max: 12, value: 2 }\n];\n","import { IModel, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport * as paths from '../core/paths.js';\n\nexport class Dome implements IModel {\n    public paths: IPathMap = {};\n\n    constructor(width: number, height: number, radius?: number, bottomless?: boolean) {\n        const w2 = width / 2;\n\n        if (radius < 0) radius = 0;\n        if (radius === void 0) radius = w2;\n        radius = Math.min(radius, w2);\n        radius = Math.min(radius, height);\n        const wt = Math.max(w2 - radius, 0);\n        const hr = Math.max(height - radius, 0);\n\n        if (!bottomless) {\n            this.paths[\"Bottom\"] = new paths.Line([-w2, 0], [w2, 0]);\n        }\n    \n        if (hr) {\n            this.paths[\"Left\"] = new paths.Line([-w2, 0], [-w2, hr]);\n            this.paths[\"Right\"] = new paths.Line([w2, 0], [w2, hr]);\n        }\n\n        if (radius > 0) {\n            this.paths[\"TopLeft\"] = new paths.Arc([-wt, hr], radius, 90, 180);\n            this.paths[\"TopRight\"] = new paths.Arc([wt, hr], radius, 0, 90);\n        }\n\n        if (wt) {\n            this.paths[\"Top\"] = new paths.Line([-wt, height], [wt, height]);\n        }\n    }\n}\n\n(Dome as any as IKit).metaParameters = [\n    { title: \"width\", type: \"range\", min: 1, max: 100, value: 50 },\n    { title: \"height\", type: \"range\", min: 1, max: 100, value: 100 },\n    { title: \"radius\", type: \"range\", min: 0, max: 50, value: 25 },\n    { title: \"bottomless\", type: \"bool\", value: false }\n];\n","import { IModel, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport { Polygon } from './Polygon.js';\nimport { Holes } from './Holes.js';\n\nexport class BoltCircle implements IModel {\n    public paths: IPathMap = {};\n\n    constructor(boltRadius: number, holeRadius: number, boltCount: number, firstBoltAngleInDegrees: number = 0) {\n        const points = Polygon.getPoints(boltCount, boltRadius, firstBoltAngleInDegrees);\n        const ids = points.map((p, i) => \"bolt \" + i);\n        this.paths = new Holes(holeRadius, points, ids).paths;\n    }\n}\n\n(BoltCircle as any as IKit).metaParameters = [\n    { title: \"bolt circle radius\", type: \"range\", min: 1, max: 100, value: 50 },\n    { title: \"hole radius\", type: \"range\", min: 1, max: 50, value: 5 },\n    { title: \"bolt count\", type: \"range\", min: 3, max: 24, value: 12 },\n    { title: \"offset angle\", type: \"range\", min: 0, max: 180, value: 0 }\n];\n","import { IModel, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport { Holes } from './Holes.js';\n\nexport class BoltRectangle implements IModel {\n    public paths: IPathMap = {};\n\n    constructor(width: number, height: number, holeRadius: number) {\n        const points = [[0, 0], [width, 0], [width, height], [0, height]];\n        const ids = [\"BottomLeft_bolt\", \"BottomRight_bolt\", \"TopRight_bolt\", \"TopLeft_bolt\"];\n        this.paths = new Holes(holeRadius, points, ids).paths;\n    }\n}\n\n(BoltRectangle as any as IKit).metaParameters = [\n    { title: \"width\", type: \"range\", min: 1, max: 100, value: 100 },\n    { title: \"height\", type: \"range\", min: 1, max: 100, value: 50 },\n    { title: \"hole radius\", type: \"range\", min: 1, max: 50, value: 5 }\n];\n","import { IModel, IPoint, IPathMap } from '../core/schema.js';\nimport type { IKit, IMeasure } from '../core/maker.js';\nimport * as point from '../core/point.js';\nimport * as paths from '../core/paths.js';\nimport * as measure from '../core/measure-minimal.js';\n\nexport class RoundRectangle implements IModel {\n    public origin: IPoint;\n    public paths: IPathMap = {};\n\n        /**\n         * Create a round rectangle from width, height, and corner radius.\n         * \n         * Example:\n         * ```\n         * var r = new makerjs.models.RoundRectangle(100, 50, 5);\n         * ```\n         * \n         * @param width Width of the rectangle.\n         * @param height Height of the rectangle.\n         * @param radius Corner radius.\n         */\n        constructor(width: number, height: number, radius: number);\n\n        /**\n         * Create a round rectangle which will surround a model.\n         * \n         * Example:\n         * ```\n         * var b = new makerjs.models.BoltRectangle(30, 20, 1); //draw a bolt rectangle so we have something to surround\n         * var r = new makerjs.models.RoundRectangle(b, 2.5);   //surround it\n         * ```\n         * \n         * @param modelToSurround IModel object.\n         * @param margin Distance from the model. This will also become the corner radius.\n         */\n        constructor(modelToSurround: IModel, margin: number);\n\n        constructor(...args: any[]) {\n            let width: number;\n            let height: number;\n            let radius = 0;\n\n            switch (args.length) {\n                case 3:\n                    width = args[0] as number;\n                    height = args[1] as number;\n                    radius = args[2] as number;\n                    break;\n\n                case 2:\n                    radius = args[1] as number;\n                    // fall through to 1\n\n                case 1:\n                    const m = measure.modelExtents(args[0] as IModel);\n                    this.origin = point.subtract(m.low, [radius, radius]);\n\n                    width = m.high[0] - m.low[0] + 2 * radius;\n                    height = m.high[1] - m.low[1] + 2 * radius;\n                    break;\n            }\n\n            const maxRadius = Math.min(height, width) / 2;\n            radius = Math.min(radius, maxRadius);\n\n            const wr = width - radius;\n            const hr = height - radius;\n\n            if (radius > 0) {\n                this.paths[\"BottomLeft\"] = new paths.Arc([radius, radius], radius, 180, 270);\n                this.paths[\"BottomRight\"] = new paths.Arc([wr, radius], radius, 270, 0);\n                this.paths[\"TopRight\"] = new paths.Arc([wr, hr], radius, 0, 90);\n                this.paths[\"TopLeft\"] = new paths.Arc([radius, hr], radius, 90, 180);\n            }\n\n            if (wr - radius > 0) {\n                this.paths[\"Bottom\"] = new paths.Line([radius, 0], [wr, 0]);\n                this.paths[\"Top\"] = new paths.Line([wr, height], [radius, height]);\n            }\n\n            if (hr - radius > 0) {\n                this.paths[\"Right\"] = new paths.Line([width, radius], [width, hr]);\n                this.paths[\"Left\"] = new paths.Line([0, hr], [0, radius]);\n            }\n        }\n    }\n\n(RoundRectangle as any as IKit).metaParameters = [\n    { title: \"width\", type: \"range\", min: 1, max: 100, value: 50 },\n    { title: \"height\", type: \"range\", min: 1, max: 100, value: 100 },\n    { title: \"radius\", type: \"range\", min: 0, max: 50, value: 11 }\n];\n","import { IModel, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport { RoundRectangle } from './RoundRectangle.js';\n\nexport class Oval implements IModel {\n    public paths: IPathMap = {};\n\n    constructor(width: number, height: number) {\n        this.paths = new RoundRectangle(width, height, Math.min(height / 2, width / 2)).paths;\n    }\n}\n\n(Oval as any as IKit).metaParameters = [\n    { title: \"width\", type: \"range\", min: 1, max: 100, value: 50 },\n    { title: \"height\", type: \"range\", min: 1, max: 100, value: 100 }\n];\n","import { IModel, IPoint, IPath, IPathMap, IModelMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport * as angle from '../core/angle.js';\nimport * as paths from '../core/paths.js';\nimport * as measure from '../core/measure-minimal.js';\n\n// TEMP: These will be available after respective modules are converted\ndeclare const model: any;\n\nexport class Slot implements IModel {\n    public paths: IPathMap = {};\n    public origin: IPoint;\n    public models: IModelMap;\n\n    constructor(origin: IPoint, endPoint: IPoint, radius: number, isolateCaps = false) {\n        let capRoot: IModel;\n\n        if (isolateCaps) {\n            capRoot = { models: {} };\n            this.models = { 'Caps': capRoot };\n        }\n\n        const addCap = (id: string, capPath: IPath) => {\n            let capModel: IModel;\n\n            if (isolateCaps) {\n                capModel = { paths: {} };\n                capRoot.models[id] = capModel;\n            } else {\n                capModel = this;\n            }\n\n            capModel.paths[id] = capPath;\n        };\n\n        const a = angle.ofPointInDegrees(origin, endPoint);\n        const len = measure.pointDistance(origin, endPoint);\n\n        this.paths['Top'] = new paths.Line([0, radius], [len, radius]);\n        this.paths['Bottom'] = new paths.Line([0, -radius], [len, -radius]);\n\n        addCap('StartCap', new paths.Arc([0, 0], radius, 90, 270));\n        addCap('EndCap', new paths.Arc([len, 0], radius, 270, 90));\n\n        model.rotate(this, a, [0, 0]);\n\n        this.origin = origin;\n    }\n}\n\n(Slot as any as IKit).metaParameters = [\n    {\n        title: \"origin\", type: \"select\", value: [\n            [0, 0],\n            [10, 0],\n            [10, 10]\n        ]\n    },\n    {\n        title: \"end\", type: \"select\", value: [\n            [80, 0],\n            [0, 30],\n            [10, 30]\n        ]\n    },\n    { title: \"radius\", type: \"range\", min: 1, max: 50, value: 10 }\n];\n","import { IModel, IPoint, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport * as angle from '../core/angle.js';\nimport * as path from '../core/path.js';\nimport * as paths from '../core/paths.js';\n\nexport class SCurve implements IModel {\n    public paths: IPathMap = {};\n\n    constructor(width: number, height: number) {\n        const findRadius = (x: number, y: number) => {\n            return x + (y * y - x * x) / (2 * x);\n        };\n\n        const h2 = height / 2;\n        const w2 = width / 2;\n        let radius: number;\n        let startAngle: number;\n        let endAngle: number;\n        let arcOrigin: IPoint;\n\n        if (width > height) {\n            radius = findRadius(h2, w2);\n            startAngle = 270;\n            endAngle = 360 - angle.toDegrees(Math.acos(w2 / radius));\n            arcOrigin = [0, radius];\n        } else {\n            radius = findRadius(w2, h2);\n            startAngle = 180 - angle.toDegrees(Math.asin(h2 / radius));\n            endAngle = 180;\n            arcOrigin = [radius, 0];\n        }\n\n        const curve = new paths.Arc(arcOrigin, radius, startAngle, endAngle);\n\n        this.paths['curve_start'] = curve;\n        this.paths['curve_end'] = path.moveRelative(path.mirror(curve, true, true), [width, height]);\n    }\n}\n\n(SCurve as any as IKit).metaParameters = [\n    { title: \"width\", type: \"range\", min: 1, max: 100, value: 50 },\n    { title: \"height\", type: \"range\", min: 1, max: 100, value: 100 }\n];\n","import { IModel, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport * as paths from '../core/paths.js';\n\nexport class Dogbone implements IModel {\n    public paths: IPathMap = {};\n\n    /** Create a dogbone from width, height, corner radius, style, and bottomless flag. */\n    constructor(width: number, height: number, radius: number, style = 0, bottomless = false) {\n        const maxSide = Math.min(height, width) / 2;\n        let maxRadius: number;\n\n        switch (style) {\n            case -1: // horizontal\n            case 1: // vertical\n                maxRadius = maxSide / 2;\n                break;\n\n            case 0: // equal\n            default:\n                maxRadius = maxSide * Math.SQRT2 / 2;\n                break;\n        }\n\n        radius = Math.min(radius, maxRadius);\n\n        let ax: number;\n        let ay: number;\n        let lx: number;\n        let ly: number;\n        let apexes: number[];\n\n        switch (style) {\n            case -1:\n                ax = 0;\n                ay = radius;\n                lx = 0;\n                ly = radius * 2;\n                apexes = [180, 0, 0, 180];\n                break;\n\n            case 1:\n                ax = radius;\n                ay = 0;\n                lx = radius * 2;\n                ly = 0;\n                apexes = [270, 270, 90, 90];\n                break;\n\n            case 0:\n            default:\n                ax = ay = radius / Math.SQRT2;\n                lx = ly = ax * 2;\n                apexes = [225, 315, 45, 135];\n                break;\n        }\n\n        if (bottomless) {\n            this.paths['Left'] = new paths.Line([0, 0], [0, height - ly]);\n            this.paths['Right'] = new paths.Line([width, 0], [width, height - ly]);\n        } else {\n            this.paths['Left'] = new paths.Line([0, ly], [0, height - ly]);\n            this.paths['Right'] = new paths.Line([width, ly], [width, height - ly]);\n            this.paths['Bottom'] = new paths.Line([lx, 0], [width - lx, 0]);\n            this.paths[\"BottomLeft\"] = new paths.Arc([ax, ay], radius, apexes[0] - 90, apexes[0] + 90);\n            this.paths[\"BottomRight\"] = new paths.Arc([width - ax, ay], radius, apexes[1] - 90, apexes[1] + 90);\n        }\n\n        this.paths[\"TopRight\"] = new paths.Arc([width - ax, height - ay], radius, apexes[2] - 90, apexes[2] + 90);\n        this.paths[\"TopLeft\"] = new paths.Arc([ax, height - ay], radius, apexes[3] - 90, apexes[3] + 90);\n        this.paths['Top'] = new paths.Line([lx, height], [width - lx, height]);\n    }\n}\n\n(Dogbone as any as IKit).metaParameters = [\n    { title: \"width\", type: \"range\", min: 1, max: 100, value: 50 },\n    { title: \"height\", type: \"range\", min: 1, max: 100, value: 100 },\n    { title: \"radius\", type: \"range\", min: 0, max: 50, value: 5 },\n    { title: \"style\", type: \"select\", value: [0, 1, -1] },\n    { title: \"bottomless\", type: \"bool\", value: false }\n];\n","import { IModel, IPathMap } from '../core/schema.js';\nimport type { IKit } from '../core/maker.js';\nimport * as point from '../core/point.js';\nimport * as paths from '../core/paths.js';\nimport * as solvers from '../core/solvers.js';\n\nexport class Belt implements IModel {\n    public paths: IPathMap = {};\n\n    constructor(leftRadius: number, distance: number, rightRadius: number) {\n        const left = new paths.Arc([0, 0], leftRadius, 0, 360);\n        const right = new paths.Arc([distance, 0], rightRadius, 0, 360);\n        const angles = solvers.circleTangentAngles(left, right);\n\n        if (!angles) {\n            this.paths[\"Belt\"] = new paths.Circle(Math.max(leftRadius, rightRadius));\n        } else {\n            angles.sort((a, b) => a - b);\n\n            left.startAngle = angles[0];\n            left.endAngle = angles[1];\n\n            right.startAngle = angles[1];\n            right.endAngle = angles[0];\n\n            this.paths[\"Left\"] = left;\n            this.paths[\"Right\"] = right;\n            this.paths[\"Top\"] = new paths.Line(point.fromAngleOnCircle(angles[0], left), point.fromAngleOnCircle(angles[0], right));\n            this.paths[\"Bottom\"] = new paths.Line(point.fromAngleOnCircle(angles[1], left), point.fromAngleOnCircle(angles[1], right));\n        }\n    }\n}\n\n(Belt as any as IKit).metaParameters = [\n    { title: \"left radius\", type: \"range\", min: 0, max: 100, value: 30 },\n    { title: \"distance between centers\", type: \"range\", min: 0, max: 100, value: 50 },\n    { title: \"right radius\", type: \"range\", min: 0, max: 100, value: 15 }\n];\n","import { IModel, IPathMap, IModelMap, IPathArc } from '../core/schema.js';\nimport { round } from '../core/maker.js';\nimport type { IKit } from '../core/maker.js';\nimport * as angle from '../core/angle.js';\nimport * as point from '../core/point.js';\nimport * as paths from '../core/paths.js';\nimport * as measure from '../core/measure-minimal.js';\nimport { intersection } from '../core/intersect.js';\n\nexport class OvalArc implements IModel {\n    public paths: IPathMap = {};\n    public models: IModelMap;\n\n    constructor(startAngle: number, endAngle: number, sweepRadius: number, slotRadius: number, selfIntersect = false, isolateCaps = false) {\n        let capRoot: IModel;\n\n        if (isolateCaps) {\n            capRoot = { models: {} };\n            this.models = { 'Caps': capRoot };\n        }\n\n        if (slotRadius <= 0 || sweepRadius <= 0) return;\n\n        startAngle = angle.noRevolutions(startAngle);\n        endAngle = angle.noRevolutions(endAngle);\n\n        if (round(startAngle - endAngle) == 0) return;\n\n        if (endAngle < startAngle) endAngle += 360;\n\n        const addCap = (id: string, tiltAngle: number, offsetStartAngle: number, offsetEndAngle: number): IPathArc => {\n            let capModel: IModel;\n\n            if (isolateCaps) {\n                capModel = { paths: {} };\n                capRoot.models[id] = capModel;\n            } else {\n                capModel = this;\n            }\n\n            return capModel.paths[id] = new paths.Arc(\n                point.fromPolar(angle.toRadians(tiltAngle), sweepRadius),\n                slotRadius,\n                tiltAngle + offsetStartAngle,\n                tiltAngle + offsetEndAngle);\n        };\n\n        const addSweep = (id: string, offsetRadius: number): IPathArc => {\n            return this.paths[id] = new paths.Arc(\n                [0, 0],\n                sweepRadius + offsetRadius,\n                startAngle,\n                endAngle);\n        };\n\n        addSweep(\"Outer\", slotRadius);\n\n        const hasInner = (sweepRadius - slotRadius) > 0;\n        if (hasInner) {\n            addSweep(\"Inner\", -slotRadius);\n        }\n\n        const caps = [];\n        caps.push(addCap(\"StartCap\", startAngle, 180, 0));\n        caps.push(addCap(\"EndCap\", endAngle, 0, 180));\n\n        // the distance between the cap origins\n        const d = measure.pointDistance(caps[0].origin, caps[1].origin);\n\n        if ((d / 2) < slotRadius) {\n            // the caps intersect\n            const int = intersection(caps[0], caps[1]);\n            if (int) {\n                if (!hasInner || !selfIntersect) {\n                    caps[0].startAngle = int.path1Angles[0];\n                    caps[1].endAngle = int.path2Angles[0];\n                }\n\n                if (!selfIntersect && hasInner && int.intersectionPoints.length == 2) {\n                    addCap(\"StartCap2\", startAngle, 180, 0).endAngle = int.path1Angles[1];\n                    addCap(\"EndCap2\", endAngle, 0, 180).startAngle = int.path2Angles[1] + 360;\n                }\n            }\n        }\n    }\n}\n\n(OvalArc as any as IKit).metaParameters = [\n    { title: \"start angle\", type: \"range\", min: -360, max: 360, step: 1, value: 180 },\n    { title: \"end angle\", type: \"range\", min: -360, max: 360, step: 1, value: 0 },\n    { title: \"sweep\", type: \"range\", min: 0, max: 100, step: 1, value: 50 },\n    { title: \"radius\", type: \"range\", min: 0, max: 100, step: 1, value: 15 },\n    { title: \"self intersect\", type: \"bool\", value: false }\n];\n","// ES Module imports\nimport type { IPoint, IPathArc, IPathBezierSeed, IModel, IModelMap } from '../core/schema.js';\nimport { pathType, isPoint, isPathArc } from '../core/maker.js';\nimport type { IKit } from '../core/maker.js';\nimport * as angle from '../core/angle.js';\nimport * as point from '../core/point.js';\nimport * as path from '../core/path.js';\nimport * as paths from '../core/paths.js';\nimport { BezierCurve } from './BezierCurve-esm.js';\n\n/**\n * @private\n * Our maximum circular arc span for accurate representation by a cubic curve.\n */\nconst maxBezierArcspan = 45;\n\n/**\n * @private\n */\nfunction controlYForCircularCubic(arcSpanInRadians: number): number {\n\n    //from http://pomax.github.io/bezierinfo/#circles_cubic\n    return 4 * (Math.tan(arcSpanInRadians / 4) / 3);\n\n}\n\n/**\n * @private\n */\nfunction controlPointsForCircularCubic(arc: IPathArc): IPoint[] {\n\n    const arcSpan = angle.ofArcSpan(arc);\n\n    //compute y for radius of 1\n    const y = controlYForCircularCubic(angle.toRadians(arcSpan));\n\n    //multiply by radius\n    const c1: IPoint = [arc.radius, arc.radius * y];\n\n    //get second control point by mirroring, then rotating\n    const c2 = point.rotate(point.mirror(c1, false, true), arcSpan, [0, 0]);\n\n    //rotate again to start angle, then offset by arc's origin\n    return [c1, c2].map(function (p: IPoint) { return point.add(arc.origin, point.rotate(p, arc.startAngle, [0, 0])); });\n}\n\n/**\n * @private\n */\nfunction bezierSeedFromArc(arc: IPathArc): IPathBezierSeed {\n    const span = angle.ofArcSpan(arc);\n    if (span <= 90) {\n        const endPoints = point.fromPathEnds(arc);\n        const controls = controlPointsForCircularCubic(arc);\n        return {\n            type: pathType.BezierSeed,\n            origin: endPoints[0],\n            controls: controls,\n            end: endPoints[1]\n        };\n    }\n    return null;\n}\n\nexport class Ellipse implements IModel {\n\n    public models: IModelMap = {};\n    public origin: IPoint;\n\n    /**\n     * Class for Ellipse created with 2 radii.\n     * \n     * @param radiusX The x radius of the ellipse.\n     * @param radiusY The y radius of the ellipse.\n     * @param accuracy Optional accuracy of the underlying BezierCurve.\n     */\n    constructor(radiusX: number, radiusY: number, accuracy?: number);\n\n    /**\n     * Class for Ellipse created at a specific origin and 2 radii.\n     * \n     * @param origin The center of the ellipse.\n     * @param radiusX The x radius of the ellipse.\n     * @param radiusY The y radius of the ellipse.\n     * @param accuracy Optional accuracy of the underlying BezierCurve.\n     */\n    constructor(origin: IPoint, radiusX: number, radiusY: number, accuracy?: number);\n\n    /**\n     * Class for Ellipse created at a specific x, y and 2 radii.\n     *\n     * @param cx The x coordinate of the center of the ellipse.\n     * @param cy The y coordinate of the center of the ellipse.\n     * @param rX The x radius of the ellipse.\n     * @param rY The y radius of the ellipse.\n     * @param accuracy Optional accuracy of the underlying BezierCurve.\n     */\n    constructor(cx: number, cy: number, rx: number, ry: number, accuracy?: number);\n\n    constructor(...args: any[]) {\n\n        const n = 360 / maxBezierArcspan;\n        let accuracy: number;\n\n        const isPointArgs0 = isPoint(args[0]);\n\n        const realArgs = (numArgs: number) => {\n            switch (numArgs) {\n                case 2:\n                    if (isPointArgs0) {\n                        //origin, radius\n                        this.origin = <IPoint>args[0];\n                    }\n                    break;\n\n                case 3:\n                    //origin, rx, ry\n                    this.origin = <IPoint>args[0];\n                    break;\n\n                case 4:\n                    //cx, cy, rx, ry\n                    this.origin = [args[0] as number, args[1] as number];\n                    break;\n            }\n\n            //construct a bezier approximation for an arc with radius of 1.\n            const a = 360 / n;\n            const arc = new paths.Arc([0, 0], 1, 0, a);\n\n            //clone and rotate to complete a circle\n            for (let i = 0; i < n; i++) {\n\n                let seed = bezierSeedFromArc(arc);\n\n                switch (numArgs) {\n                    case 1:\n                        //radius\n                        seed = path.scale(seed, args[0] as number) as IPathBezierSeed;\n                        break;\n\n                    case 2:\n                        if (isPointArgs0) {\n                            //origin, radius\n                            seed = path.scale(seed, args[1] as number) as IPathBezierSeed;\n\n                        } else {\n                            //rx, ry\n                            seed = path.distort(seed, args[0] as number, args[1] as number) as IPathBezierSeed;\n                        }\n                        break;\n\n                    case 3:\n                        //origin, rx, ry\n                        seed = path.distort(seed, args[1] as number, args[2] as number) as IPathBezierSeed;\n                        break;\n\n                    case 4:\n                        //cx, cy, rx, ry\n                        seed = path.distort(seed, args[2] as number, args[3] as number) as IPathBezierSeed;\n                        break;\n                }\n\n                this.models['Curve_' + (1 + i)] = new BezierCurve(seed, accuracy);\n\n                arc.startAngle += a;\n                arc.endAngle += a;\n            }\n        };\n\n        switch (args.length) {\n            case 2:\n                realArgs(2);\n                break;\n\n            case 3:\n                if (isPointArgs0) {\n                    realArgs(3);\n                } else {\n                    accuracy = args[2] as number;\n                    realArgs(2);\n                }\n                break;\n\n            case 4:\n                if (isPointArgs0) {\n                    accuracy = args[3] as number;\n                    realArgs(3);\n                } else {\n                    realArgs(4);\n                }\n                break;\n\n            case 5:\n                accuracy = args[4] as number;\n                realArgs(4);\n                break;\n        }\n\n    }\n}\n\n(<IKit>Ellipse).metaParameters = [\n    { title: \"radiusX\", type: \"range\", min: 1, max: 50, value: 50 },\n    { title: \"radiusY\", type: \"range\", min: 1, max: 50, value: 25 }\n];\n\nexport class EllipticArc implements IModel {\n    public models: IModelMap = {};\n\n    /**\n     * Class for Elliptic Arc created by distorting a circular arc.\n     *\n     * @param arc The circular arc to use as the basis of the elliptic arc.\n     * @param radiusX The x radius of the ellipse.\n     * @param radiusY The y radius of the ellipse.\n     * @param accuracy Optional accuracy of the underlying BezierCurve.\n     */\n    constructor(startAngle: number, endAngle: number, radiusX: number, radiusY: number, accuracy?: number);\n\n    /**\n     * Class for Elliptic Arc created by distorting a circular arc.\n     *\n     * @param arc The circular arc to use as the basis of the elliptic arc.\n     * @param distortX The x scale of the ellipse.\n     * @param distortY The y scale of the ellipse.\n     * @param accuracy Optional accuracy of the underlying BezierCurve.\n     */\n    constructor(arc: IPathArc, distortX: number, distortY: number, accuracy?: number);\n\n    constructor(...args: any[]) {\n\n        let arc: IPathArc;\n        let accuracy: number;\n        let distortX: number;\n        let distortY: number;\n\n        if (isPathArc(args[0])) {\n            arc = args[0] as IPathArc;\n            distortX = args[1] as number;\n            distortY = args[2] as number;\n            accuracy = args[3] as number;\n        } else {\n            arc = new paths.Arc([0, 0], 1, args[0] as number, args[1] as number);\n            distortX = args[2] as number;\n            distortY = args[3] as number;\n            accuracy = args[4] as number;\n        }\n\n        const span = angle.ofArcSpan(arc);\n\n        //split into equal chunks, no larger than max chunk size\n        const count = Math.ceil(span / maxBezierArcspan);\n        const subSpan = span / count;\n        const subArc = path.clone(arc) as IPathArc;\n\n        for (let i = 0; i < count; i++) {\n            subArc.startAngle = arc.startAngle + (i * subSpan);\n            subArc.endAngle = subArc.startAngle + subSpan;\n\n            let seed = bezierSeedFromArc(subArc);\n            seed = path.distort(seed, distortX, distortY) as IPathBezierSeed;\n\n            this.models['Curve_' + (1 + i)] = new BezierCurve(seed, accuracy);\n        }\n    }\n}\n\n(<IKit>EllipticArc).metaParameters = [\n    { title: \"startAngle\", type: \"range\", min: 0, max: 90, value: 0 },\n    { title: \"endAngle\", type: \"range\", min: 90, max: 360, value: 180 },\n    { title: \"radiusX\", type: \"range\", min: 1, max: 50, value: 50 },\n    { title: \"radiusY\", type: \"range\", min: 1, max: 50, value: 25 }\n];\n","/**\n * Path breaking functions for Maker.js\n * Break paths at specific points\n */\n\nimport { IPath, IPoint, IPathArc, IPathCircle, IPathLine } from './schema.js';\nimport { cloneObject, pathType } from './maker.js';\nimport * as angle from './angle.js';\nimport { isAngleEqual } from './equal.js';\n\nfunction isBetween(valueInQuestion: number, limitA: number, limitB: number, exclusive: boolean): boolean {\n    if (exclusive) {\n        return Math.min(limitA, limitB) < valueInQuestion && valueInQuestion < Math.max(limitA, limitB);\n    }\n    return Math.min(limitA, limitB) <= valueInQuestion && valueInQuestion <= Math.max(limitA, limitB);\n}\n\nfunction isBetweenArcAngles(angleInQuestion: number, arc: IPathArc, exclusive: boolean): boolean {\n    const startAngle = angle.noRevolutions(arc.startAngle);\n    const span = angle.ofArcSpan(arc);\n    const endAngle = startAngle + span;\n    let normalized = angle.noRevolutions(angleInQuestion);\n    if (normalized < startAngle) {\n        normalized += 360;\n    }\n    return isBetween(normalized, startAngle, endAngle, exclusive);\n}\n\nfunction isBetweenPoints(pointInQuestion: IPoint, line: IPathLine, exclusive: boolean): boolean {\n    let oneDimension = false;\n    for (let i = 2; i--;) {\n        if (Math.abs(line.origin[i] - line.end[i]) < 0.000001) {\n            oneDimension = true;\n        } else {\n            const originValue = Math.round(line.origin[i] * 1000000) / 1000000;\n            const endValue = Math.round(line.end[i] * 1000000) / 1000000;\n            const pointValue = Math.round(pointInQuestion[i] * 1000000) / 1000000;\n            if (exclusive) {\n                if (!isBetween(pointValue, originValue, endValue, true)) {\n                    return false;\n                }\n            } else if (!(pointValue >= Math.min(originValue, endValue) && pointValue <= Math.max(originValue, endValue))) {\n                return false;\n            }\n        }\n    }\n    return oneDimension;\n}\n\n/**\n * @private\n */\ninterface IBreakPathFunctionMap {\n    [type: string]: (path: IPath, pointOfBreak: IPoint) => IPath;\n}\n\n/**\n * @private\n */\nconst breakPathFunctionMap: IBreakPathFunctionMap = {};\n\nbreakPathFunctionMap[pathType.Arc] = (arc: IPathArc, pointOfBreak: IPoint): IPath => {\n\n    const angleAtBreakPoint = angle.ofPointInDegrees(arc.origin, pointOfBreak);\n\n    if (isAngleEqual(angleAtBreakPoint, arc.startAngle) || isAngleEqual(angleAtBreakPoint, arc.endAngle)) {\n        return null;\n    }\n\n    const getAngleStrictlyBetweenArcAngles = () => {\n        const startAngle = angle.noRevolutions(arc.startAngle);\n        const endAngle = startAngle + angle.ofArcEnd(arc) - arc.startAngle;\n\n        const tries = [0, 1, -1];\n        for (let i = 0; i < tries.length; i++) {\n            const add = + 360 * tries[i];\n            if (isBetween(angleAtBreakPoint + add, startAngle, endAngle, true)) {\n                return arc.startAngle + angleAtBreakPoint + add - startAngle;\n            }\n        }\n        return null;\n    };\n\n    const angleAtBreakPointBetween = getAngleStrictlyBetweenArcAngles();\n    if (angleAtBreakPointBetween == null) {\n        return null;\n    }\n\n    const savedEndAngle = arc.endAngle;\n\n    arc.endAngle = angleAtBreakPointBetween;\n\n    //clone the original to carry other properties\n    const copy = cloneObject(arc) as IPathArc;\n    copy.startAngle = angleAtBreakPointBetween;\n    copy.endAngle = savedEndAngle;\n\n    return copy;\n};\n\nbreakPathFunctionMap[pathType.Circle] = (circle: IPathCircle, pointOfBreak: IPoint): IPath => {\n\n    //breaking a circle turns it into an arc\n    circle.type = pathType.Arc;\n\n    const arc: IPathArc = <IPathArc>circle;\n\n    const angleAtBreakPoint = angle.ofPointInDegrees(circle.origin, pointOfBreak);\n\n    arc.startAngle = angleAtBreakPoint;\n    arc.endAngle = angleAtBreakPoint + 360;\n\n    return null;\n};\n\nbreakPathFunctionMap[pathType.Line] = (line: IPathLine, pointOfBreak: IPoint): IPath => {\n\n    if (!isBetweenPoints(pointOfBreak, line, true)) {\n        return null;\n    }\n\n    const savedEndPoint = line.end;\n\n    line.end = pointOfBreak;\n\n    //clone the original to carry other properties\n    const copy = cloneObject(line) as IPathLine;\n    copy.origin = pointOfBreak;\n    copy.end = savedEndPoint;\n\n    return copy;\n};\n\n/**\n * Breaks a path in two. The supplied path will end at the supplied pointOfBreak, \n * a new path is returned which begins at the pointOfBreak and ends at the supplied path's initial end point.\n * For Circle, the original path will be converted in place to an Arc, and null is returned.\n * \n * @param pathToBreak The path to break.\n * @param pointOfBreak The point at which to break the path.\n * @returns A new path of the same type, when path type is line or arc. Returns null for circle.\n */\nexport function breakAtPoint(pathToBreak: IPath, pointOfBreak: IPoint): IPath {\n    if (pathToBreak && pointOfBreak) {\n        const fn = breakPathFunctionMap[pathToBreak.type];\n        if (fn) {\n            const result = fn(pathToBreak, pointOfBreak);\n\n            if (result && ('layer' in pathToBreak)) {\n                result.layer = pathToBreak.layer;\n            }\n\n            return result;\n        }\n    }\n    return null;\n}\n","import { IModel, IPath, IPathArc, IPathCircle, IPathLine, IPoint } from './schema.js';\nimport { pathType } from './maker.js';\nimport * as angle from './angle.js';\nimport * as point from './point.js';\nimport * as path from './path.js';\nimport * as measure from './measure-minimal.js';\nimport { isPointOnPath } from './equal.js';\n\nexport const DEFAULT_POINT_MATCHING_DISTANCE = 0.005;\n\nexport interface SegmentClassification {\n    isInside: boolean;\n    isDuplicate: boolean;\n}\n\nexport type SegmentClassifier = (segmentPath: IPath) => SegmentClassification;\n\nexport function isZeroLength(pathContext: IPath, tolerance = DEFAULT_POINT_MATCHING_DISTANCE / 5): boolean {\n    return Math.abs(measure.pathLength(pathContext)) < tolerance;\n}\n\nexport function isCircleOrArc(pathContext: IPath): pathContext is IPathArc | IPathCircle {\n    return pathContext.type === pathType.Circle || pathContext.type === pathType.Arc;\n}\n\nexport function isArcEnclosingAngle(arc: IPathArc, angleInQuestion: number, exclusive = false): boolean {\n    const startAngle = angle.noRevolutions(arc.startAngle);\n    const span = angle.ofArcSpan(arc);\n    const endAngle = startAngle + span;\n    let normalized = angle.noRevolutions(angleInQuestion);\n    if (normalized < startAngle) {\n        normalized += 360;\n    }\n    if (exclusive) {\n        return normalized > startAngle && normalized < endAngle;\n    }\n    return normalized >= startAngle && normalized <= endAngle;\n}\n\nexport function ensurePathLayer(source: IPath, target: IPath) {\n    if (source && target && typeof source.layer !== 'undefined') {\n        target.layer = source.layer;\n    }\n}\n\nexport function isBetween(valueInQuestion: number, limitA: number, limitB: number, exclusive: boolean, tolerance = DEFAULT_POINT_MATCHING_DISTANCE): boolean {\n    const min = Math.min(limitA, limitB);\n    const max = Math.max(limitA, limitB);\n    if (exclusive) {\n        return valueInQuestion > min + tolerance && valueInQuestion < max - tolerance;\n    }\n    return valueInQuestion >= min - tolerance && valueInQuestion <= max + tolerance;\n}\n\nexport function isBetweenArcAngles(angleInQuestion: number, arc: IPathArc, exclusive: boolean, tolerance = DEFAULT_POINT_MATCHING_DISTANCE): boolean {\n    const startAngle = angle.noRevolutions(arc.startAngle);\n    const span = angle.ofArcSpan(arc);\n    const endAngle = startAngle + span;\n    let normalized = angle.noRevolutions(angleInQuestion);\n    if (normalized < startAngle) {\n        normalized += 360;\n    }\n    return isBetween(normalized, startAngle, endAngle, exclusive, tolerance);\n}\n\nexport function isBetweenPoints(pointInQuestion: IPoint, line: IPathLine, exclusive: boolean, tolerance = DEFAULT_POINT_MATCHING_DISTANCE): boolean {\n    const dx = line.end[0] - line.origin[0];\n    const dy = line.end[1] - line.origin[1];\n    const lengthSq = dx * dx + dy * dy;\n    if (lengthSq === 0) {\n        const dx = pointInQuestion[0] - line.origin[0];\n        const dy = pointInQuestion[1] - line.origin[1];\n        return Math.sqrt(dx * dx + dy * dy) <= tolerance;\n    }\n    const t = ((pointInQuestion[0] - line.origin[0]) * dx + (pointInQuestion[1] - line.origin[1]) * dy) / lengthSq;\n    if (exclusive) {\n        if (t <= tolerance || t >= 1 - tolerance) {\n            return false;\n        }\n    } else if (t < -tolerance || t > 1 + tolerance) {\n        return false;\n    }\n    return true;\n}\n\nexport function addPathToModel(modelContext: IModel, pathContext: IPath, pathId: string) {\n    modelContext.paths = modelContext.paths || {};\n    modelContext.paths[pathId] = pathContext;\n}\n\nexport interface DeletedPathInfo extends IPath {\n    reason: string;\n    routeKey: string;\n}\n\nexport function trackDeletedPath(container: { paths: Record<string, IPath> }, deletedPath: IPath, pathId: string, reason: string, routeKey?: string) {\n    container.paths[pathId] = deletedPath;\n    const info = deletedPath as DeletedPathInfo;\n    info.reason = reason;\n    if (routeKey) {\n        info.routeKey = routeKey;\n    }\n}\n\nexport function pathBoundingBox(pathContext: IPath, offset?: IPoint) {\n    return measure.pathExtents(pathContext, offset);\n}\n\nexport function findPointsOnPath(points: IPoint[], pathContext: IPath, tolerance = DEFAULT_POINT_MATCHING_DISTANCE) {\n    const result: IPoint[] = [];\n    points.forEach(p => {\n        if (isPointOnPath(p, pathContext, tolerance)) {\n            result.push(p);\n        }\n    });\n    return result;\n}\n","import { IModel, IPath, IPoint } from './schema.js';\nimport {\n    cloneObject,\n    extendObject,\n    pathType,\n    createRouteKey,\n    IWalkPath,\n    IWalkModel,\n    IWalkOptions,\n    IWalkPathBooleanCallback,\n    ICombineOptions,\n    IMeasurePointInsideOptions,\n    IPathIntersectionOptions,\n    IPathRemoved,\n    IIsPointOnPathOptions\n} from './maker.js';\nimport * as path from './path.js';\nimport * as point from './point.js';\nimport { addPath, getSimilarPathId, walk } from './model.js';\nimport { breakAtPoint } from './break.js';\nimport { isPointOnPath, isPathEqual } from './equal.js';\nimport { DEFAULT_POINT_MATCHING_DISTANCE, isZeroLength } from './boolean-utils.js';\n\ndeclare const measure: any;\ndeclare function removeDeadEnds(modelContext: IModel, pointMatchingDistance?: number | null, keep?: IWalkPathBooleanCallback, trackDeleted?: (wp: IWalkPath, reason: string) => void): IModel;\n\nconst pathInternal: any = path;\n\ninterface CrossedPathSegment {\n    isInside?: boolean;\n    uniqueForeignIntersectionPoints: IPoint[];\n    absolutePath: IPath;\n    addedPath?: IPath;\n    pathId: string;\n    overlapped: boolean;\n    duplicate?: boolean;\n}\n\ninterface CrossedPath extends IWalkPath {\n    broken: boolean;\n    segments: CrossedPathSegment[];\n}\n\ninterface CombinedModel {\n    crossedPaths: CrossedPath[];\n    overlappedSegments: CrossedPathSegment[];\n}\n\nfunction getNonZeroSegments(pathToSegment: IPath, breakPoint: IPoint): IPath[] | null {\n    const segment1 = cloneObject(pathToSegment);\n    if (!segment1) {\n        return null;\n    }\n\n    const segment2 = breakAtPoint(segment1, breakPoint);\n\n    if (segment2) {\n        const segments: IPath[] = [segment1, segment2];\n        for (let i = 0; i < segments.length; i += 1) {\n            if (isZeroLength(segments[i], DEFAULT_POINT_MATCHING_DISTANCE / 5)) {\n                return null;\n            }\n        }\n        return segments;\n    }\n\n    if (pathToSegment.type === pathType.Circle) {\n        return [segment1];\n    }\n\n    return null;\n}\n\nfunction getPointsOnPath(points: IPoint[], onPath: IPath, popOptions: IIsPointOnPathOptions): IPoint[] {\n    const endpointsOnPath: IPoint[] = [];\n    points.forEach(p => {\n        if (isPointOnPath(p, onPath, 0.00001, undefined, popOptions as any)) {\n            endpointsOnPath.push(p);\n        }\n    });\n    return endpointsOnPath;\n}\n\nfunction breakAlongForeignPath(crossedPath: CrossedPath, overlappedSegments: CrossedPathSegment[], foreignWalkedPath: IWalkPath) {\n    const foreignPath = foreignWalkedPath.pathContext;\n    const segments = crossedPath.segments;\n\n    if (isPathEqual(segments[0].absolutePath, foreignPath, 0.0001, undefined, foreignWalkedPath.offset)) {\n        segments[0].overlapped = true;\n        segments[0].duplicate = true;\n        overlappedSegments.push(segments[0]);\n        return;\n    }\n\n    const popOptions: IIsPointOnPathOptions = {} as IIsPointOnPathOptions;\n    const options: IPathIntersectionOptions = { path1Offset: crossedPath.offset, path2Offset: foreignWalkedPath.offset };\n    const foreignIntersection = pathInternal.intersection?.(crossedPath.pathContext, foreignPath, options);\n    const intersectionPoints = foreignIntersection ? foreignIntersection.intersectionPoints : null;\n    const foreignPathEndPoints = point.fromPathEnds(foreignPath, foreignWalkedPath.offset) || [];\n\n    for (let i = 0; i < segments.length; i += 1) {\n        const pointsOfInterest = intersectionPoints ? foreignPathEndPoints.concat(intersectionPoints) : foreignPathEndPoints;\n        const pointsToCheck = getPointsOnPath(pointsOfInterest, segments[i].absolutePath, popOptions);\n\n        if (options.out_AreOverlapped) {\n            segments[i].overlapped = true;\n            overlappedSegments.push(segments[i]);\n        }\n\n        if (pointsToCheck.length > 0) {\n            let subSegments: IPath[] | null = null;\n            let pointer = 0;\n            while (!subSegments && pointer < pointsToCheck.length) {\n                subSegments = getNonZeroSegments(segments[i].absolutePath, pointsToCheck[pointer]);\n                pointer += 1;\n            }\n\n            if (subSegments) {\n                crossedPath.broken = true;\n                segments[i].absolutePath = subSegments[0];\n\n                if (subSegments[1]) {\n                    const newSegment: CrossedPathSegment = {\n                        absolutePath: subSegments[1],\n                        pathId: segments[0].pathId,\n                        overlapped: segments[i].overlapped,\n                        uniqueForeignIntersectionPoints: []\n                    };\n\n                    if (segments[i].overlapped) {\n                        overlappedSegments.push(newSegment);\n                    }\n\n                    segments.push(newSegment);\n                }\n\n                i -= 1;\n            }\n        }\n    }\n}\n\nexport function isPathInsideModel(pathContext: IPath, modelContext: IModel, pathOffset?: IPoint, farPoint?: IPoint, measureAtlas?: any): boolean {\n    const options = { farPoint } as IMeasurePointInsideOptions & { measureAtlas?: any };\n    if (measureAtlas) {\n        options.measureAtlas = measureAtlas;\n    }\n\n    const p = point.add(point.middle(pathContext), pathOffset);\n    return measure.isPointInsideModel(p, modelContext, options);\n}\n\nfunction breakAllPathsAtIntersections(\n    modelToBreak: IModel,\n    modelToIntersect: IModel,\n    checkIsInside: boolean,\n    modelToBreakAtlas: any,\n    modelToIntersectAtlas: any,\n    farPoint?: IPoint\n): CombinedModel {\n    const crossedPaths: CrossedPath[] = [];\n    const overlappedSegments: CrossedPathSegment[] = [];\n\n    const walkModelToBreakOptions: IWalkOptions = {\n        onPath(outerWalkedPath: IWalkPath) {\n            const segment: CrossedPathSegment = {\n                absolutePath: path.clone(outerWalkedPath.pathContext, outerWalkedPath.offset),\n                pathId: outerWalkedPath.pathId,\n                overlapped: false,\n                uniqueForeignIntersectionPoints: []\n            };\n\n            const thisPath = outerWalkedPath as CrossedPath;\n            thisPath.broken = false;\n            thisPath.segments = [segment];\n\n            const walkModelToIntersectOptions: IWalkOptions = {\n                onPath(innerWalkedPath: IWalkPath) {\n                    if (\n                        outerWalkedPath.pathContext !== innerWalkedPath.pathContext &&\n                        measure.isMeasurementOverlapping(\n                            modelToBreakAtlas.pathMap[outerWalkedPath.routeKey],\n                            modelToIntersectAtlas.pathMap[innerWalkedPath.routeKey]\n                        )\n                    ) {\n                        breakAlongForeignPath(thisPath, overlappedSegments, innerWalkedPath);\n                    }\n                },\n                beforeChildWalk(innerWalkedModel: IWalkModel): boolean {\n                    const innerModelMeasurement = modelToIntersectAtlas.modelMap[innerWalkedModel.routeKey];\n                    return innerModelMeasurement && measure.isMeasurementOverlapping(modelToBreakAtlas.pathMap[outerWalkedPath.routeKey], innerModelMeasurement);\n                }\n            };\n\n            walk(modelToIntersect, walkModelToIntersectOptions);\n\n            if (checkIsInside) {\n                for (let i = 0; i < thisPath.segments.length; i += 1) {\n                    const midpoint = point.middle(thisPath.segments[i].absolutePath);\n                    const pointInsideOptions = { farPoint } as IMeasurePointInsideOptions & { measureAtlas?: any };\n                    pointInsideOptions.measureAtlas = modelToIntersectAtlas;\n                    thisPath.segments[i].isInside = measure.isPointInsideModel(midpoint, modelToIntersect, pointInsideOptions);\n                    thisPath.segments[i].uniqueForeignIntersectionPoints = pointInsideOptions.out_intersectionPoints;\n                }\n            }\n\n            crossedPaths.push(thisPath);\n        }\n    };\n\n    walk(modelToBreak, walkModelToBreakOptions);\n\n    return { crossedPaths, overlappedSegments };\n}\n\nfunction checkForEqualOverlaps(crossedPathsA: CrossedPathSegment[], crossedPathsB: CrossedPathSegment[], pointMatchingDistance: number) {\n    const compareSegments = (segment1: CrossedPathSegment, segment2: CrossedPathSegment) => {\n        if (isPathEqual(segment1.absolutePath, segment2.absolutePath, pointMatchingDistance)) {\n            segment1.duplicate = true;\n            segment2.duplicate = true;\n        }\n    };\n\n    const compareAll = (segment: CrossedPathSegment) => {\n        crossedPathsB.forEach(other => compareSegments(other, segment));\n    };\n\n    crossedPathsA.forEach(compareAll);\n}\n\ntype TrackDeleted = (pathToDelete: IPath, routeKey: string, reason: string) => void;\n\nfunction addOrDeleteSegments(\n    crossedPath: CrossedPath,\n    includeInside: boolean,\n    includeOutside: boolean,\n    keepDuplicates: boolean,\n    atlas: any,\n    trackDeleted: TrackDeleted\n) {\n    const addSegment = (modelContext: IModel, pathIdBase: string, segment: CrossedPathSegment) => {\n        const id = getSimilarPathId(modelContext, pathIdBase);\n        const newRouteKey = id === pathIdBase ? crossedPath.routeKey : createRouteKey(crossedPath.route.slice(0, -1).concat([id]));\n\n        segment.addedPath = cloneObject(crossedPath.pathContext);\n        segment.addedPath.type = segment.absolutePath.type;\n\n        path.copyProps(segment.absolutePath, segment.addedPath);\n        path.moveRelative(segment.addedPath, crossedPath.offset, true);\n\n        modelContext.paths = modelContext.paths || {};\n        modelContext.paths[id] = segment.addedPath;\n\n        if (crossedPath.broken) {\n            const measurement = measure.pathExtents(segment.absolutePath);\n            atlas.pathMap[newRouteKey] = measurement;\n            atlas.modelsMeasured = false;\n        } else {\n            atlas.pathMap[newRouteKey] = savedMeasurement;\n        }\n    };\n\n    const checkAddSegment = (modelContext: IModel, pathIdBase: string, segment: CrossedPathSegment) => {\n        if ((segment.isInside && includeInside) || (!segment.isInside && includeOutside)) {\n            addSegment(modelContext, pathIdBase, segment);\n        } else {\n            atlas.modelsMeasured = false;\n            trackDeleted(\n                segment.absolutePath,\n                crossedPath.routeKey,\n                `segment is ${segment.isInside ? 'inside' : 'outside'} intersectionPoints=${JSON.stringify(segment.uniqueForeignIntersectionPoints)}`\n            );\n        }\n    };\n\n    const savedMeasurement = atlas.pathMap[crossedPath.routeKey];\n\n    delete crossedPath.modelContext.paths[crossedPath.pathId];\n    delete atlas.pathMap[crossedPath.routeKey];\n\n    crossedPath.segments.forEach(segment => {\n        if (segment.duplicate) {\n            if (keepDuplicates) {\n                addSegment(crossedPath.modelContext, crossedPath.pathId, segment);\n            } else {\n                trackDeleted(segment.absolutePath, crossedPath.routeKey, 'segment is duplicate');\n            }\n        } else {\n            checkAddSegment(crossedPath.modelContext, crossedPath.pathId, segment);\n        }\n    });\n}\n\nexport function breakPathsAtIntersections(modelToBreak: IModel, modelToIntersect?: IModel) {\n    const modelToBreakAtlas = new measure.Atlas(modelToBreak);\n    modelToBreakAtlas.measureModels();\n\n    let modelToIntersectAtlas: any;\n\n    if (!modelToIntersect) {\n        modelToIntersect = modelToBreak;\n        modelToIntersectAtlas = modelToBreakAtlas;\n    } else {\n        modelToIntersectAtlas = new measure.Atlas(modelToIntersect);\n        modelToIntersectAtlas.measureModels();\n    }\n\n    breakAllPathsAtIntersections(modelToBreak, modelToIntersect || modelToBreak, false, modelToBreakAtlas, modelToIntersectAtlas);\n\n    return modelToBreak;\n}\n\nexport function combine(\n    modelA: IModel,\n    modelB: IModel,\n    includeAInsideB = false,\n    includeAOutsideB = true,\n    includeBInsideA = false,\n    includeBOutsideA = true,\n    options?: ICombineOptions\n) {\n    const opts: ICombineOptions = {\n        trimDeadEnds: true,\n        pointMatchingDistance: DEFAULT_POINT_MATCHING_DISTANCE,\n        out_deleted: [{ paths: {} }, { paths: {} }]\n    };\n    extendObject(opts, options);\n\n    opts.measureA = opts.measureA || new measure.Atlas(modelA);\n    opts.measureB = opts.measureB || new measure.Atlas(modelB);\n\n    opts.measureA.measureModels();\n    opts.measureB.measureModels();\n\n    if (!opts.farPoint) {\n        const measureBoth = measure.increase(\n            measure.increase({ high: [null, null], low: [null, null] }, opts.measureA.modelMap['']),\n            opts.measureB.modelMap['']\n        );\n        opts.farPoint = point.add(measureBoth.high, [1, 1]);\n    }\n\n    const pathsA = breakAllPathsAtIntersections(modelA, modelB, true, opts.measureA, opts.measureB, opts.farPoint);\n    const pathsB = breakAllPathsAtIntersections(modelB, modelA, true, opts.measureB, opts.measureA, opts.farPoint);\n\n    checkForEqualOverlaps(pathsA.overlappedSegments, pathsB.overlappedSegments, opts.pointMatchingDistance || DEFAULT_POINT_MATCHING_DISTANCE);\n\n    const trackDeleted = (which: number, deletedPath: IPath, routeKey: string, reason: string) => {\n        addPath(opts.out_deleted[which], deletedPath, 'deleted');\n        const removed = deletedPath as IPathRemoved;\n        removed.reason = reason;\n        removed.routeKey = routeKey;\n    };\n\n    pathsA.crossedPaths.forEach(crossedPath => {\n        addOrDeleteSegments(crossedPath, includeAInsideB, includeAOutsideB, true, opts.measureA, (p, id, reason) => trackDeleted(0, p, id, reason));\n    });\n\n    pathsB.crossedPaths.forEach(crossedPath => {\n        addOrDeleteSegments(crossedPath, includeBInsideA, includeBOutsideA, false, opts.measureB, (p, id, reason) => trackDeleted(1, p, id, reason));\n    });\n\n    const result: IModel = { models: { a: modelA, b: modelB } };\n\n    if (opts.trimDeadEnds) {\n        let shouldKeep: IWalkPathBooleanCallback | undefined;\n\n        if (!includeAInsideB && !includeBInsideA) {\n            shouldKeep = (walkedPath: IWalkPath): boolean => {\n                return !pathsA.overlappedSegments.some(segment => segment.duplicate && walkedPath.pathContext === segment.addedPath);\n            };\n        }\n\n        removeDeadEnds(result, null, shouldKeep, (wp, reason) => {\n            const which = wp.route[1] === 'a' ? 0 : 1;\n            trackDeleted(which, wp.pathContext, wp.routeKey, reason);\n        });\n    }\n\n    extendObject(options, opts);\n\n    return result;\n}\n\nexport function combineIntersection(modelA: IModel, modelB: IModel) {\n    return combine(modelA, modelB, true, false, true, false);\n}\n\nexport function combineSubtraction(modelA: IModel, modelB: IModel) {\n    return combine(modelA, modelB, false, true, true, false);\n}\n\nexport function combineUnion(modelA: IModel, modelB: IModel) {\n    return combine(modelA, modelB, false, true, false, true);\n}\n","// ES Module imports\nimport type { IPoint, IPath, IModel, IModelMap } from '../core/schema.js';\nimport type { IKit, ICombineOptions } from '../core/maker.js';\nimport * as point from '../core/point.js';\nimport * as paths from '../core/paths.js';\nimport { isPointEqual } from '../core/equal.js';\nimport { modelExtents } from '../core/measure.js';\nimport { originate } from '../core/model.js';\nimport { combine as combineModels } from '../core/combine.js';\nimport { BezierCurve } from './BezierCurve-esm.js';\n\nexport class Text implements IModel {\n    public models: IModelMap = {};\n\n    /**\n     * Renders text in a given font to a model.\n     * @param font OpenType.Font object.\n     * @param text String of text to render.\n     * @param fontSize Font size.\n     * @param combine Flag (default false) to perform a combineUnion upon each character with characters to the left and right.\n     * @param centerCharacterOrigin Flag (default false) to move the x origin of each character to the center. Useful for rotating text characters.\n     * @param bezierAccuracy Optional accuracy of Bezier curves.\n     * @param opentypeOptions Optional opentype.RenderOptions object.\n     * @returns Model of the text.\n     */\n    constructor(font: opentype.Font, text: string, fontSize: number, combine = false, centerCharacterOrigin = false, bezierAccuracy?: number, opentypeOptions?: opentype.RenderOptions) {\n        let charIndex = 0;\n        let prevDeleted: IModel;\n        let prevChar: IModel;\n\n        const cb = (glyph: opentype.Glyph, x: number, y: number, _fontSize: number, options: opentype.RenderOptions) => {\n            const charModel = Text.glyphToModel(glyph, _fontSize, bezierAccuracy);\n            charModel.origin = [x, 0];\n\n            if (centerCharacterOrigin && (charModel.paths || charModel.models)) {\n                const m = modelExtents(charModel);\n                if (m) {\n                    const w = m.high[0] - m.low[0];\n                    originate(charModel, [m.low[0] + w / 2, 0]);\n                }\n            }\n\n            if (combine && charIndex > 0) {\n                const combineOptions: ICombineOptions = {};\n                let prev: IModel;\n\n                if (prevDeleted) {\n\n                    //form a temporary complete geometry of the previous character using the previously deleted segments\n                    prev = {\n                        models: {\n                            deleted: prevDeleted,\n                            char: prevChar\n                        }\n                    }\n                } else {\n                    prev = prevChar;\n                }\n\n                combineModels(prev, charModel, false, true, false, true, combineOptions);\n\n                //save the deleted segments from this character for the next iteration\n                prevDeleted = combineOptions.out_deleted[1];\n            }\n\n            this.models[charIndex] = charModel;\n            charIndex++;\n            prevChar = charModel;\n        };\n\n        font.forEachGlyph(text, 0, 0, fontSize, opentypeOptions, cb);\n    }\n\n    /**\n     * Convert an opentype glyph to a model.\n     * @param glyph Opentype.Glyph object.\n     * @param fontSize Font size.\n     * @param bezierAccuracy Optional accuracy of Bezier curves.\n     * @returns Model of the glyph.\n     */\n    static glyphToModel(glyph: opentype.Glyph, fontSize: number, bezierAccuracy?: number) {\n        const charModel: IModel = {};\n        let firstPoint: IPoint;\n        let currPoint: IPoint;\n        let pathCount = 0;\n\n        function addPath(p: IPath) {\n            if (!charModel.paths) {\n                charModel.paths = {};\n            }\n            charModel.paths['p_' + ++pathCount] = p;\n        }\n\n        function addModel(m: IModel) {\n            if (!charModel.models) {\n                charModel.models = {};\n            }\n            charModel.models['p_' + ++pathCount] = m;\n        }\n\n        const p = glyph.getPath(0, 0, fontSize);\n\n        p.commands.map((command, i) => {\n\n            const points: IPoint[] = [[command.x, command.y], [command.x1, command.y1], [command.x2, command.y2]].map(\n                p => {\n                    if (p[0] !== void 0) {\n                        return point.mirror(p, false, true);\n                    }\n                }\n            );\n\n            switch (command.type) {\n\n                case 'M':\n                    firstPoint = points[0];\n                    break;\n\n                case 'Z':\n                    points[0] = firstPoint;\n                //fall through to line\n\n                case 'L':\n                    if (!isPointEqual(currPoint, points[0])) {\n                        addPath(new paths.Line(currPoint, points[0]));\n                    }\n                    break;\n\n                case 'C':\n                    addModel(new BezierCurve(currPoint, points[1], points[2], points[0], bezierAccuracy));\n                    break;\n\n                case 'Q':\n                    addModel(new BezierCurve(currPoint, points[1], points[0], bezierAccuracy));\n                    break;\n            }\n\n            currPoint = points[0];\n        });\n\n        return charModel;\n    }\n}\n\n(<IKit>Text).metaParameters = [\n    { title: \"font\", type: \"font\", value: '*' },\n    { title: \"text\", type: \"text\", value: 'Hello' },\n    { title: \"font size\", type: \"range\", min: 10, max: 200, value: 72 },\n    { title: \"combine\", type: \"bool\", value: false },\n    { title: \"center character origin\", type: \"bool\", value: false }\n];\n","/**\n * Functional composition utilities for photon/core\n * Provides pure, immutable function composition patterns\n * @module functional\n */\n\n/**\n * Pipe value through functions left-to-right\n * \n * Applies functions in sequence from left to right, passing the result\n * of each function to the next. This is a pure functional composition\n * utility that does not mutate the original value.\n * \n * @example\n * ```typescript\n * // Simple numeric transformations\n * const result = pipe(\n *   10,\n *   x => x + 5,\n *   x => x * 2,\n *   x => x - 3\n * ); // 27\n * \n * // With Photon models\n * const square = pipe(\n *   new Square(100),\n *   m => model.moveRelative(m, [10, 20]),\n *   m => model.rotate(m, 45)\n * );\n * ```\n * \n * @param value - Initial value to transform\n * @param fns - Functions to apply in sequence (left-to-right)\n * @returns Final result after all transformations\n */\nexport function pipe<T>(value: T): T;\nexport function pipe<T, A>(value: T, fn1: (x: T) => A): A;\nexport function pipe<T, A, B>(value: T, fn1: (x: T) => A, fn2: (x: A) => B): B;\nexport function pipe<T, A, B, C>(\n  value: T,\n  fn1: (x: T) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C\n): C;\nexport function pipe<T, A, B, C, D>(\n  value: T,\n  fn1: (x: T) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D\n): D;\nexport function pipe<T, A, B, C, D, E>(\n  value: T,\n  fn1: (x: T) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E\n): E;\nexport function pipe<T, A, B, C, D, E, F>(\n  value: T,\n  fn1: (x: T) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F\n): F;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  value: T,\n  fn1: (x: T) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G\n): G;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  value: T,\n  fn1: (x: T) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n  fn8: (x: G) => H\n): H;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  value: T,\n  fn1: (x: T) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n  fn8: (x: G) => H,\n  fn9: (x: H) => I\n): I;\nexport function pipe<T, A, B, C, D, E, F, G, H, I, J>(\n  value: T,\n  fn1: (x: T) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n  fn8: (x: G) => H,\n  fn9: (x: H) => I,\n  fn10: (x: I) => J\n): J;\nexport function pipe(value: any, ...fns: Function[]): any {\n  if (fns.length === 0) return value;\n  return fns.reduce((acc, fn) => fn(acc), value);\n}\n\n/**\n * Compose functions right-to-left\n * \n * Creates a reusable composed function that applies functions from right to left.\n * This is the traditional mathematical composition where (f  g)(x) = f(g(x)).\n * \n * @example\n * ```typescript\n * // Simple transformations\n * const transform = compose(\n *   x => x * 2,\n *   x => x + 5\n * );\n * transform(10); // (10 + 5) * 2 = 30\n * \n * // Reusable with Photon models\n * const centerAndRotate = compose(\n *   m => model.rotate(m, 45),\n *   m => model.center(m)\n * );\n * const square1 = centerAndRotate(new Square(100));\n * const square2 = centerAndRotate(new Rectangle(200, 100));\n * ```\n * \n * @param fns - Functions to compose (applied right-to-left)\n * @returns Composed function that can be called with an initial value\n */\nexport function compose<A>(fn1: (x: A) => A): (x: A) => A;\nexport function compose<A, B>(fn2: (x: A) => B, fn1: (x: A) => A): (x: A) => B;\nexport function compose<A, B, C>(\n  fn3: (x: B) => C,\n  fn2: (x: A) => B,\n  fn1: (x: A) => A\n): (x: A) => C;\nexport function compose<A, B, C, D>(\n  fn4: (x: C) => D,\n  fn3: (x: B) => C,\n  fn2: (x: A) => B,\n  fn1: (x: A) => A\n): (x: A) => D;\nexport function compose<A, B, C, D, E>(\n  fn5: (x: D) => E,\n  fn4: (x: C) => D,\n  fn3: (x: B) => C,\n  fn2: (x: A) => B,\n  fn1: (x: A) => A\n): (x: A) => E;\nexport function compose<A, B, C, D, E, F>(\n  fn6: (x: E) => F,\n  fn5: (x: D) => E,\n  fn4: (x: C) => D,\n  fn3: (x: B) => C,\n  fn2: (x: A) => B,\n  fn1: (x: A) => A\n): (x: A) => F;\nexport function compose<A, B, C, D, E, F, G>(\n  fn7: (x: F) => G,\n  fn6: (x: E) => F,\n  fn5: (x: D) => E,\n  fn4: (x: C) => D,\n  fn3: (x: B) => C,\n  fn2: (x: A) => B,\n  fn1: (x: A) => A\n): (x: A) => G;\nexport function compose<A, B, C, D, E, F, G, H>(\n  fn8: (x: G) => H,\n  fn7: (x: F) => G,\n  fn6: (x: E) => F,\n  fn5: (x: D) => E,\n  fn4: (x: C) => D,\n  fn3: (x: B) => C,\n  fn2: (x: A) => B,\n  fn1: (x: A) => A\n): (x: A) => H;\nexport function compose<A, B, C, D, E, F, G, H, I>(\n  fn9: (x: H) => I,\n  fn8: (x: G) => H,\n  fn7: (x: F) => G,\n  fn6: (x: E) => F,\n  fn5: (x: D) => E,\n  fn4: (x: C) => D,\n  fn3: (x: B) => C,\n  fn2: (x: A) => B,\n  fn1: (x: A) => A\n): (x: A) => I;\nexport function compose<A, B, C, D, E, F, G, H, I, J>(\n  fn10: (x: I) => J,\n  fn9: (x: H) => I,\n  fn8: (x: G) => H,\n  fn7: (x: F) => G,\n  fn6: (x: E) => F,\n  fn5: (x: D) => E,\n  fn4: (x: C) => D,\n  fn3: (x: B) => C,\n  fn2: (x: A) => B,\n  fn1: (x: A) => A\n): (x: A) => J;\nexport function compose<A>(...fns: Function[]): (x: A) => any {\n  return (x: A) => fns.reduceRight((acc, fn) => fn(acc), x);\n}\n","// ES Module imports\nimport type { IModel } from './schema.js';\nimport { isNumber, isPoint, isModel, round } from './maker.js';\nimport * as point from './point.js';\n\n/**\n * @private\n */\nexport interface IExportOptions {\n\n        /**\n         * Optional exemplar of number of decimal places.\n         */\n        accuracy?: number;\n\n        /**\n         * Optional unit system to embed in exported file, if the export format allows alternate unit systems.\n         */\n        units?: string;\n    }\n\n/**\n * Options for JSON export.\n */\nexport interface IJsonExportOptions extends IExportOptions {\n\n        /**\n         * Optional number of characters to indent after a newline.\n         */\n        indentation?: number;\n    }\n\n/**\n * Renders an item in JSON.\n * \n * @param itemToExport Item to render: may be a path, an array of paths, or a model object.\n * @param options Rendering options object.\n * @param options.accuracy Optional exemplar of number of decimal places.\n * @param options.indentation Optional number of characters to indent after a newline.\n * @returns String of DXF content.\n */\nexport function toJson(itemToExport: any, options: IJsonExportOptions = {}) {\n        function replacer(key: string, value: any) {\n            if (isNumber(value)) {\n                const newValue = round(value, options.accuracy);\n                return newValue\n            }\n            if (isPoint(value)) {\n                const newPoint = point.rounded(value, options.accuracy);\n                return newPoint;\n            }\n            return value;\n        }\n        return JSON.stringify(itemToExport, options.accuracy && replacer, options.indentation);\n    }\n\n/**\n * Try to get the unit system from a model\n * @private\n */\nexport function tryGetModelUnits(itemToExport: any) {\n        if (isModel(itemToExport)) {\n            return (<IModel>itemToExport).units;\n        }\n    }\n\n/**\n * Named colors, safe for CSS and DXF\n * 17 colors from https://www.w3.org/TR/CSS21/syndata.html#value-def-color mapped to DXF equivalent AutoDesk Color Index\n */\nexport const colors = {\n        black: 0,\n        red: 1,\n        yellow: 2,\n        lime: 3,\n        aqua: 4,\n        blue: 5,\n        fuchsia: 6,\n        white: 7,\n        gray: 9,\n        maroon: 14,\n        orange: 30,\n        olive: 58,\n        green: 94,\n        teal: 134,\n        navy: 174,\n        purple: 214,\n        silver: 254\n    }\n\nexport interface IStatusCallback {\n    (status: { progress?: number }): void;\n}\n","/** Attributes for an XML tag. */\nexport interface IXmlTagAttrs {\n    [name: string]: any;\n}\n\n/** Class for an XML tag. */\nexport class XmlTag {\n    /** Text between the opening and closing tags. */\n    public innerText = '';\n\n    /** Boolean to indicate that the innerText has been escaped. */\n    public innerTextEscaped: boolean;\n\n    /** Flag to explicitly close XML tags. */\n    public closingTags?: boolean;\n\n    /** Escapes certain characters within a string so that it can appear in a tag or its attribute. */\n    public static escapeString(value: string): string {\n        const escape = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;'\n        };\n\n        for (const code in escape) {\n            // .split then .join is a 'replace'\n            value = value.split(code).join(escape[code]);\n        }\n\n        return value;\n    }\n\n    constructor(public name: string, public attrs?: IXmlTagAttrs) {\n    }\n\n    /** Get the opening tag. */\n    public getOpeningTag(selfClose: boolean) {\n        let attrs = '';\n\n        const outputAttr = (attrName: string, attrValue: any) => {\n            if (attrValue == null || typeof attrValue === 'undefined') return;\n\n            if (Array.isArray(attrValue) || typeof attrValue === 'object') {\n                attrValue = JSON.stringify(attrValue);\n            }\n\n            if (typeof attrValue === 'string') {\n                attrValue = XmlTag.escapeString(attrValue);\n            }\n\n            attrs += ' ' + attrName + '=\"' + attrValue + '\"';\n        };\n\n        for (const name in this.attrs) {\n            outputAttr(name, this.attrs[name]);\n        }\n\n        return '<' + this.name + attrs + (selfClose ? '/' : '') + '>';\n    }\n\n    /** Get the inner text. */\n    public getInnerText(): string {\n        if (this.innerTextEscaped) {\n            return this.innerText;\n        } else {\n            return XmlTag.escapeString(this.innerText);\n        }\n    }\n\n    /** Get the closing tag. */\n    public getClosingTag() {\n        return '</' + this.name + '>';\n    }\n\n    /** Output the entire tag as a string. */\n    public toString(): string {\n        const selfClose = !this.innerText;\n        if (selfClose && !this.closingTags) {\n            return this.getOpeningTag(true);\n        } else {\n            return this.getOpeningTag(false) + this.getInnerText() + this.getClosingTag();\n        }\n    }\n}\n\n","import type { IModel, IPath, IPathLine, IPathCircle, IPathArc, IPathBezierSeed, IPoint } from './schema.js';\nimport { round, pathType, type IChain } from './maker.js';\nimport * as point from './point.js';\nimport * as angle from './angle.js';\nimport * as path from './path.js';\nimport * as paths from './paths.js';\nimport * as equal from './equal.js';\n\n// Internal SVG path data type\ninterface ISvgPathData extends Array<any> {}\n\n// --- Private helpers shared by both conversions ---\n\nfunction svgCoords(p: IPoint): IPoint {\n  // Mirror Y for SVG coordinate system\n  return point.mirror(p, false, true);\n}\n\nfunction correctArc(arc: IPathArc) {\n  const arcSpan = angle.ofArcSpan(arc);\n  arc.startAngle = angle.noRevolutions(arc.startAngle);\n  arc.endAngle = arc.startAngle + arcSpan;\n}\n\nfunction startSvgPathData(start: IPoint, d: ISvgPathData, accuracy: number): ISvgPathData {\n  return ['M', round(start[0], accuracy), round(start[1], accuracy)].concat(d);\n}\n\nfunction svgArcData(d: ISvgPathData, radius: number, endPoint: IPoint, accuracy: number, largeArc?: boolean, increasing?: boolean) {\n  const r = round(radius, accuracy);\n  const end: IPoint = endPoint;\n  d.push(r, r);\n  d.push(0);                 // x-axis rotation\n  d.push(largeArc ? 1 : 0);  // large-arc-flag\n  d.push(increasing ? 0 : 1);// sweep-flag 0=increasing, 1=decreasing\n  d.push(round(end[0], accuracy), round(end[1], accuracy));\n}\n\nfunction svgCircleData(radius: number, accuracy: number, clockwiseCircle?: boolean): ISvgPathData {\n  const r = round(radius, accuracy);\n  const d: ISvgPathData = ['m', -r, 0];\n  function halfCircle(sign: number) {\n    d.push('a');\n    svgArcData(d, r, [2 * r * sign, 0], accuracy, false, !clockwiseCircle);\n  }\n  halfCircle(1);\n  halfCircle(-1);\n  d.push('z');\n  return d;\n}\n\nfunction svgBezierData(d: ISvgPathData, seed: IPathBezierSeed, accuracy: number, reversed?: boolean) {\n  if (seed.controls.length === 1) {\n    d.push('Q', round(seed.controls[0][0], accuracy), round(seed.controls[0][1], accuracy));\n  } else {\n    const controls = reversed ? [seed.controls[1], seed.controls[0]] : seed.controls;\n    d.push('C',\n      round(controls[0][0], accuracy), round(controls[0][1], accuracy),\n      round(controls[1][0], accuracy), round(controls[1][1], accuracy)\n    );\n  }\n  const final = reversed ? seed.origin : seed.end;\n  d.push(round(final[0], accuracy), round(final[1], accuracy));\n}\n\n// --- Path to SVG path-data mapping ---\n\nconst svgPathDataMap: {\n  [pathType: string]: (pathContext: any, accuracy: number, clockwiseCircle?: boolean) => ISvgPathData\n} = {};\n\nsvgPathDataMap[pathType.Line] = function (line: IPathLine, accuracy: number) {\n  const e = point.rounded(line.end, accuracy);\n  const d: ISvgPathData = ['L', e[0], e[1]];\n  return startSvgPathData(line.origin, d, accuracy);\n};\n\nsvgPathDataMap[pathType.Circle] = function (circle: IPathCircle, accuracy: number, clockwiseCircle?: boolean) {\n  return startSvgPathData(circle.origin, svgCircleData(circle.radius, accuracy, clockwiseCircle), accuracy);\n};\n\nsvgPathDataMap[pathType.Arc] = function (arc: IPathArc, accuracy: number) {\n  correctArc(arc);\n  const arcPoints = point.fromArc(arc);\n  if (equal.isPointEqual(arcPoints[0], arcPoints[1])) {\n    return svgPathDataMap[pathType.Circle](arc, accuracy);\n  } else {\n    const d: ISvgPathData = ['A'];\n    svgArcData(\n      d,\n      arc.radius,\n      arcPoints[1],\n      accuracy,\n      angle.ofArcSpan(arc) > 180,\n      arc.startAngle > arc.endAngle\n    );\n    return startSvgPathData(arcPoints[0], d, accuracy);\n  }\n};\n\nsvgPathDataMap[pathType.BezierSeed] = function (seed: IPathBezierSeed, accuracy: number) {\n  const d: ISvgPathData = [];\n  svgBezierData(d, seed, accuracy);\n  return startSvgPathData(seed.origin, d, accuracy);\n};\n\n/**\n * Export a single path to SVG path-data string.\n */\nexport function pathToSVGPathData(pathToExport: IPath, pathOffset: IPoint, exportOffset: IPoint, accuracy = 0.001, clockwiseCircle?: boolean): string {\n  const fn = svgPathDataMap[pathToExport.type];\n  if (!fn) return '';\n\n  // clone -> move to offset -> mirror Y for SVG -> apply export offset\n  let fixedPath = path.clone(pathToExport);\n  fixedPath = path.moveRelative(fixedPath, pathOffset);\n  fixedPath = path.mirror(fixedPath, false, true);\n  path.moveRelative(fixedPath, exportOffset);\n\n  const d = fn(fixedPath as any, accuracy, clockwiseCircle);\n  return d.join(' ');\n}\n\n// --- Chain to SVG path-data mapping ---\n\nconst chainLinkToPathDataMap: {\n  [pathType: string]: (pathContext: any, endPoint: IPoint, reversed: boolean, d: ISvgPathData, accuracy: number) => void\n} = {};\n\nchainLinkToPathDataMap[pathType.Arc] = function (arc: IPathArc, endPoint: IPoint, reversed: boolean, d: ISvgPathData, accuracy: number) {\n  d.push('A');\n  svgArcData(\n    d,\n    arc.radius,\n    endPoint,\n    accuracy,\n    angle.ofArcSpan(arc) > 180,\n    reversed ? (arc.startAngle > arc.endAngle) : (arc.startAngle < arc.endAngle)\n  );\n};\n\nchainLinkToPathDataMap[pathType.Line] = function (_line: IPathLine, endPoint: IPoint, _reversed: boolean, d: ISvgPathData, accuracy: number) {\n  d.push('L', round(endPoint[0], accuracy), round(endPoint[1], accuracy));\n};\n\nchainLinkToPathDataMap[pathType.BezierSeed] = function (seed: IPathBezierSeed, _endPoint: IPoint, reversed: boolean, d: ISvgPathData, accuracy: number) {\n  svgBezierData(d, seed, accuracy, reversed);\n};\n\n/**\n * Convert a chain to SVG path-data string.\n */\nexport function chainToSVGPathData(chain: IChain, offset: IPoint, accuracy = 0.001): string {\n  const offsetPoint = (p: IPoint) => point.add(p, offset);\n\n  const first = chain.links[0];\n  const firstPoint = offsetPoint(svgCoords(first.endPoints[first.reversed ? 1 : 0]));\n\n  const d: ISvgPathData = ['M', round(firstPoint[0], accuracy), round(firstPoint[1], accuracy)];\n\n  for (let i = 0; i < chain.links.length; i++) {\n    const link = chain.links[i];\n    const pathContext = link.walkedPath.pathContext;\n\n    const fn = chainLinkToPathDataMap[pathContext.type];\n    if (!fn) continue;\n\n    // clone -> move to link offset -> mirror Y for SVG -> apply export offset\n    let fixedPath = path.clone(pathContext);\n    fixedPath = path.moveRelative(fixedPath, link.walkedPath.offset);\n    fixedPath = path.mirror(fixedPath, false, true);\n    path.moveRelative(fixedPath, offset);\n\n    fn(\n      fixedPath as any,\n      offsetPoint(svgCoords(link.endPoints[link.reversed ? 0 : 1])),\n      link.reversed,\n      d,\n      accuracy\n    );\n  }\n\n  if (chain.endless) {\n    d.push('Z');\n  }\n\n  return d.join(' ');\n}\n","/**\n * Create a numeric array from a string of numbers. The numbers may be delimited by anything non-numeric.\n * \n * Example:\n * ```\n * var n = makerjs.importer.parseNumericList('5, 10, 15.20 25-30-35 4e1 .5');\n * ```\n * \n * @param s The string of numbers.\n * @returns Array of numbers.\n */\nexport function parseNumericList(s: string): number[] {\n        var result: number[] = [];\n\n        //http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n        var re = /-?(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\n        var matches: RegExpExecArray;\n\n        while ((matches = re.exec(s)) !== null) {\n            if (matches.index === re.lastIndex) {\n                re.lastIndex++;\n            }\n            if (matches[0] !== \"\") result.push(parseFloat(matches[0]));\n        }\n\n        return result;\n    }\n","import type { IModel, IPoint, IPath, IPathMap, IPathLine, IPathArc } from './schema.js';\nimport {\n  extendObject,\n  isObject,\n  isModel,\n  isPath,\n  round,\n  unitType,\n  pathType,\n  type IFindChainsOptions,\n  type IContainChainsOptions,\n  type IWalkPath,\n  type IChain\n} from './maker.js';\nimport * as measure from './measure.js';\nimport * as chain from './chain.js';\nimport { XmlTag, type IXmlTagAttrs } from './xml.js';\nimport { tryGetModelUnits, colors, type IExportOptions } from './exporter.js';\nimport { pathToSVGPathData as pathToData, chainToSVGPathData as chainToData } from './svg-helpers.js';\nimport * as point from './point.js';\nimport * as angle from './angle.js';\nimport * as path from './path.js';\nimport * as paths from './paths.js';\nimport * as model from './model.js';\nimport * as equal from './equal.js';\nimport { parseNumericList } from './importer.js';\n// Use legacy global models if present; avoids compile-time coupling to pending model migrations\ndeclare const Photon: any;\nconst models: any = (typeof Photon !== 'undefined' && Photon.models) ? Photon.models : ({} as any);\n\nexport interface IPathDataByLayerMap {\n  [layer: string]: string;\n}\n\n// --- SVG Importer (ESM) ---\n\nexport interface ISVGImportOptions {\n  bezierAccuracy?: number;\n}\n\ninterface ISVGPathCommand {\n  command: string;\n  absolute?: boolean;\n  data: number[];\n  from: IPoint;\n  prev?: ISVGPathCommand;\n}\n\nexport function fromSVGPathData(pathData: string, options: ISVGImportOptions = {}): IModel {\n  const result: IModel = {};\n\n  let pathCount = 0;\n  const addPath = (p: IPath) => {\n    if (!result.paths) result.paths = {} as any;\n    (result.paths as any)['p_' + ++pathCount] = p;\n  };\n  const addModel = (m: IModel) => {\n    if (!result.models) result.models = {} as any;\n    (result.models as any)['p_' + ++pathCount] = m;\n  };\n\n  const getPoint = (cmd: ISVGPathCommand, offset = 0, from: IPoint = cmd.from): IPoint => {\n    if (offset < 0) offset = offset + cmd.data.length;\n    const p: IPoint = point.mirror([cmd.data[0 + offset], cmd.data[1 + offset]], false, true);\n    return cmd.absolute ? p : point.add(p, from);\n  };\n\n  const lineTo = (cmd: ISVGPathCommand, end: IPoint) => {\n    if (!equal.isPointEqual(cmd.from, end)) {\n      addPath(new paths.Line(cmd.from, end));\n    }\n    return end;\n  };\n\n  const map: { [command: string]: (cmd: ISVGPathCommand) => IPoint } = {};\n\n  let firstPoint: IPoint = [0, 0];\n\n  map['M'] = (cmd: ISVGPathCommand) => {\n    firstPoint = getPoint(cmd);\n    if (cmd.data.length > 2) {\n      cmd.from = firstPoint;\n      for (let a = 2; a < cmd.data.length; a += 2) {\n        cmd.from = lineTo(cmd, getPoint(cmd, a));\n      }\n      return cmd.from;\n    }\n    return firstPoint;\n  };\n\n  map['Z'] = (cmd: ISVGPathCommand) => lineTo(cmd, firstPoint);\n\n  map['H'] = (cmd: ISVGPathCommand) => {\n    const end = point.clone(cmd.from);\n    if (cmd.absolute) {\n      end[0] = cmd.data[0];\n    } else {\n      end[0] += cmd.data[0];\n    }\n    return lineTo(cmd, end);\n  };\n\n  map['V'] = (cmd: ISVGPathCommand) => {\n    const end = point.clone(cmd.from);\n    if (cmd.absolute) {\n      end[1] = -cmd.data[0];\n    } else {\n      end[1] -= cmd.data[0];\n    }\n    return lineTo(cmd, end);\n  };\n\n  map['L'] = (cmd: ISVGPathCommand) => {\n    let end: IPoint = cmd.from;\n    for (let a = 0; a < cmd.data.length; a += 2) {\n      end = getPoint(cmd, a);\n      cmd.from = lineTo(cmd, end);\n    }\n    return cmd.from;\n  };\n\n  map['A'] = (cmd: ISVGPathCommand) => {\n    let rx: number, ry: number, rotation: number, large: boolean, decreasing: boolean;\n    let end: IPoint = cmd.from;\n    let elliptic: boolean;\n    let xAxis: IPathLine;\n    let arc: IPathArc;\n    let scaleUp: number;\n    let e: IModel;\n    for (let a = 0; a < cmd.data.length; a += 7) {\n      rx = cmd.data[0 + a];\n      ry = cmd.data[1 + a];\n      rotation = cmd.data[2 + a];\n      large = cmd.data[3 + a] === 1;\n      decreasing = cmd.data[4 + a] === 1;\n      end = getPoint(cmd, 5 + a);\n      elliptic = rx !== ry;\n      xAxis = new paths.Line(cmd.from, point.rotate(end, rotation, cmd.from));\n      if (elliptic) {\n        xAxis = path.distort(xAxis, 1, rx / ry) as IPathLine;\n      }\n      arc = new paths.Arc(xAxis.origin, xAxis.end, rx, large, decreasing);\n      if (elliptic) {\n        if (rx < arc.radius) {\n          scaleUp = arc.radius / rx;\n          rx *= scaleUp;\n          ry *= scaleUp;\n        }\n        e = new models.EllipticArc(arc as any, 1, ry / rx, options.bezierAccuracy) as any;\n        model.rotate(e, -rotation, cmd.from);\n        addModel(e);\n      } else {\n        path.rotate(arc, -rotation, cmd.from);\n        addPath(arc);\n      }\n      cmd.from = end;\n    }\n    return end;\n  };\n\n  map['C'] = (cmd: ISVGPathCommand) => {\n    let control1: IPoint, control2: IPoint;\n    let start: IPoint = cmd.from;\n    let end: IPoint = start;\n    for (let a = 0; a < cmd.data.length; a += 6) {\n      cmd.from = start;\n      control1 = getPoint(cmd, 0 + a, start);\n      control2 = getPoint(cmd, 2 + a, start);\n      end = getPoint(cmd, 4 + a, start);\n      addModel(new models.BezierCurve(start, control1, control2, end, options.bezierAccuracy) as any);\n      start = end;\n    }\n    return end;\n  };\n\n  map['S'] = (cmd: ISVGPathCommand) => {\n    let control1: IPoint, prevControl2: IPoint, control2: IPoint;\n    let start: IPoint = cmd.from;\n    let end: IPoint = start;\n    if (cmd.prev && (cmd.prev.command === 'C' || cmd.prev.command === 'S')) {\n      prevControl2 = getPoint(cmd.prev, -4);\n    } else {\n      prevControl2 = cmd.from;\n    }\n    for (let a = 0; a < cmd.data.length; a += 4) {\n      cmd.from = start;\n      control1 = point.rotate(prevControl2, 180, start);\n      control2 = getPoint(cmd, 0 + a);\n      end = getPoint(cmd, 2 + a);\n      addModel(new models.BezierCurve(start, control1, control2, end, options.bezierAccuracy) as any);\n      start = end;\n      prevControl2 = control2;\n    }\n    return end;\n  };\n\n  map['Q'] = (cmd: ISVGPathCommand) => {\n    let control: IPoint;\n    let start: IPoint = cmd.from;\n    let end: IPoint = start;\n    for (let a = 0; a < cmd.data.length; a += 4) {\n      cmd.from = start;\n      control = getPoint(cmd, 0 + a);\n      end = getPoint(cmd, 2 + a);\n      addModel(new models.BezierCurve(start, control, end, options.bezierAccuracy) as any);\n      start = end;\n    }\n    return end;\n  };\n\n  map['T'] = (cmd: ISVGPathCommand) => {\n    let control: IPoint;\n    let prevControl: IPoint;\n    let end: IPoint = cmd.from;\n    if (cmd.prev && cmd.prev.command === 'Q') {\n      prevControl = getPoint(cmd.prev, -4);\n      control = point.rotate(prevControl, 180, cmd.from);\n    } else if (cmd.prev && cmd.prev.command === 'T') {\n      cmd.prev.absolute = true;\n      control = getPoint(cmd.prev, -2);\n    } else {\n      control = cmd.from;\n    }\n    for (let a = 0; a < cmd.data.length; a += 2) {\n      end = getPoint(cmd, 0 + a);\n      addModel(new models.BezierCurve(cmd.from, control, end, options.bezierAccuracy) as any);\n      cmd.from = end;\n      control = point.rotate(control, 180, cmd.from);\n    }\n    // save control point\n    const p = point.mirror(control, false, true);\n    cmd.data.push(p[0], p[1]);\n    return end;\n  };\n\n  // Parse and walk the commands\n  let currPoint: IPoint = [0, 0];\n  let prevCommand: ISVGPathCommand | undefined;\n  const regexpCommands = /([achlmqstvz])([0-9e\\.,\\+-\\s]*)/ig;\n  let commandMatches: RegExpExecArray | null;\n  while ((commandMatches = regexpCommands.exec(pathData)) !== null) {\n    if (commandMatches.index === regexpCommands.lastIndex) {\n      regexpCommands.lastIndex++;\n    }\n    const command = commandMatches[1];\n    const dataString = commandMatches[2];\n    const currCmd: ISVGPathCommand = {\n      command: command.toUpperCase(),\n      data: [],\n      from: currPoint,\n      prev: prevCommand\n    };\n    if (command === currCmd.command) currCmd.absolute = true;\n    currCmd.data = parseNumericList(dataString);\n    const fn = map[currCmd.command];\n    if (fn) currPoint = fn(currCmd);\n    prevCommand = currCmd;\n  }\n\n  return result;\n}\n\ninterface IPathDataMap {\n  [layer: string]: string[];\n}\n\nexport interface ISVGPathDataRenderOptions {\n  accuracy?: number;\n  byLayers?: boolean;\n  fillRule?: 'evenodd' | 'nonzero';\n  origin?: IPoint;\n}\n\nfunction getPathDataByLayer(modelToExport: IModel, offset: IPoint, options: IFindChainsOptions, accuracy = 0.001) {\n  const pathDataByLayer: IPathDataMap = {};\n  options.unifyBeziers = true;\n\n  chain.findChains(\n    modelToExport,\n    function (chains: IChain[], loose: IWalkPath[], layer: string) {\n      function single(walkedPath: IWalkPath, clockwise?: boolean) {\n        const pathData = pathToData(walkedPath.pathContext, walkedPath.offset, offset, accuracy, clockwise);\n        pathDataByLayer[layer].push(pathData);\n      }\n\n      pathDataByLayer[layer] = [];\n\n      function doChains(cs: IChain[], clockwise: boolean) {\n        cs.forEach(function (c: IChain) {\n          if (c.links.length > 1) {\n            const pathData = chainToData(c, offset, accuracy);\n            pathDataByLayer[layer].push(pathData);\n          } else {\n            single(c.links[0].walkedPath, clockwise);\n          }\n          if (c.contains) {\n            doChains(c.contains, !clockwise);\n          }\n        });\n      }\n\n      doChains(chains, true);\n      loose.forEach(wp => single(wp));\n    },\n    options\n  );\n\n  return pathDataByLayer;\n}\n\nexport function toSVGPathData(modelToExport: IModel, ...args: any[]): IPathDataByLayerMap | string {\n  const options: ISVGPathDataRenderOptions = {\n    fillRule: 'evenodd'\n  };\n\n  if (typeof args[0] === 'boolean') {\n    options.byLayers = args[0];\n    options.origin = args[1];\n    options.accuracy = args[2];\n  } else if (isObject(args[0])) {\n    extendObject(options, args[0]);\n  }\n\n  const findChainsOptions: IFindChainsOptions = {\n    byLayers: options.byLayers,\n    contain: false\n  };\n\n  if (options.fillRule === 'nonzero') {\n    findChainsOptions.contain = <IContainChainsOptions>{\n      alternateDirection: true\n    };\n  }\n\n  const size = measure.modelExtents(modelToExport);\n  if (!options.origin) {\n    options.origin = [-size.low[0], size.high[1]];\n  }\n\n  const pathDataArrayByLayer = getPathDataByLayer(modelToExport, options.origin, findChainsOptions, options.accuracy);\n  const pathDataStringByLayer: IPathDataByLayerMap = {};\n\n  for (const layer in pathDataArrayByLayer) {\n    pathDataStringByLayer[layer] = pathDataArrayByLayer[layer].join(' ');\n  }\n\n  return findChainsOptions.byLayers ? pathDataStringByLayer : pathDataStringByLayer[''];\n}\n\n// --- Minimal SVG rendering (path elements only) ---\n\nexport interface ISVGElementRenderOptions {\n  fill?: string;\n  stroke?: string;\n  strokeWidth?: string;\n  cssStyle?: string;\n  className?: string;\n}\n\nexport interface IFlowAnnotation {\n  size: number;\n}\n\nexport interface ISVGRenderOptions extends IExportOptions, ISVGElementRenderOptions {\n  accuracy?: number;\n  svgAttrs?: IXmlTagAttrs;\n  fontSize?: string;\n  scale?: number;\n  annotate?: boolean;\n  flow?: IFlowAnnotation;\n  origin?: IPoint;\n  useSvgPathOnly?: boolean;\n  viewBox?: boolean;\n  scalingStroke?: boolean;\n  layerOptions?: Record<string, ISVGElementRenderOptions>;\n  fillRule?: 'evenodd' | 'nonzero';\n}\n\nexport interface SvgUnitConversion {\n  [unit: string]: { svgUnitType: string; scaleConversion: number };\n}\n\nexport const svgUnit: SvgUnitConversion = {\n  [unitType.Inch]: { svgUnitType: 'in', scaleConversion: 1 },\n  [unitType.Millimeter]: { svgUnitType: 'mm', scaleConversion: 1 },\n  [unitType.Centimeter]: { svgUnitType: 'cm', scaleConversion: 1 },\n  [unitType.Foot]: { svgUnitType: 'in', scaleConversion: 12 },\n  [unitType.Meter]: { svgUnitType: 'cm', scaleConversion: 100 }\n};\n\nfunction cssStyle(elOpts: ISVGElementRenderOptions) {\n  const a: string[] = [];\n  const push = (name: string, val: string | undefined) => {\n    if (val === undefined) return;\n    a.push(name + ':' + val);\n  };\n  push('stroke', elOpts.stroke);\n  push('stroke-width', elOpts.strokeWidth);\n  push('fill', elOpts.fill);\n  return a.join(';');\n}\n\nfunction addSvgAttrs(attrs: IXmlTagAttrs, elOpts?: ISVGElementRenderOptions) {\n  if (!elOpts) return;\n  extendObject(attrs, {\n    stroke: elOpts.stroke,\n    'stroke-width': elOpts.strokeWidth,\n    fill: elOpts.fill,\n    style: (elOpts as any).cssStyle || cssStyle(elOpts),\n    class: elOpts.className\n  });\n}\n\nfunction colorLayerOptions(layer: string, layerOptions?: Record<string, ISVGElementRenderOptions>) {\n  if (layerOptions && layerOptions[layer]) return layerOptions[layer];\n  if (layer in colors) {\n    return { stroke: layer } as ISVGElementRenderOptions;\n  }\n}\n\nexport function toSVG(itemToExport: any, options: ISVGRenderOptions = {}): string {\n  // defaults\n  const opts: ISVGRenderOptions = {\n    accuracy: 0.001,\n    annotate: false,\n    origin: null as any,\n    scale: 1,\n    stroke: '#000',\n    strokeWidth: '0.25mm',\n    fill: 'none',\n    fillRule: 'evenodd',\n    fontSize: '9pt',\n    useSvgPathOnly: true,\n    viewBox: true,\n    scalingStroke: false,\n    ...options\n  };\n\n  let modelToExport: IModel;\n  const itemIsModel = isModel(itemToExport);\n  if (itemIsModel) {\n    modelToExport = itemToExport as IModel;\n  } else if (Array.isArray(itemToExport)) {\n    const pathMap: IPathMap = {};\n    (itemToExport as IPath[]).forEach((p, i) => { pathMap[String(i)] = p; });\n    modelToExport = { paths: pathMap } as IModel;\n  } else if (isPath(itemToExport)) {\n    modelToExport = { paths: { modelToMeasure: itemToExport as IPath } } as any;\n  } else {\n    return '';\n  }\n\n  // units\n  if (!opts.units) {\n    const unitSystem = tryGetModelUnits(itemToExport);\n    if (unitSystem) opts.units = unitSystem;\n  }\n  const useSvgUnit = opts.units ? svgUnit[opts.units] : undefined;\n\n  // size and origin\n  const size = measure.modelExtents(modelToExport);\n  if (!opts.origin) {\n    if (size) {\n      const scale = opts.scale ?? 1;\n      const left = -size.low[0] * scale;\n      opts.origin = [left, size.high[1] * scale];\n    } else {\n      opts.origin = [0, 0];\n    }\n  }\n\n  // Include caption extents before sizing to ensure viewBox fits text\n  const captionsForSizing = model.getAllCaptionsOffset(modelToExport);\n  if (captionsForSizing && captionsForSizing.length && size) {\n    captionsForSizing.forEach(c => {\n      measure.increase(size, measure.pathExtents(c.anchor), true);\n    });\n  }\n\n  // begin SVG\n  const elements: string[] = [];\n\n  let svgAttrs: IXmlTagAttrs = {};\n  if (size && opts.viewBox) {\n    let scaleFactor = opts.scale ?? 1;\n    if (useSvgUnit && opts.viewBox) {\n      scaleFactor *= useSvgUnit.scaleConversion;\n    }\n    const width = round(size.width * scaleFactor, opts.accuracy);\n    const height = round(size.height * scaleFactor, opts.accuracy);\n    const viewBox = [0, 0, width, height];\n    const unit = useSvgUnit ? useSvgUnit.svgUnitType : '';\n    svgAttrs = {\n      width: String(width) + unit,\n      height: String(height) + unit,\n      viewBox: viewBox.join(' ')\n    };\n  }\n  svgAttrs['xmlns'] = 'http://www.w3.org/2000/svg';\n  const svgTag = new XmlTag('svg', extendObject(svgAttrs, opts.svgAttrs));\n  elements.push(svgTag.getOpeningTag(false));\n\n  const groupAttrs: IXmlTagAttrs = {\n    id: 'svgGroup',\n    'stroke-linecap': 'round',\n    'fill-rule': opts.fillRule,\n    'font-size': opts.fontSize\n  };\n  addSvgAttrs(groupAttrs, opts);\n  const svgGroup = new XmlTag('g', groupAttrs);\n  elements.push(svgGroup.getOpeningTag(false));\n\n  // Captions for rendering\n  const captions = model.getAllCaptionsOffset(modelToExport);\n\n  if (opts.useSvgPathOnly) {\n    // Path-only rendering (existing behavior)\n    const findChainsOptions: IFindChainsOptions = { byLayers: true };\n    if (opts.fillRule === 'nonzero') {\n      findChainsOptions.contain = <IContainChainsOptions>{ alternateDirection: true };\n    }\n    const pathDataByLayer = getPathDataByLayer(modelToExport, opts.origin!, findChainsOptions, opts.accuracy);\n    for (const layerId in pathDataByLayer) {\n      const pathData = pathDataByLayer[layerId].join(' ');\n      const attrs: IXmlTagAttrs = { d: pathData } as any;\n      if (layerId.length > 0) {\n        (attrs as any).id = layerId;\n      }\n      addSvgAttrs(attrs, colorLayerOptions(layerId, opts.layerOptions));\n      const pathTag = new XmlTag('path', attrs);\n      elements.push(pathTag.toString());\n    }\n  } else {\n    // Full element rendering (non-path mode)\n    const layers: Record<string, string[]> = {};\n\n    const append = (value: string, layer?: string, forcePush = false) => {\n      if (!forcePush && typeof layer === 'string' && layer.length > 0) {\n        if (!(layer in layers)) layers[layer] = [];\n        layers[layer].push(value);\n      } else {\n        elements.push(value);\n      }\n    };\n\n    const addSvgAttrsLocal = (attrs: IXmlTagAttrs, layer: string) => {\n      addSvgAttrs(attrs, colorLayerOptions(layer, opts.layerOptions));\n      if (!opts.scalingStroke) {\n        (attrs as any)['vector-effect'] = 'non-scaling-stroke';\n      }\n    };\n\n    const createElementLocal = (tagname: string, attrs: IXmlTagAttrs, layer: string, innerText: string | null = null, forcePush = false) => {\n      if (tagname !== 'text') {\n        addSvgAttrsLocal(attrs, layer);\n      }\n      const tag = new XmlTag(tagname, attrs);\n      if (innerText) tag.innerText = innerText;\n      append(tag.toString(), layer, forcePush);\n    };\n\n    const fixPoint = (p: IPoint): IPoint => {\n      const mirrored = point.mirror(p, false, true);\n      return point.scale(mirrored, opts.scale ?? 1);\n    };\n\n    const fixPath = (p: any, origin: IPoint): any => {\n      const mirrorY = path.mirror(p, false, true);\n      const scaled = path.scale(mirrorY, opts.scale ?? 1);\n      return path.moveRelative(scaled, origin);\n    };\n\n    // Local helpers for arcs and beziers (duplicated to avoid exporting internals)\n    const svgArcData = (d: any[], radius: number, endPoint: IPoint, accuracy = 0.001, largeArc?: boolean, increasing?: boolean) => {\n      const r = round(radius, accuracy);\n      d.push(r, r);\n      d.push(0);\n      d.push(largeArc ? 1 : 0);\n      d.push(increasing ? 0 : 1);\n      d.push(round(endPoint[0], accuracy), round(endPoint[1], accuracy));\n    };\n\n    const svgBezierData = (d: any[], seed: any, accuracy = 0.001, reversed?: boolean) => {\n      if (seed.controls.length === 1) {\n        d.push('Q', round(seed.controls[0][0], accuracy), round(seed.controls[0][1], accuracy));\n      } else {\n        const controls = reversed ? [seed.controls[1], seed.controls[0]] : seed.controls;\n        d.push('C',\n          round(controls[0][0], accuracy), round(controls[0][1], accuracy),\n          round(controls[1][0], accuracy), round(controls[1][1], accuracy)\n        );\n      }\n      const final = reversed ? seed.origin : seed.end;\n      d.push(round(final[0], accuracy), round(final[1], accuracy));\n    };\n\n    const drawText = (id: string, textPoint: IPoint, layer: string) => {\n      createElementLocal('text', {\n        id: id + '_text',\n        x: round(textPoint[0], opts.accuracy),\n        y: round(textPoint[1], opts.accuracy)\n      } as any, layer, id);\n    };\n\n    const drawPath = (id: string, x: number, y: number, d: any[], layer: string, route: string[] | null, textPoint: IPoint, annotate: boolean) => {\n      const attrs: IXmlTagAttrs = {\n        id,\n        d: ['M', round(x, opts.accuracy), round(y, opts.accuracy)].concat(d).join(' ')\n      } as any;\n      if (route) (attrs as any)['data-route'] = route;\n      createElementLocal('path', attrs, layer);\n      if (annotate) drawText(id, textPoint, layer);\n    };\n\n    const addFlowMarks = (flow: IFlowAnnotation | undefined, layer: string, origin: IPoint, end: IPoint, endAngle: number) => {\n      if (!flow) return;\n      const className = 'flow';\n      // origin circle\n      createElementLocal('circle', {\n        r: flow.size / 2,\n        cx: round(origin[0], opts.accuracy),\n        cy: round(origin[1], opts.accuracy),\n        class: className\n      } as any, layer);\n      // arrow lines\n      const arrowEnd: IPoint = [-1 * flow.size, flow.size / 2];\n      const p1 = point.add(point.rotate(arrowEnd, endAngle), end);\n      const p2 = point.mirror(arrowEnd, false, true);\n      const p2r = point.add(point.rotate(p2, endAngle), end);\n      createElementLocal('line', {\n        x1: round(p1[0], opts.accuracy), y1: round(p1[1], opts.accuracy),\n        x2: round(end[0], opts.accuracy), y2: round(end[1], opts.accuracy),\n        class: className\n      } as any, layer);\n      createElementLocal('line', {\n        x1: round(p2r[0], opts.accuracy), y1: round(p2r[1], opts.accuracy),\n        x2: round(end[0], opts.accuracy), y2: round(end[1], opts.accuracy),\n        class: className\n      } as any, layer);\n    };\n\n    const map: { [type: string]: (id: string, pathValue: any, layer: string, className: string | null, route: string[] | null, annotate: boolean) => void } = {};\n\n    map[pathType.Line] = (id, line, layer, className, route, annotate) => {\n      const start = line.origin;\n      const end = line.end;\n      const attrs: IXmlTagAttrs = {\n        id,\n        x1: round(start[0], opts.accuracy), y1: round(start[1], opts.accuracy),\n        x2: round(end[0], opts.accuracy), y2: round(end[1], opts.accuracy)\n      } as any;\n      if (className) (attrs as any).class = className;\n      if (route) (attrs as any)['data-route'] = route;\n      createElementLocal('line', attrs, layer);\n      if (annotate) drawText(id, point.middle(line), layer);\n      if (opts.flow) addFlowMarks(opts.flow, layer, line.origin, line.end, angle.ofLineInDegrees(line));\n    };\n\n    map[pathType.Circle] = (id, circle, layer, className, route, annotate) => {\n      const center = circle.origin;\n      const attrs: IXmlTagAttrs = {\n        id,\n        r: circle.radius,\n        cx: round(center[0], opts.accuracy), cy: round(center[1], opts.accuracy)\n      } as any;\n      if (className) (attrs as any).class = className;\n      if (route) (attrs as any)['data-route'] = route;\n      createElementLocal('circle', attrs, layer);\n      if (annotate) drawText(id, center, layer);\n    };\n\n    map[pathType.Arc] = (id, arc, layer, className, route, annotate) => {\n      // normalize arc angles\n      const arcSpan = angle.ofArcSpan(arc);\n      arc.startAngle = angle.noRevolutions(arc.startAngle);\n      arc.endAngle = arc.startAngle + arcSpan;\n      const arcPoints = point.fromArc(arc);\n      if (equal.isPointEqual(arcPoints[0], arcPoints[1])) {\n        map[pathType.Circle](id, { origin: arc.origin, radius: arc.radius }, layer, className, route, annotate);\n      } else {\n        const d: any[] = ['A'];\n        svgArcData(d, arc.radius, arcPoints[1], opts.accuracy, angle.ofArcSpan(arc) > 180, arc.startAngle > arc.endAngle);\n        drawPath(id, arcPoints[0][0], arcPoints[0][1], d, layer, route, point.middle(arc), annotate);\n        addFlowMarks(opts.flow, layer, arcPoints[1], arcPoints[0], angle.noRevolutions(arc.startAngle - 90));\n      }\n    };\n\n    map[pathType.BezierSeed] = (id, seed, layer, className, route, annotate) => {\n      const d: any[] = [];\n      svgBezierData(d, seed, opts.accuracy);\n      drawPath(id, seed.origin[0], seed.origin[1], d, layer, route, point.middle(seed), annotate);\n    };\n\n    const modelGroup = new XmlTag('g');\n\n    const beginModel = (id: string, modelContext: IModel) => {\n      modelGroup.attrs = { id } as any;\n      append(modelGroup.getOpeningTag(false), modelContext.layer);\n    };\n\n    const endModel = (modelContext: IModel) => {\n      append(modelGroup.getClosingTag(), modelContext.layer);\n    };\n\n    beginModel('0', modelToExport);\n\n    const walkOptions: any = {\n      beforeChildWalk: (walkedModel: any) => { beginModel(walkedModel.childId, walkedModel.childModel); return true; },\n      onPath: (walkedPath: any) => {\n        const pctx = walkedPath.pathContext;\n        const layer = walkedPath.layer;\n        const offset = point.add(fixPoint(walkedPath.offset), opts.origin!);\n        const fixed = fixPath(pctx, offset);\n        switch (pctx.type) {\n          case pathType.Line:\n            map[pathType.Line](walkedPath.pathId, fixed, layer, null, walkedPath.route, opts.annotate);\n            break;\n          case pathType.Circle:\n            map[pathType.Circle](walkedPath.pathId, fixed, layer, null, walkedPath.route, opts.annotate);\n            break;\n          case pathType.Arc:\n            map[pathType.Arc](walkedPath.pathId, fixed, layer, null, walkedPath.route, opts.annotate);\n            break;\n          case pathType.BezierSeed:\n            map[pathType.BezierSeed](walkedPath.pathId, fixed, layer, null, walkedPath.route, opts.annotate);\n            break;\n          default:\n            // fallback to path element for unknown types\n            const d = pathToData(pctx, walkedPath.offset, opts.origin!, opts.accuracy);\n            const attrs: IXmlTagAttrs = { id: walkedPath.pathId, d } as any;\n            createElementLocal('path', attrs, layer);\n            break;\n        }\n      },\n      afterChildWalk: (walkedModel: any) => { endModel(walkedModel.childModel); }\n    };\n\n    model.walk(modelToExport, walkOptions);\n\n    // export layers as groups\n    for (const layerId in layers) {\n      const layerGroup = new XmlTag('g', { id: layerId } as any);\n      addSvgAttrs(layerGroup.attrs, colorLayerOptions(layerId, opts.layerOptions));\n      layerGroup.innerText = layers[layerId].join('');\n      layerGroup.innerTextEscaped = true;\n      elements.push(layerGroup.toString());\n    }\n\n    endModel(modelToExport);\n\n    // Captions\n    if (captions && captions.length) {\n      const captionTags = captions.map(caption => {\n        const anchor = fixPath(caption.anchor, opts.origin!) as any;\n        const center = point.rounded(point.middle(anchor), opts.accuracy);\n        const tag = new XmlTag('text', {\n          'alignment-baseline': 'middle',\n          'text-anchor': 'middle',\n          transform: `rotate(${angle.ofLineInDegrees(anchor)},${center[0]},${center[1]})`,\n          x: center[0],\n          y: center[1]\n        } as any);\n        addSvgAttrs(tag.attrs, colorLayerOptions(caption.layer, opts.layerOptions));\n        tag.innerText = caption.text;\n        return tag.toString();\n      });\n      if (captionTags.length) {\n        const captionGroup = new XmlTag('g', { id: 'captions' } as any);\n        addSvgAttrs(captionGroup.attrs, colorLayerOptions('captions', opts.layerOptions));\n        captionGroup.innerText = captionTags.join('');\n        captionGroup.innerTextEscaped = true;\n        elements.push(captionGroup.toString());\n      }\n    }\n  }\n\n  elements.push(svgGroup.getClosingTag());\n  elements.push(svgTag.getClosingTag());\n  return elements.join('');\n}\n","import { IPoint, IPath, IPathLine, IPathArc } from './schema.js';\nimport { pathType, round, extendObject } from './maker.js';\nimport * as point from './point.js';\nimport * as angle from './angle.js';\nimport * as measure from './measure.js';\nimport * as equal from './equal.js';\nimport { Line, Circle, Arc, Parallel } from './paths.js';\nimport * as path from './path.js';\nimport { intersection } from './intersect.js';\nimport { breakAtPoint } from './break.js';\nimport type { IPointMatchOptions } from './maker.js';\n\n/** @private */\ninterface IPointProperty {\n  point: IPoint;\n  propertyName: string;\n}\n\n/** @private */\nexport interface IMatchPointProperty extends IPointProperty {\n  path: IPath;\n  isStart: boolean;\n  oppositePoint: IPoint;\n  shardPoint?: IPoint;\n}\n\n/** @private */\nexport interface IFilletResult {\n  filletAngle: number;\n  clipPath: () => void;\n}\n\nconst propertyNamesMap: { [pathType: string]: (p: IPath) => string[] } = {};\npropertyNamesMap[pathType.Arc] = (_arc: IPathArc) => ['startAngle', 'endAngle'];\npropertyNamesMap[pathType.Line] = (_line: IPathLine) => ['origin', 'end'];\n\n/** @private */\nexport function getPointProperties(pathToInspect: IPath): IPointProperty[] {\n  const points = point.fromPathEnds(pathToInspect);\n  if (!points) return null;\n\n  const propertyNames = propertyNamesMap[pathToInspect.type]?.(pathToInspect);\n  if (!propertyNames) return null;\n\n  const pointProperty = (index: number): IPointProperty => ({\n    point: points[index],\n    propertyName: propertyNames[index],\n  });\n\n  return [pointProperty(0), pointProperty(1)];\n}\n\n/** @private */\nexport function getMatchingPointProperties(pathA: IPath, pathB: IPath, _options?: IPointMatchOptions): IMatchPointProperty[] {\n  const pathAProps = getPointProperties(pathA);\n  const pathBProps = getPointProperties(pathB);\n  if (!pathAProps || !pathBProps) return null;\n\n  const makeMatch = (pathContext: IPath, props: IPointProperty[], index: number): IMatchPointProperty => ({\n    path: pathContext,\n    isStart: index === 0,\n    propertyName: props[index].propertyName,\n    point: props[index].point,\n    oppositePoint: props[1 - index].point,\n  });\n\n  const check = (iA: number, iB: number) => {\n    if (equal.isPointEqual(pathAProps[iA].point, pathBProps[iB].point, 0.0001)) {\n      return [makeMatch(pathA, pathAProps, iA), makeMatch(pathB, pathBProps, iB)] as IMatchPointProperty[];\n    }\n    return null;\n  };\n\n  return check(0, 0) || check(0, 1) || check(1, 0) || check(1, 1);\n}\n\n/** @private */\nexport function populateShardPointsFromReferenceCircle(\n  filletRadius: number,\n  center: IPoint,\n  properties: IMatchPointProperty[],\n  _options: IPointMatchOptions\n): boolean {\n  const referenceCircle = new Circle(center, filletRadius);\n\n  for (let i = 0; i < 2; i++) {\n    const circleIntersection = intersection(referenceCircle, properties[i].path);\n    if (!circleIntersection) return false;\n\n    properties[i].shardPoint = circleIntersection.intersectionPoints[0];\n\n    if (equal.isPointEqual(properties[i].point, circleIntersection.intersectionPoints[0], 0.0001)) {\n      if (circleIntersection.intersectionPoints.length > 1) {\n        properties[i].shardPoint = circleIntersection.intersectionPoints[1];\n      } else {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/** @private */\nexport function cloneAndBreakPath(pathToShard: IPath, shardPoint: IPoint): IPath[] {\n  const shardStart = path.clone(pathToShard);\n  const shardEnd = breakAtPoint(shardStart, shardPoint);\n  return [shardStart, shardEnd];\n}\n\nconst guidePathMap: {\n  [pathType: string]: (\n    pathContext: IPath,\n    filletRadius: number,\n    nearPoint: IPoint,\n    shardPoint: IPoint,\n    isStart: boolean\n  ) => IPath;\n} = {};\n\nguidePathMap[pathType.Arc] = (arc: IPathArc, filletRadius: number, nearPoint: IPoint, shardPoint: IPoint, isStart: boolean) => {\n  let guideRadius = arc.radius;\n\n  const guideArcShard = cloneAndBreakPath(arc, shardPoint)[isStart ? 0 : 1] as IPathArc;\n  if (!guideArcShard) return null;\n\n  if (measure.isArcConcaveTowardsPoint(guideArcShard, nearPoint)) {\n    guideRadius -= filletRadius;\n  } else {\n    guideRadius += filletRadius;\n  }\n\n  if (round(guideRadius) <= 0) return null;\n\n  return new Arc(arc.origin, guideRadius, arc.startAngle, arc.endAngle);\n};\n\nguidePathMap[pathType.Line] = (line: IPathLine, filletRadius: number, nearPoint: IPoint) => new Parallel(line, filletRadius, nearPoint);\n\n/** @private */\nexport function getGuidePath(context: IMatchPointProperty, filletRadius: number, nearPoint: IPoint): IPath {\n  const fn = guidePathMap[context.path.type];\n  return fn ? fn(context.path, filletRadius, nearPoint, context.shardPoint, context.isStart) : null;\n}\n\nconst filletResultMap: {\n  [pathType: string]: (\n    pathContext: IPath,\n    propertyName: string,\n    filletRadius: number,\n    filletCenter: IPoint\n  ) => IFilletResult;\n} = {};\n\nfilletResultMap[pathType.Arc] = (arc: IPathArc, propertyName: string, _filletRadius: number, filletCenter: IPoint) => {\n  const guideLine = new Line(arc.origin, filletCenter);\n  const guideLineAngle = angle.ofLineInDegrees(guideLine);\n  let filletAngle = guideLineAngle;\n\n  if (!measure.isArcConcaveTowardsPoint(arc, filletCenter)) {\n    filletAngle += 180;\n  }\n\n  return {\n    filletAngle: angle.noRevolutions(filletAngle),\n    clipPath: () => {\n      (arc as any)[propertyName] = guideLineAngle;\n    },\n  };\n};\n\nfilletResultMap[pathType.Line] = (line: IPathLine, propertyName: string, _filletRadius: number, filletCenter: IPoint) => {\n  const guideLine = new Line([0, 0], [0, 1]);\n  const lineAngle = angle.ofLineInDegrees(line);\n  path.rotate(guideLine, lineAngle, [0, 0]);\n  path.moveRelative(guideLine, filletCenter);\n\n  const intersectionPoint = point.fromSlopeIntersection(line, guideLine);\n  if (!intersectionPoint) return null;\n\n  return {\n    filletAngle: angle.ofPointInDegrees(filletCenter, intersectionPoint),\n    clipPath: () => {\n      (line as any)[propertyName] = intersectionPoint;\n    },\n  };\n};\n\n/** @private */\nexport function getFilletResult(context: IMatchPointProperty, filletRadius: number, filletCenter: IPoint): IFilletResult {\n  const fn = filletResultMap[context.path.type];\n  const result = fn ? fn(context.path, context.propertyName, filletRadius, filletCenter) : null;\n  return testFilletResult(context, result) ? result : null;\n}\n\n/** @private */\nexport function getDogboneResult(context: IMatchPointProperty, filletCenter: IPoint): IFilletResult {\n  const result: IFilletResult = {\n    filletAngle: angle.ofPointInDegrees(filletCenter, context.shardPoint),\n    clipPath: () => {\n      (context.path as any)[context.propertyName] = context.shardPoint;\n    },\n  };\n  return testFilletResult(context, result) ? result : null;\n}\n\n/** @private */\nexport function testFilletResult(context: IMatchPointProperty, result: IFilletResult): boolean {\n  if (!result) return false;\n\n  const originalValue = (context.path as any)[context.propertyName];\n  result.clipPath();\n  const ok = measure.pathLength(context.path) > 0;\n  (context.path as any)[context.propertyName] = originalValue;\n  return ok;\n}\n\n/** @private */\nexport function getLineRatio(lines: IPathLine[]): number {\n  let totalLength = 0;\n  const lengths: number[] = [];\n  for (let i = 0; i < lines.length; i++) {\n    const length = measure.pathLength(lines[i]);\n    lengths.push(length);\n    totalLength += length;\n  }\n  return lengths[0] / totalLength;\n}\n","import { IPoint, IPath, IPathLine, IPathArc } from './schema.js';\nimport { round, isPathLine, extendObject } from './maker.js';\nimport * as point from './point.js';\nimport * as angle from './angle.js';\nimport { Arc, Line } from './paths.js';\nimport {\n  getMatchingPointProperties,\n  populateShardPointsFromReferenceCircle,\n  getGuidePath,\n  getFilletResult,\n  getDogboneResult,\n  getLineRatio,\n  IMatchPointProperty,\n} from './fillet-core.js';\nimport type { IPointMatchOptions } from './maker.js';\nimport { intersection } from './intersect.js';\n\nexport function pathDogbone(lineA: IPathLine, lineB: IPathLine, filletRadius: number, options?: IPointMatchOptions): IPathArc | null {\n  if (!isPathLine(lineA) || !isPathLine(lineB) || !filletRadius || filletRadius <= 0) return null;\n\n  const opts: IPointMatchOptions = { pointMatchingDistance: 0.005 };\n  extendObject(opts, options);\n\n  const commonProperty = getMatchingPointProperties(lineA, lineB, opts);\n  if (!commonProperty) return null;\n\n  const ratio = getLineRatio([lineA, lineB]);\n  const span = new Line(commonProperty[0].oppositePoint, commonProperty[1].oppositePoint);\n  const midRatioPoint = point.middle(span, ratio);\n  const bisectionAngle = angle.ofPointInDegrees(commonProperty[0].point, midRatioPoint);\n  const center = point.add(commonProperty[0].point, point.fromPolar(angle.toRadians(bisectionAngle), filletRadius));\n\n  if (!populateShardPointsFromReferenceCircle(filletRadius, center, commonProperty, opts)) return null;\n\n  const results: { filletAngle: number; clipPath: () => void }[] = [];\n  for (let i = 0; i < 2; i++) {\n    const result = getDogboneResult(commonProperty[i], center);\n    if (!result) return null;\n    results.push(result);\n  }\n\n  const filletArc = new Arc(center, filletRadius, results[0].filletAngle, results[1].filletAngle);\n\n  if (round(angle.noRevolutions(angle.ofArcMiddle(filletArc))) === round(bisectionAngle)) {\n    filletArc.startAngle = results[1].filletAngle;\n    filletArc.endAngle = results[0].filletAngle;\n  }\n\n  results[0].clipPath();\n  results[1].clipPath();\n\n  return filletArc;\n}\n\nexport function pathFillet(pathA: IPath, pathB: IPath, filletRadius: number, options?: IPointMatchOptions): IPathArc | null {\n  if (!pathA || !pathB || !filletRadius || filletRadius <= 0) return null;\n\n  const opts: IPointMatchOptions = { pointMatchingDistance: 0.005 };\n  extendObject(opts, options);\n\n  const commonProperty = getMatchingPointProperties(pathA, pathB, opts);\n  if (!commonProperty) return null;\n\n  if (!populateShardPointsFromReferenceCircle(filletRadius, commonProperty[0].point, commonProperty, opts)) return null;\n\n  const guidePaths: IPath[] = [];\n  for (let i = 0; i < 2; i++) {\n    const otherPathShardPoint = commonProperty[1 - i].shardPoint;\n    if (!otherPathShardPoint) return null;\n    const guidePath = getGuidePath(commonProperty[i], filletRadius, otherPathShardPoint);\n    guidePaths.push(guidePath);\n  }\n\n  const intersectionPoint = intersection(guidePaths[0], guidePaths[1]);\n  if (!intersectionPoint) return null;\n\n  let center: IPoint;\n  if (intersectionPoint.intersectionPoints.length === 1) {\n    center = intersectionPoint.intersectionPoints[0];\n  } else {\n    center = point.closest(commonProperty[0].point, intersectionPoint.intersectionPoints);\n  }\n\n  const results = [] as { filletAngle: number; clipPath: () => void }[];\n  for (let i = 0; i < 2; i++) {\n    const result = getFilletResult(commonProperty[i], filletRadius, center);\n    if (!result) return null;\n    results.push(result);\n  }\n\n  if (round(results[0].filletAngle - results[1].filletAngle) === 0) return null;\n\n  const filletArc = new Arc(center, filletRadius, results[0].filletAngle, results[1].filletAngle);\n  const filletSpan = angle.ofArcSpan(filletArc);\n\n  if (filletSpan === 180) return null;\n  if (filletSpan > 180) {\n    filletArc.startAngle = results[1].filletAngle;\n    filletArc.endAngle = results[0].filletAngle;\n  }\n\n  results[0].clipPath();\n  results[1].clipPath();\n  return filletArc;\n}\n","import type { IModel, IPathArc, IPathLine } from './schema.js';\nimport { isObject, round, IChain } from './maker.js';\nimport * as angle from './angle.js';\nimport * as path from './path.js';\nimport { pathFillet, pathDogbone } from './fillet-path.js';\n\nexport function chainDogbone(chainToFillet: IChain, filletSpec: number | { left?: number; right?: number }): IModel | null {\n    return chainFilletInternal(false, chainToFillet, filletSpec);\n}\n\nexport function chainFillet(chainToFillet: IChain, filletSpec: number | { left?: number; right?: number }): IModel | null {\n    return chainFilletInternal(true, chainToFillet, filletSpec);\n}\n\nfunction chainFilletInternal(traditional: boolean, chainToFillet: IChain, filletSpec: number | { left?: number; right?: number }): IModel | null {\n    const result: IModel = { paths: {} };\n    let added = 0;\n    const links = chainToFillet.links;\n\n    const add = (i1: number, i2: number) => {\n        const p1 = links[i1].walkedPath;\n        const p2 = links[i2].walkedPath;\n\n        path.moveTemporary([p1.pathContext, p2.pathContext], [p1.offset, p2.offset], () => {\n            let filletRadius: number;\n            if (isObject(filletSpec)) {\n                const a = angle.ofChainLinkJoint(links[i1], links[i2]);\n                if (a == null || round(a) === 0) return;\n                const spec = filletSpec as { left?: number; right?: number };\n                filletRadius = a > 0 ? (spec.left as number) : (spec.right as number);\n                if (typeof filletRadius !== 'number') return;\n            } else {\n                filletRadius = filletSpec as number;\n            }\n            if (!filletRadius || filletRadius < 0) return;\n\n            let filletArc: IPathArc | null;\n            if (traditional) {\n                filletArc = pathFillet(p1.pathContext, p2.pathContext, filletRadius);\n            } else {\n                filletArc = pathDogbone(p1.pathContext as IPathLine, p2.pathContext as IPathLine, filletRadius);\n            }\n\n            if (filletArc) {\n                if (!result.paths) result.paths = {};\n                result.paths['fillet' + added] = filletArc;\n                added++;\n            }\n        });\n    };\n\n    for (let i = 1; i < links.length; i++) {\n        add(i - 1, i);\n    }\n\n    if (chainToFillet.endless && links.length > 1) {\n        add(links.length - 1, 0);\n    }\n\n    if (!added) return null;\n    return result;\n}\n","import { IModel, IPoint } from './schema.js';\nimport { IWalkPath, IWalkOptions, IWalkModel, IWalkPathBooleanCallback } from './maker.js';\nimport * as point from './point.js';\nimport * as model from './model.js';\nimport { PointGraph, IPointGraphIndexElement } from './collect.js';\n\n/**\n * @private\n */\ninterface IWalkPathWithEndpoints extends IWalkPath {\n  endPoints: IPoint[];\n}\n\n/**\n * @private\n */\ninterface IDeadEndFinderOptions {\n  pointMatchingDistance?: number;\n  keep?: IWalkPathBooleanCallback;\n}\n\n/**\n * Internal class to find and remove dead-end paths.\n */\nclass DeadEndFinder {\n  public pointMap: PointGraph<IWalkPathWithEndpoints>;\n  private list: IPointGraphIndexElement[];\n  private removed: IWalkPathWithEndpoints[];\n  private ordinals: { [pointId: number]: number };\n\n  constructor(public modelContext: IModel, public options: IDeadEndFinderOptions) {\n    this.pointMap = new PointGraph<IWalkPathWithEndpoints>();\n    this.list = [];\n    this.removed = [];\n    this.ordinals = {};\n    this.load();\n  }\n\n  private load() {\n    const walkOptions: IWalkOptions = {\n      onPath: (walkedPath: IWalkPath) => {\n        const endPoints = point.fromPathEnds(walkedPath.pathContext, walkedPath.offset);\n\n        if (!endPoints) return;\n\n        const pathRef = walkedPath as IWalkPathWithEndpoints;\n        pathRef.endPoints = endPoints;\n\n        const valueId = this.pointMap.insertValue(pathRef);\n\n        for (let i = 2; i--;) {\n          this.pointMap.insertValueIdAtPoint(valueId, endPoints[i]);\n        }\n      }\n    };\n\n    model.walk(this.modelContext, walkOptions);\n\n    if (this.options.pointMatchingDistance) {\n      this.pointMap.mergePoints(this.options.pointMatchingDistance);\n    }\n  }\n\n  public findDeadEnds() {\n    let i = 0;\n\n    this.pointMap.forEachPoint((p: IPoint, values: IWalkPathWithEndpoints[], pointId: number, el: IPointGraphIndexElement) => {\n      this.ordinals[pointId] = i++;\n      this.list.push(el);\n    });\n\n    i = 0;\n    while (i < this.list.length) {\n      const el = this.list[i];\n      if (el.valueIds.length === 1) {\n        this.removePath(el, el.valueIds[0], i);\n      } else if (this.options.keep && el.valueIds.length % 2) {\n        el.valueIds.forEach(valueId => {\n          const value = this.pointMap.values[valueId];\n          if (!this.options.keep(value)) {\n            this.removePath(el, valueId, i);\n          }\n        });\n      }\n      i++;\n    }\n\n    return this.removed;\n  }\n\n  private removePath(el: IPointGraphIndexElement, valueId: number, current: number) {\n    const value = this.pointMap.values[valueId];\n    const otherPointId = this.getOtherPointId(value.endPoints, el.pointId);\n    const otherElement = this.pointMap.index[otherPointId];\n\n    this.removed.push(value);\n    this.removeValue(el, valueId);\n    this.removeValue(otherElement, valueId);\n\n    if (otherElement.valueIds.length > 0) {\n      this.appendQueue(otherElement, current);\n    }\n  }\n\n  private removeValue(el: IPointGraphIndexElement, valueId: number) {\n    const pos = el.valueIds.indexOf(valueId);\n    if (pos >= 0) {\n      el.valueIds.splice(pos, 1);\n    }\n  }\n\n  private appendQueue(el: IPointGraphIndexElement, current: number) {\n    const otherOrdinal = this.ordinals[el.pointId];\n    if (otherOrdinal < current) {\n      this.list[otherOrdinal] = null as any;\n      this.list.push(el);\n      this.ordinals[el.pointId] = this.list.length;\n    }\n  }\n\n  private getOtherPointId(endPoints: IPoint[], pointId: number) {\n    for (let i = 0; i < endPoints.length; i++) {\n      const id = this.pointMap.getIdOfPoint(endPoints[i]);\n      if (pointId !== id) {\n        return id;\n      }\n    }\n    return -1;\n  }\n}\n\n/**\n * Remove paths from a model which have endpoints that do not connect to other paths.\n *\n * @param modelContext The model to search for dead ends.\n * @param pointMatchingDistance Optional max distance to consider two points as the same.\n * @param keep Optional callback function (which should return a boolean) to decide if a dead end path should be kept instead.\n * @param trackDeleted Optional callback function which will log discarded paths and the reason they were discarded.\n * @returns The input model (for cascading).\n */\nexport function removeDeadEnds(\n  modelContext: IModel,\n  pointMatchingDistance?: number,\n  keep?: IWalkPathBooleanCallback,\n  trackDeleted?: (wp: IWalkPath, reason: string) => void\n) {\n  const options: IDeadEndFinderOptions = {\n    pointMatchingDistance: pointMatchingDistance || .005,\n    keep\n  };\n\n  const deadEndFinder = new DeadEndFinder(modelContext, options);\n\n  const removed = deadEndFinder.findDeadEnds();\n\n  //do not leave an empty model\n  if (removed.length < deadEndFinder.pointMap.values.length) {\n    removed.forEach(wp => {\n      trackDeleted && trackDeleted(wp, 'dead end');\n      delete wp.modelContext.paths[wp.pathId];\n    });\n  }\n\n  return modelContext;\n}\n\n","import type { IModel, IPath, IPoint, IPathLine, IPathCircle, IPathArc, ICaption } from './schema.js';\nimport {\n  extendObject,\n  isModel,\n  pathType,\n  round,\n  unitType,\n  type IWalkPath,\n  type IFindChainsOptions,\n  type IWalkOptions,\n  type IChain,\n  type IChainCallback,\n  type IPointMatchOptions\n} from './maker.js';\nimport { tryGetModelUnits, colors, type IExportOptions } from './exporter.js';\nimport * as point from './point.js';\nimport * as angle from './angle.js';\nimport * as paths from './paths.js';\nimport * as model from './model.js';\nimport * as measure from './measure.js';\n\nexport function toDXF(modelToExport: IModel, options?: IDXFRenderOptions): string;\nexport function toDXF(pathsToExport: IPath[], options?: IDXFRenderOptions): string;\nexport function toDXF(pathToExport: IPath, options?: IDXFRenderOptions): string;\n\n    /**\n     * Renders an item in AutoDesk DFX file format.\n     *\n     * @param itemToExport Item to render: may be a path, an array of paths, or a model object.\n     * @param options Rendering options object.\n     * @param options.units String of the unit system. May be omitted. See makerjs.unitType for possible values.\n     * @returns String of DXF content.\n     */\nexport function toDXF(itemToExport: any, options: IDXFRenderOptions = {}): string {\n\n        //DXF format documentation:\n        //http://images.autodesk.com/adsk/files/acad_dxf0.pdf\n\n        var opts: IDXFRenderOptions = {\n            fontSize: 9\n        };\n        var layerIds: string[] = [];\n\n        const doc: DxfParser.DXFDocument = {\n            entities: [],\n            header: {},\n            tables: {}\n        };\n\n        extendObject(opts, options);\n\n        if (isModel(itemToExport)) {\n            var modelToExport = itemToExport as IModel;\n            if (modelToExport.exporterOptions) {\n                extendObject(opts, modelToExport.exporterOptions['toDXF']);\n            }\n        }\n\n        function colorLayerOptions(layer: string): IDXFLayerOptions {\n            if (opts.layerOptions && opts.layerOptions[layer]) return opts.layerOptions[layer];\n\n            if (layer in colors) {\n                return {\n                    color: colors[layer]\n                };\n            }\n        }\n\n        function defaultLayer(pathContext: IPath, parentLayer: string) {\n            var layerId = (pathContext && pathContext.layer) || parentLayer || '0';\n            if (layerIds.indexOf(layerId) < 0) {\n                layerIds.push(layerId);\n            }\n            return layerId;\n        }\n\n        var map: { [type: string]: (pathValue: IPath, offset: IPoint, layer: string) => DxfParser.Entity; } = {};\n\n        map[pathType.Line] = function (line: IPathLine, offset: IPoint, layer: string) {\n            const lineEntity: DxfParser.EntityLINE = {\n                type: \"LINE\",\n                layer: defaultLayer(line, layer),\n                vertices: [\n                    {\n                        x: round(line.origin[0] + offset[0], opts.accuracy),\n                        y: round(line.origin[1] + offset[1], opts.accuracy)\n                    },\n                    {\n                        x: round(line.end[0] + offset[0], opts.accuracy),\n                        y: round(line.end[1] + offset[1], opts.accuracy)\n                    }\n                ]\n            };\n            return lineEntity;\n        };\n\n        map[pathType.Circle] = function (circle: IPathCircle, offset: IPoint, layer: string) {\n            const circleEntity: DxfParser.EntityCIRCLE = {\n                type: \"CIRCLE\",\n                layer: defaultLayer(circle, layer),\n                center: {\n                    x: round(circle.origin[0] + offset[0], opts.accuracy),\n                    y: round(circle.origin[1] + offset[1], opts.accuracy),\n                },\n                radius: round(circle.radius, opts.accuracy)\n            };\n            return circleEntity;\n        };\n\n        map[pathType.Arc] = function (arc: IPathArc, offset: IPoint, layer: string) {\n            const arcEntity: DxfParser.EntityARC = {\n                type: \"ARC\",\n                layer: defaultLayer(arc, layer),\n                center: {\n                    x: round(arc.origin[0] + offset[0], opts.accuracy),\n                    y: round(arc.origin[1] + offset[1], opts.accuracy)\n                },\n                radius: round(arc.radius, opts.accuracy),\n                startAngle: round(arc.startAngle, opts.accuracy),\n                endAngle: round(arc.endAngle, opts.accuracy)\n            };\n            return arcEntity;\n        };\n\n        //TODO - handle scenario if any bezier seeds get passed\n        //map[pathType.BezierSeed]\n\n        function appendVertex(v: IPoint, layer: string, bulge?: number) {\n            const vertex: DxfParser.EntityVERTEX = {\n                type: \"VERTEX\",\n                layer: defaultLayer(null, layer),\n                x: round(v[0], opts.accuracy),\n                y: round(v[1], opts.accuracy),\n                bulge\n            };\n            return vertex;\n        }\n\n        function polyline(c: IChainOnLayer) {\n            const polylineEntity: DxfParser.EntityPOLYLINE = {\n                type: \"POLYLINE\",\n                layer: defaultLayer(null, c.layer),\n                shape: c.chain.endless,\n                vertices: []\n            };\n\n            c.chain.links.forEach((link, i) => {\n                let bulge: number;\n                if (link.walkedPath.pathContext.type === pathType.Arc) {\n                    const arc = link.walkedPath.pathContext as IPathArc;\n                    bulge = round(Math.tan(angle.toRadians(angle.ofArcSpan(arc)) / 4), opts.accuracy);\n                    if (link.reversed) {\n                        bulge *= -1;\n                    }\n                }\n                const vertex = link.endPoints[link.reversed ? 1 : 0];\n                polylineEntity.vertices.push(appendVertex(vertex, c.layer, bulge));\n            });\n\n            if (!c.chain.endless) {\n                const lastLink = c.chain.links[c.chain.links.length - 1];\n                const endPoint = lastLink.endPoints[lastLink.reversed ? 0 : 1];\n                polylineEntity.vertices.push(appendVertex(endPoint, c.layer));\n            }\n\n            return polylineEntity;\n        }\n\n        function text(caption: ICaption & { layer?: string }) {\n            const layerId = defaultLayer(null, caption.layer);\n            const layerOptions = colorLayerOptions(layerId);\n            const center = point.middle(caption.anchor);\n            const textEntity: DxfParser.EntityTEXT = {\n                type: \"TEXT\",\n                startPoint: appendVertex(center, null),\n                endPoint: appendVertex(center, null),\n                layer: layerId,\n                textHeight: (layerOptions && layerOptions.fontSize) || opts.fontSize,\n                text: caption.text,\n                halign: 4, // Middle\n                valign: 0, // Baseline\n                rotation: angle.ofPointInDegrees(caption.anchor.origin, caption.anchor.end)\n            };\n            return textEntity;\n        }\n\n        function layerOut(layerId: string, layerColor: number) {\n            const layerEntity: DxfParser.Layer = {\n                name: layerId,\n                color: layerColor\n            };\n            return layerEntity;\n        }\n\n        function lineTypesOut() {\n            const lineStyleTable: DxfParser.TableLTYPE =\n            {\n                lineTypes: {\n                    \"CONTINUOUS\": {\n                        name: \"CONTINUOUS\",\n                        description: \"______\",\n                        patternLength: 0\n                    }\n                }\n            };\n            const tableName: DxfParser.TableNames = 'lineType';\n            doc.tables[tableName] = lineStyleTable;\n        }\n\n        function layersOut() {\n            const layerTable: DxfParser.TableLAYER = {\n                layers: {}\n            }\n            layerIds.forEach(layerId => {\n                var layerOptions = colorLayerOptions(layerId);\n                if (layerOptions) {\n                    layerTable.layers[layerId] = layerOut(layerId, layerOptions.color);\n                }\n            });\n            const tableName: DxfParser.TableNames = 'layer';\n            doc.tables[tableName] = layerTable;\n        }\n\n        function header() {\n            if (opts.units) {\n                var units = dxfUnit[opts.units];\n                doc.header[\"$INSUNITS\"] = units;\n            }\n        }\n\n        function entities(walkedPaths: IWalkPath[], chains: IChainOnLayer[], captions: (ICaption & { layer?: string })[]) {\n            const entityArray = doc.entities;\n\n            entityArray.push.apply(entityArray, chains.map(polyline));\n            walkedPaths.forEach((walkedPath: IWalkPath) => {\n                var fn = map[walkedPath.pathContext.type];\n                if (fn) {\n                    const entity = fn(walkedPath.pathContext, walkedPath.offset, walkedPath.layer);\n                    entityArray.push(entity);\n                }\n            });\n            entityArray.push.apply(entityArray, captions.map(text));\n        }\n\n        //fixup options\n\n        if (!opts.units) {\n            var units = tryGetModelUnits(itemToExport);\n            if (units) {\n                opts.units = units;\n            }\n        }\n\n        //also pass back to options parameter\n        extendObject(options, opts);\n\n        //begin dxf output\n\n        const chainsOnLayers: IChainOnLayer[] = [];\n        const walkedPaths: IWalkPath[] = [];\n        if (opts.usePOLYLINE) {\n            const cb: IChainCallback = function (chains: IChain[], loose: IWalkPath[], layer: string) {\n                chains.forEach(c => {\n                    if (c.endless && c.links.length === 1 && c.links[0].walkedPath.pathContext.type === pathType.Circle) {\n                        //don't treat circles as lwpolylines\n                        walkedPaths.push(c.links[0].walkedPath);\n                        return;\n                    }\n                    const chainOnLayer: IChainOnLayer = { chain: c, layer };\n                    chainsOnLayers.push(chainOnLayer);\n                });\n                walkedPaths.push.apply(walkedPaths, loose);\n            }\n            model.findChains(modelToExport, cb, { byLayers: true, pointMatchingDistance: opts.pointMatchingDistance });\n        } else {\n            var walkOptions: IWalkOptions = {\n                onPath: (walkedPath: IWalkPath) => {\n                    walkedPaths.push(walkedPath);\n                }\n            };\n            model.walk(modelToExport, walkOptions);\n        }\n        entities(walkedPaths, chainsOnLayers, model.getAllCaptionsOffset(modelToExport));\n\n        header();\n\n        lineTypesOut();\n        layersOut();\n\n        return outputDocument(doc);\n    }\n\n    /**\n     * @private\n     */\n    function outputDocument(doc: DxfParser.DXFDocument) {\n\n        const dxf: (string | number)[] = [];\n        function append(...values: (string | number)[]) {\n            dxf.push.apply(dxf, values);\n        }\n\n        var map: { [entityType: string]: (entity: DxfParser.Entity) => void; } = {};\n\n        map[\"LINE\"] = function (line: DxfParser.EntityLINE) {\n            append(\"0\", \"LINE\",\n                \"8\",\n                line.layer,\n                \"10\",\n                line.vertices[0].x,\n                \"20\",\n                line.vertices[0].y,\n                \"11\",\n                line.vertices[1].x,\n                \"21\",\n                line.vertices[1].y\n            );\n        };\n\n        map[\"CIRCLE\"] = function (circle: DxfParser.EntityCIRCLE) {\n            append(\"0\", \"CIRCLE\",\n                \"8\",\n                circle.layer,\n                \"10\",\n                circle.center.x,\n                \"20\",\n                circle.center.y,\n                \"40\",\n                circle.radius\n            );\n        };\n\n        map[\"ARC\"] = function (arc: DxfParser.EntityARC) {\n            append(\"0\", \"ARC\",\n                \"8\",\n                arc.layer,\n                \"10\",\n                arc.center.x,\n                \"20\",\n                arc.center.y,\n                \"40\",\n                arc.radius,\n                \"50\",\n                arc.startAngle,\n                \"51\",\n                arc.endAngle\n            );\n        };\n\n        //TODO - handle scenario if any bezier seeds get passed\n        //map[pathType.BezierSeed]\n\n        map[\"VERTEX\"] = function (vertex: DxfParser.EntityVERTEX) {\n            append(\"0\", \"VERTEX\",\n                \"8\",\n                vertex.layer,\n                \"10\",\n                vertex.x,\n                \"20\",\n                vertex.y\n            );\n\n            if (vertex.bulge !== undefined) {\n                append(\"42\", vertex.bulge);\n            }\n        }\n\n        map[\"POLYLINE\"] = function (polyline: DxfParser.EntityPOLYLINE) {\n            append(\"0\", \"POLYLINE\",\n                \"8\",\n                polyline.layer,\n                \"66\",\n                1,\n                \"70\",\n                polyline.shape ? 1 : 0\n            );\n\n            polyline.vertices.forEach(vertex => map[\"VERTEX\"](vertex));\n\n            append(\"0\", \"SEQEND\");\n        }\n\n        map[\"TEXT\"] = function (text: DxfParser.EntityTEXT) {\n            append(\"0\", \"TEXT\",\n                \"10\",\n                text.startPoint.x,\n                \"20\",\n                text.startPoint.y,\n                \"11\",\n                text.endPoint.x,\n                \"21\",\n                text.endPoint.y,\n                \"40\",\n                text.textHeight,\n                \"1\",\n                text.text,\n                \"50\",\n                text.rotation,\n                \"8\",\n                text.layer,\n                \"72\",\n                text.halign,\n                \"73\",\n                text.valign\n            );\n        }\n\n        function section(sectionFn: () => void) {\n            append(\"0\", \"SECTION\");\n\n            sectionFn();\n\n            append(\"0\", \"ENDSEC\");\n        }\n\n        function table(fn: Function) {\n            append(\"0\", \"TABLE\");\n            fn();\n            append(\"0\", \"ENDTAB\");\n        }\n\n        function tables() {\n            append(\"2\", \"TABLES\");\n\n            table(lineTypesOut);\n            table(layersOut);\n        }\n\n        function layerOut(layer: DxfParser.Layer) {\n            append(\"0\", \"LAYER\",\n                \"2\",\n                layer.name,\n                \"70\",\n                \"0\",\n                \"62\",\n                layer.color,\n                \"6\",\n                \"CONTINUOUS\"\n            );\n        }\n\n        function lineTypeOut(lineType: DxfParser.LineType) {\n            append(\"0\", \"LTYPE\",\n                \"72\", //72 Alignment code; value is always 65, the ASCII code for A\n                \"65\",\n                \"70\",\n                \"64\",\n                \"2\",\n                lineType.name,\n                \"3\",\n                lineType.description,\n                \"73\",\n                \"0\",\n                \"40\",\n                lineType.patternLength\n            );\n        }\n\n        function lineTypesOut() {\n            const lineTypeTableName: DxfParser.TableNames = 'lineType';\n            const lineTypeTable = doc.tables[lineTypeTableName] as DxfParser.TableLTYPE;\n\n            append(\"2\", \"LTYPE\");\n\n            for (let lineTypeId in lineTypeTable.lineTypes) {\n                let lineType = lineTypeTable.lineTypes[lineTypeId];\n                lineTypeOut(lineType);\n            }\n        }\n\n        function layersOut() {\n            const layerTableName: DxfParser.TableNames = 'layer';\n            const layerTable = doc.tables[layerTableName] as DxfParser.TableLAYER;\n\n            append(\"2\", \"LAYER\");\n\n            for (let layerId in layerTable.layers) {\n                let layer = layerTable.layers[layerId];\n                layerOut(layer);\n            }\n        }\n\n        function header() {\n            append(\"2\", \"HEADER\");\n\n            for (let key in doc.header) {\n                let value = doc.header[key];\n                append(\"9\", key, \"70\", value);\n            }\n        }\n\n        function entities(entityArray: DxfParser.Entity[]) {\n            append(\"2\", \"ENTITIES\");\n\n            entityArray.forEach(entity => {\n                const fn = map[entity.type];\n                if (fn) {\n                    fn(entity);\n                }\n            });\n        }\n\n        //begin dxf output\n\n        section(header);\n        section(tables);\n        section(() => entities(doc.entities));\n\n        append(\"0\", \"EOF\");\n\n        return dxf.join('\\n');\n    }\n\n    /**\n     * @private\n     */\n    var dxfUnit: { [unitType: string]: number } = {};\n\n    //DXF format documentation:\n    //http://images.autodesk.com/adsk/files/acad_dxf0.pdf\n    //Default drawing units for AutoCAD DesignCenter blocks:\n    //0 = Unitless; 1 = Inches; 2 = Feet; 3 = Miles; 4 = Millimeters; 5 = Centimeters; 6 = Meters; 7 = Kilometers; 8 = Microinches;\n\n    dxfUnit[''] = 0;\n    dxfUnit[unitType.Inch] = 1;\n    dxfUnit[unitType.Foot] = 2;\n    dxfUnit[unitType.Millimeter] = 4;\n    dxfUnit[unitType.Centimeter] = 5;\n    dxfUnit[unitType.Meter] = 6;\n\n    /**\n     * DXF layer options.\n     */\nexport interface IDXFLayerOptions {\n\n        /**\n         * DXF layer color.\n         */\n        color: number\n\n        /**\n         * Text size for TEXT entities.\n         */\n        fontSize?: number;\n    }\n\n    /**\n     * DXF rendering options.\n     */\nexport interface IDXFRenderOptions extends IExportOptions, IPointMatchOptions {\n\n        /**\n         * Text size for TEXT entities.\n         */\n        fontSize?: number;\n\n        /**\n         * DXF options per layer.\n         */\n        layerOptions?: { [layerId: string]: IDXFLayerOptions };\n\n        /**\n         * Flag to use POLYLINE\n         */\n        usePOLYLINE?: boolean;\n    }\n\n    /**\n     * @private\n     */\ninterface IChainOnLayer {\n        chain: IChain;\n        layer: string;\n    }\n\n","import type { IModel, IPoint, IPath, IPathCircle, IPathLine } from './schema.js';\nimport type { IChain, IWalkPath } from './maker.js';\nimport { extendObject, cloneObject, unitType, pathType } from './maker.js';\nimport * as units from './units.js';\nimport * as model from './model.js';\nimport * as chain from './chain.js';\nimport * as measure from './measure.js';\nimport * as point from './point.js';\nimport * as path from './path.js';\nimport * as angle from './angle.js';\nimport { pathToSVGPathData, chainToSVGPathData } from './svg-helpers.js';\nimport type { IExportOptions } from './exporter.js';\n\n/**\n * PDF rendering options.\n */\nexport interface IPDFRenderOptions extends IExportOptions {\n  /**\n   * Font name, see list at https://github.com/foliojs/pdfkit/blob/master/docs/text.coffee.md#fonts\n   */\n  fontName?: string;\n\n  /**\n   * Font size.\n   */\n  fontSize?: number;\n\n  /**\n   * Rendered reference origin.\n   */\n  origin?: IPoint;\n\n  /**\n   * SVG color of the rendered paths.\n   */\n  stroke?: string;\n}\n\n/**\n * Injects drawing into a PDFKit document.\n *\n * @param doc PDFKit.PDFDocument object. See https://pdfkit.org/\n * @param modelToExport Model object to export.\n * @param options Export options object.\n * @returns String of PDF file contents.\n */\nexport function toPDF(doc: PDFKit.PDFDocument, modelToExport: IModel, options?: IPDFRenderOptions) {\n  if (!modelToExport) return;\n\n  // fixup options\n  const opts: IPDFRenderOptions = {\n    fontName: 'Courier',\n    fontSize: 9,\n    origin: [0, 0],\n    stroke: '#000',\n    ...options\n  };\n\n  // try to get the unit system from the itemToExport\n  let scale = 1;\n  const exportUnits = opts.units || modelToExport.units;\n  if (exportUnits) {\n    // convert to inch\n    scale = units.conversionScale(exportUnits, unitType.Inch);\n  } else {\n    // assume pixels, convert to inch\n    scale = 1 / 100;\n  }\n\n  // from inch to PDF PPI\n  scale *= 72;\n\n  // TODO scale each element without a whole clone\n  const scaledModel = model.scale(cloneObject(modelToExport), scale);\n\n  const size = measure.modelExtents(scaledModel);\n  if (!size) return;\n\n  const left = -size.low[0];\n  let offset: IPoint = [left, size.high[1]];\n\n  offset = point.add(offset, opts.origin!);\n\n  chain.findChains(\n    scaledModel,\n    function (chains: IChain[], loose: IWalkPath[], layer: string) {\n      function single(walkedPath: IWalkPath) {\n        const pathData = pathToSVGPathData(walkedPath.pathContext, walkedPath.offset, offset);\n        doc.path(pathData).stroke(opts.stroke!);\n      }\n\n      chains.map(function (chain: IChain) {\n        if (chain.links.length > 1) {\n          const pathData = chainToSVGPathData(chain, offset);\n          doc.path(pathData).stroke(opts.stroke!);\n        } else {\n          const walkedPath = chain.links[0].walkedPath;\n          if (walkedPath.pathContext.type === pathType.Circle) {\n            let fixedPath: IPath = walkedPath.pathContext;\n            path.moveTemporary([walkedPath.pathContext], [walkedPath.offset], function () {\n              fixedPath = path.mirror(walkedPath.pathContext, false, true);\n            });\n            path.moveRelative(fixedPath, offset);\n\n            // TODO use only chainToSVGPathData instead of circle, so that we can use fill\n            doc\n              .circle(fixedPath.origin[0], fixedPath.origin[1], (walkedPath.pathContext as IPathCircle).radius)\n              .stroke(opts.stroke!);\n          } else {\n            single(walkedPath);\n          }\n        }\n      });\n\n      loose.map(single);\n    },\n    { byLayers: false }\n  );\n\n  doc.font(opts.fontName!).fontSize(opts.fontSize!);\n\n  model.getAllCaptionsOffset(scaledModel).forEach(caption => {\n    // measure the angle of the line, prior to mirroring\n    const a = angle.ofLineInDegrees(caption.anchor);\n\n    // mirror into pdf y coords\n    const anchor = path.mirror(caption.anchor, false, true) as IPathLine;\n\n    // move mirrored line by document offset\n    path.moveRelative(anchor, offset);\n\n    // measure center point of text\n    const text = caption.text;\n    const textCenter: IPoint = [doc.widthOfString(text) / 2, doc.heightOfString(text) / 2];\n\n    // get center point on line\n    const center = point.middle(anchor) as number[];\n    const textOffset = point.subtract(center, textCenter);\n\n    doc.rotate(-a, { origin: center });\n    doc.text(text, textOffset[0], textOffset[1]);\n    doc.rotate(a, { origin: center });\n  });\n}\n","import type { IModel, IPoint, IPath, IPathCircle, IPathLine, IPathArc } from './schema.js';\nimport type { IChain, IChainLink, IChainsMap, IFindChainsOptions, IPointMatchOptions, IFindLoopsOptions } from './maker.js';\nimport { extendObject, isNumber, round, pathType } from './maker.js';\nimport * as point from './point.js';\nimport * as angle from './angle.js';\nimport * as paths from './paths.js';\nimport * as measure from './measure.js';\nimport * as chain from './chain.js';\nimport * as model from './model.js';\nimport type { IExportOptions } from './exporter.js';\nimport type * as jscad from '../types/jscad.js';\n\nexport interface IStatusCallback {\n  (status: { progress: number }): void;\n}\n\ntype ChainHandler = (pathValue: IPath, link: IChainLink) => void;\n\nfunction wrap(prefix: string, content: string, condition?: any): string {\n  if (!prefix) return content;\n  if (condition) {\n    return prefix + '(' + content + ')';\n  }\n  return prefix + content;\n}\n\nfunction facetSizeToResolution(arcOrCircle: IPathCircle, facetSize?: number): number | undefined {\n  if (!facetSize) return undefined;\n\n  const circle = new paths.Circle([0, 0], arcOrCircle.radius);\n  const length = measure.pathLength(circle);\n  if (!length) return undefined;\n\n  return Math.ceil(length / facetSize);\n}\n\nfunction chainToJscadScript(chainContext: IChain, facetSize?: number, accuracy?: number): string {\n  let head = '';\n  let tail = '';\n  let first = true;\n  let exit = false;\n  let reverseTail = false;\n\n  const beginMap: Partial<Record<string, ChainHandler>> = {};\n\n  beginMap[pathType.Circle] = function (circlePath: IPath, link: IChainLink) {\n    const circle = circlePath as IPathCircle;\n    const circleOptions: jscad.CSG.ICircleOptions = {\n      center: point.rounded(point.add(circle.origin, link.walkedPath.offset), accuracy) as number[],\n      radius: round(circle.radius, accuracy),\n      resolution: facetSizeToResolution(circle, facetSize)\n    };\n    head = wrap('CAG.circle', JSON.stringify(circleOptions), true);\n    exit = true;\n  };\n\n  beginMap[pathType.Line] = function (linePath: IPath, link: IChainLink) {\n    let points = link.endPoints.map(p => point.rounded(p, accuracy));\n    if (link.reversed) {\n      points.reverse();\n    }\n    head = wrap('new CSG.Path2D', JSON.stringify(points), true);\n  };\n\n  beginMap[pathType.Arc] = function (arcPath: IPath, link: IChainLink) {\n    const arc = arcPath as IPathArc;\n    const endAngle = angle.ofArcEnd(arc);\n    if (link.reversed) {\n      reverseTail = true;\n    }\n    const arcOptions: jscad.CSG.IArcOptions = {\n      center: point.rounded(point.add(arc.origin, link.walkedPath.offset), accuracy) as number[],\n      radius: round(arc.radius, accuracy),\n      startangle: round(arc.startAngle, accuracy),\n      endangle: round(endAngle, accuracy),\n      resolution: facetSizeToResolution(arc, facetSize)\n    };\n    head = wrap('new CSG.Path2D.arc', JSON.stringify(arcOptions), true);\n  };\n\n  const appendMap: Partial<Record<string, ChainHandler>> = {};\n\n  appendMap[pathType.Line] = function (_linePath: IPath, link: IChainLink) {\n    const reverse = reverseTail != link.reversed;\n    const endPoint = point.rounded(link.endPoints[reverse ? 0 : 1], accuracy);\n    append(wrap('.appendPoint', JSON.stringify(endPoint), true));\n  };\n\n  appendMap[pathType.Arc] = function (arcPath: IPath, link: IChainLink) {\n    const arc = arcPath as IPathArc;\n    const reverse = reverseTail != link.reversed;\n    const endAngle = angle.ofArcEnd(arc);\n    const arcOptions: jscad.CSG.IEllpiticalArcOptions = {\n      radius: round(arc.radius, accuracy),\n      clockwise: reverse,\n      large: Math.abs(endAngle - arc.startAngle) > 180,\n      resolution: facetSizeToResolution(arc, facetSize)\n    };\n    const endPoint = point.rounded(link.endPoints[reverse ? 0 : 1], accuracy);\n    append(wrap('.appendArc', JSON.stringify(endPoint) + ',' + JSON.stringify(arcOptions), true));\n  };\n\n  function append(s: string) {\n    if (reverseTail) {\n      tail = s + tail;\n    } else {\n      tail += s;\n    }\n  }\n\n  for (let i = 0; i < chainContext.links.length; i++) {\n    const link = chainContext.links[i];\n    const pathContext = link.walkedPath.pathContext;\n\n    const fn = (first ? beginMap[pathContext.type] : appendMap[pathContext.type]) as ChainHandler | undefined;\n\n    if (fn) {\n      fn(pathContext, link);\n    }\n\n    if (exit) {\n      return head;\n    }\n\n    first = false;\n  }\n\n  return head + tail + '.close().innerToCAG()';\n}\n\ninterface IAdd<T> {\n  cag: T;\n  subtracts: T[][];\n}\n\ninterface IOperate<T> {\n  (a: T, b: T): T;\n}\n\nfunction makePhasedCallback(originalCb: IStatusCallback | undefined, phaseStart: number, phaseSpan: number): IStatusCallback | undefined {\n  if (!originalCb) return undefined;\n  return function statusCallback(status) {\n    originalCb({ progress: phaseStart + (status.progress * phaseSpan) / 100 });\n  };\n}\n\nfunction convertChainsTo2D<T>(\n  convertToT: { (c: IChain, maxArcFacet: number): T },\n  union: IOperate<T>,\n  subtraction: IOperate<T>,\n  modelToExport: IModel,\n  jsCadCagOptions: IJscadCagOptions = {}\n) {\n  const adds: { [layerId: string]: IAdd<T>[] } = {};\n  const status = { total: 0, complete: 0 };\n\n  function unionize(phaseStart: number, phaseSpan: number, arr: T[]) {\n    let result = arr[0];\n    for (let i = 1; i < arr.length; i += 1) {\n      result = union(result, arr[i]);\n    }\n    status.complete++;\n\n    jsCadCagOptions.statusCallback &&\n      jsCadCagOptions.statusCallback({ progress: phaseStart + (phaseSpan * status.complete) / status.total });\n\n    return result;\n  }\n\n  function subtractChains(layerId: string, cs: IChain[]) {\n    const subtracts: T[] = [];\n    cs.forEach(c => {\n      if (!c.endless) return;\n      if (c.contains) {\n        addChains(layerId, c.contains);\n      }\n      status.total++;\n      subtracts.unshift(convertToT(c, jsCadCagOptions.maxArcFacet!));\n    });\n    return subtracts;\n  }\n\n  function addChains(layerId: string, cs: IChain[]) {\n    cs.forEach(c => {\n      if (!c.endless) return;\n      const add: IAdd<T> = { cag: convertToT(c, jsCadCagOptions.maxArcFacet!), subtracts: [] };\n      if (c.contains) {\n        const subtracts = subtractChains(layerId, c.contains);\n        if (subtracts.length > 0) {\n          add.subtracts.push(subtracts);\n        }\n      }\n      status.total++;\n      if (!(layerId in adds)) {\n        adds[layerId] = [];\n      }\n      adds[layerId].unshift(add);\n    });\n  }\n\n  const options: IFindChainsOptions = {\n    pointMatchingDistance: jsCadCagOptions.pointMatchingDistance,\n    byLayers: jsCadCagOptions.byLayers,\n    contain: true\n  };\n\n  jsCadCagOptions.statusCallback && jsCadCagOptions.statusCallback({ progress: 25 });\n\n  const chainsResult = chain.findChains(modelToExport, options);\n  if (!chainsResult) {\n    jsCadCagOptions.statusCallback && jsCadCagOptions.statusCallback({ progress: 100 });\n    throw new Error('No closed geometries found.');\n  }\n\n  if (Array.isArray(chainsResult)) {\n    addChains('', chainsResult);\n  } else {\n    const chainsByLayer = chainsResult as IChainsMap;\n    Object.keys(chainsByLayer).forEach(layerId => {\n      addChains(layerId, chainsByLayer[layerId] ?? []);\n    });\n  }\n\n  jsCadCagOptions.statusCallback && jsCadCagOptions.statusCallback({ progress: 50 });\n\n  let closedCount = 0;\n  for (const layerId in adds) {\n    closedCount += adds[layerId].length;\n  }\n  if (closedCount === 0) {\n    jsCadCagOptions.statusCallback && jsCadCagOptions.statusCallback({ progress: 100 });\n    throw new Error('No closed geometries found.');\n  }\n\n  const resultMap: { [layerId: string]: T } = {};\n\n  for (const layerId in adds) {\n    const flatAdds = adds[layerId].map(add => {\n      let result = add.cag;\n      add.subtracts.forEach(subtract => {\n        const union = unionize(50, 50, subtract);\n        result = subtraction(result, union);\n      });\n      return result;\n    });\n    resultMap[layerId] = unionize(50, 50, flatAdds);\n  }\n\n  jsCadCagOptions.statusCallback && jsCadCagOptions.statusCallback({ progress: 100 });\n\n  return options.byLayers ? resultMap : resultMap[''];\n}\n\n/**\n * Converts a model to a @jscad/csg CAG object - 2D to 2D. See https://en.wikibooks.org/wiki/OpenJSCAD_User_Guide#2D_Paths\n *\n * Example:\n * ```\n * //First, use npm install @jscad/csg from the command line in your jscad project\n * //Create a CAG instance from a model.\n * var { CAG } = require('@jscad/csg');\n * var model = new makerjs.models.Ellipse(70, 40);\n * var cag = makerjs.exporter.toJscadCAG(CAG, model, {maxArcFacet: 1});\n * ```\n *\n * @param jscadCAG @jscad/csg CAG engine, see https://www.npmjs.com/package/@jscad/csg\n * @param modelToExport Model object to export.\n * @param options Optional options object.\n * @param options.byLayers Optional flag to separate chains by layers.\n * @param options.pointMatchingDistance Optional max distance to consider two points as the same.\n * @param options.maxArcFacet The maximum length between points on an arc or circle.\n * @param options.statusCallback Optional callback function to get the percentage complete.\n * @returns jscad CAG object in 2D, or a map (keyed by layer id) of jscad CAG objects - if options.byLayers is true.\n */\nexport function toJscadCAG(\n  jscadCAG: typeof jscad.CAG,\n  modelToExport: IModel,\n  jsCadCagOptions?: IJscadCagOptions\n): jscad.CAG | { [layerId: string]: jscad.CAG } {\n  function chainToJscadCag(c: IChain, maxArcFacet: number) {\n    const keyPoints = chain.toKeyPoints(c, maxArcFacet).map(pt => [pt[0], pt[1]] as number[]);\n    if (keyPoints.length > 0) {\n      keyPoints.push([keyPoints[0][0], keyPoints[0][1]]);\n    }\n    return jscadCAG.fromPoints(keyPoints as number[][]);\n  }\n\n  function jscadCagUnion(augend: jscad.CAG, addend: jscad.CAG) {\n    return augend.union(addend);\n  }\n\n  function jscadCagSubtraction(minuend: jscad.CAG, subtrahend: jscad.CAG) {\n    return minuend.subtract(subtrahend);\n  }\n\n  return convertChainsTo2D<jscad.CAG>(chainToJscadCag, jscadCagUnion, jscadCagSubtraction, modelToExport, jsCadCagOptions);\n}\n\nfunction convert2Dto3D<T2D, T3D>(\n  to2D: { (options: IJscadCsgOptions): T2D | { [layerId: string]: T2D } },\n  to3D: { (result2D: T2D, extrude: number, z: number): T3D },\n  union3D: { (a: T3D, b: T3D): T3D },\n  modelToExport: IModel,\n  options: IJscadCsgOptions = {}\n) {\n  const originalCb = options.statusCallback;\n\n  function getDefinedNumber(a: number | undefined, b: number | undefined) {\n    if (isNumber(a)) return a;\n    return b;\n  }\n\n  if (modelToExport.exporterOptions) {\n    extendObject(options, modelToExport.exporterOptions['toJscadCSG']);\n  }\n\n  options.byLayers = options.byLayers || (options.layerOptions && true);\n  options.statusCallback = makePhasedCallback(originalCb, 0, 50);\n\n  const result2D = to2D(options);\n  const csgs: T3D[] = [];\n\n  if (options.byLayers) {\n    const map = result2D as { [layerId: string]: T2D };\n    for (const layerId in map) {\n      if (!Object.prototype.hasOwnProperty.call(map, layerId)) continue;\n      const layerOptions = (options.layerOptions && options.layerOptions[layerId]) || {};\n      const csg = to3D(map[layerId], layerOptions.extrude ?? options.extrude!, getDefinedNumber(layerOptions.z, options.z)!);\n      csgs.push(csg);\n    }\n  } else {\n    const csg = to3D(result2D as T2D, options.extrude!, options.z!);\n    csgs.push(csg);\n  }\n\n  options.statusCallback = makePhasedCallback(originalCb, 50, 100);\n\n  if (csgs.length === 0) {\n    throw new Error('No extrusions generated.');\n  }\n\n  const status = { total: Math.max(csgs.length - 1, 1), complete: 0 };\n\n  let result = csgs[0];\n  for (let i = 1; i < csgs.length; i += 1) {\n    result = union3D(result, csgs[i]);\n    status.complete++;\n    options.statusCallback && options.statusCallback({ progress: status.complete / status.total });\n  }\n\n  return result;\n}\n\n/**\n * Converts a model to a @jscad/csg CSG object - 2D to 3D.\n *\n * Example:\n * ```\n * //First, use npm install @jscad/csg from the command line in your jscad project\n * //Create a CSG instance from a model.\n * var { CAG } = require('@jscad/csg');\n * var model = new makerjs.models.Ellipse(70, 40);\n * var csg = makerjs.exporter.toJscadCSG(CAG, model, {maxArcFacet: 1, extrude: 10});\n * ```\n *\n * @param jscadCAG @jscad/csg CAG engine, see https://www.npmjs.com/package/@jscad/csg\n * @param modelToExport Model object to export.\n * @param options Optional options object.\n * @param options.byLayers Optional flag to separate chains by layers.\n * @param options.pointMatchingDistance Optional max distance to consider two points as the same.\n * @param options.maxArcFacet The maximum length between points on an arc or circle.\n * @param options.statusCallback Optional callback function to get the percentage complete.\n * @param options.extrude Optional default extrusion distance.\n * @param options.layerOptions Optional object map of options per layer, keyed by layer name. Each value for a key is an object with 'extrude' and 'z' properties.\n * @returns jscad CAG object in 2D, or a map (keyed by layer id) of jscad CAG objects - if options.byLayers is true.\n */\nexport function toJscadCSG(jscadCAG: typeof jscad.CAG, modelToExport: IModel, options?: IJscadCsgOptions): jscad.CSG {\n  function to2D(opts: IJscadCsgOptions) {\n    return toJscadCAG(jscadCAG, modelToExport, opts);\n  }\n\n  function to3D(cag: jscad.CAG, extrude: number, z: number) {\n    let csg = cag.extrude({ offset: [0, 0, extrude] });\n    if (z) {\n      csg = csg.translate([0, 0, z]);\n    }\n    return csg;\n  }\n\n  function union3D(augend: jscad.CSG, addend: jscad.CSG) {\n    return augend.union(addend);\n  }\n\n  return convert2Dto3D<jscad.CAG, jscad.CSG>(to2D, to3D, union3D, modelToExport, options);\n}\n\n/**\n * Creates a string of JavaScript code for execution with a Jscad environment.\n *\n * @param modelToExport Model object to export.\n * @param options Export options object.\n * @param options.byLayers Optional flag to separate chains by layers.\n * @param options.pointMatchingDistance Optional max distance to consider two points as the same.\n * @param options.maxArcFacet The maximum length between points on an arc or circle.\n * @param options.statusCallback Optional callback function to get the percentage complete.\n * @param options.extrude Optional default extrusion distance.\n * @param options.layerOptions Optional object map of options per layer, keyed by layer name. Each value for a key is an object with 'extrude' and 'z' properties.\n * @returns String of JavaScript containing a main() function for Jscad.\n */\nexport function toJscadScript(modelToExport: IModel, options: IJscadScriptOptions = {}) {\n  function _chainToJscadScript(c: IChain, maxArcFacet: number) {\n    return wrap('', chainToJscadScript(c, maxArcFacet, options.accuracy));\n  }\n\n  function scriptUnion(augend: string, addend: string) {\n    return augend + `.union(${addend})`;\n  }\n\n  function scriptSubtraction(minuend: string, subtrahend: string) {\n    return minuend + `.subtract(${subtrahend})`;\n  }\n\n  function to2D(opts: IJscadCsgOptions) {\n    return convertChainsTo2D<string>(_chainToJscadScript, scriptUnion, scriptSubtraction, modelToExport, options);\n  }\n\n  function to3D(cag: string, extrude: number, z: number) {\n    let csg = cag + `.extrude({ offset: [0, 0, ${extrude}] })`;\n    if (z) {\n      csg = csg + `.translate([0, 0, ${z}])`;\n    }\n    return csg;\n  }\n\n  function wrapScript(s: string) {\n    return `${nl}${indent}${s}${nl}`;\n  }\n\n  const indent = new Array((options.indent || 0) + 1).join(' ');\n  const nl = options.indent ? '\\n' : '';\n\n  const result = convert2Dto3D<string, string>(to2D, to3D, scriptUnion, modelToExport, options).trim();\n\n  return `function ${options.functionName || 'main'}(){${wrapScript(`return ${result};`)}}${nl}`;\n}\n\n/**\n * Exports a model in STL format - 2D to 3D.\n *\n * @param jscadCAG @jscad/csg CAG engine, see https://www.npmjs.com/package/@jscad/csg\n * @param stlSerializer @jscad/stl-serializer, see https://www.npmjs.com/package/@jscad/stl-serializer\n * @param modelToExport Model object to export.\n * @param options Optional options object.\n * @param options.byLayers Optional flag to separate chains by layers.\n * @param options.pointMatchingDistance Optional max distance to consider two points as the same.\n * @param options.maxArcFacet The maximum length between points on an arc or circle.\n * @param options.statusCallback Optional callback function to get the percentage complete.\n * @param options.extrude Optional default extrusion distance.\n * @param options.layerOptions Optional object map of options per layer, keyed by layer name. Each value for a key is an object with 'extrude' and 'z' properties.\n * @returns String in STL ASCII format.\n */\nexport function toJscadSTL(\n  CAG: typeof jscad.CAG,\n  stlSerializer: jscad.StlSerializer,\n  modelToExport: IModel,\n  options: IJscadCsgOptions = {}\n) {\n  const originalCb = options.statusCallback;\n  options.statusCallback = makePhasedCallback(originalCb, 0, 50);\n  const csg = toJscadCSG(CAG, modelToExport, options);\n  return stlSerializer.serialize(csg, { binary: false, statusCallback: makePhasedCallback(originalCb, 50, 50) });\n}\n\n/**\n * OpenJsCad export options.\n */\nexport interface IOpenJsCadOptions extends IFindLoopsOptions, IExportOptions {\n  /**\n   * Optional depth of 3D extrusion.\n   */\n  extrusion?: number;\n\n  /**\n   * Optional size of curve facets.\n   */\n  facetSize?: number;\n\n  /**\n   * Optional override of function name, default is \"main\".\n   */\n  functionName?: string;\n\n  /**\n   * Optional options applied to specific first-child models by model id.\n   */\n  modelMap?: IOpenJsCadOptionsMap;\n}\n\n/**\n * Map of OpenJsCad export options.\n */\nexport interface IOpenJsCadOptionsMap {\n  [modelId: string]: IOpenJsCadOptions;\n}\n\n/**\n * Jscad CAG export options.\n */\nexport interface IJscadCagOptions extends IExportOptions, IPointMatchOptions {\n  /**\n   * Flag to separate chains by layers.\n   */\n  byLayers?: boolean;\n\n  /**\n   * The maximum length between points on an arc or circle.\n   */\n  maxArcFacet?: number;\n\n  /**\n   * Optional callback to get status during the export.\n   */\n  statusCallback?: IStatusCallback;\n}\n\n/**\n * Jscad CAG extrusion options.\n */\nexport interface IJscadExtrudeOptions {\n  /**\n   * Optional depth of 3D extrusion.\n   */\n  extrude?: number;\n\n  /**\n   * Optional depth of 3D extrusion.\n   */\n  z?: number;\n}\n\n/**\n * Jscad CSG export options.\n */\nexport interface IJscadCsgOptions extends IJscadCagOptions, IJscadExtrudeOptions {\n  /**\n   * SVG options per layer.\n   */\n  layerOptions?: { [layerId: string]: IJscadExtrudeOptions };\n}\n\n/**\n * Jscad Script export options.\n */\nexport interface IJscadScriptOptions extends IJscadCsgOptions {\n  /**\n   * Optional override of function name, default is \"main\".\n   */\n  functionName?: string;\n\n  /**\n   * Optional number of spaces to indent.\n   */\n  indent?: number;\n}\n","// ES Module imports\nimport type { IPoint, IPath, IPathArc, IPathLine, IModel, IModelMap, IPathMap } from './schema.js';\nimport { pathType, isModel, cloneObject } from './maker.js';\nimport type { IChain, IWalkOptions, IWalkModel, IMeasure } from './maker.js';\nimport * as angle from './angle.js';\nimport * as point from './point.js';\nimport * as path from './path.js';\nimport * as paths from './paths.js';\nimport * as model from './model.js';\nimport * as measure from './measure.js';\nimport * as chain from './chain.js';\nimport * as solvers from './solvers.js';\n\n/**\n * @private\n */\ninterface IChildPlacement {\n    childId: string;\n    xRatio: number;\n    origin?: IPoint;\n    angle?: number;\n}\n\n/**\n * @private\n */\nfunction getChildPlacement(parentModel: IModel, baseline: number) {\n\n    //measure everything and cache the results\n    const atlas = new measure.Atlas(parentModel);\n    const measureParent = measure.modelExtents(parentModel, atlas);\n\n    //measure height of the model from the baseline 0\n    const parentTop = measureParent.high[1];\n\n    const cpa: IChildPlacement[] = [];\n    const xMap: { [childId: string]: number } = {};\n\n    const walkOptions: IWalkOptions = {\n        beforeChildWalk: function (context: IWalkModel) {\n            const child = context.childModel;\n\n            //get cached measurement of the child\n            const m = atlas.modelMap[context.routeKey];\n\n            if (!m) return;\n\n            const childMeasure = measure.augment(m);\n\n            //set a new origin at the x-center and y-baseline of the child\n            model.originate(child, [childMeasure.center[0], parentTop * baseline]);\n\n            //get the x-center of the child\n            const x = child.origin[0] - measureParent.low[0];\n            xMap[context.childId] = x;\n\n            //get the x-center of the child as a percentage\n            const xRatio = x / measureParent.width;\n\n            cpa.push({ childId: context.childId, xRatio });\n\n            //do not walk the grandchildren. This is only for immediate children of the parentModel.\n            return false;\n        }\n    };\n\n    model.walk(parentModel, walkOptions);\n\n    cpa.sort((a, b) => a.xRatio - b.xRatio);\n\n    const first = cpa[0];\n    const last = cpa[cpa.length - 1];\n\n    if (cpa.length > 1) {\n        const min = first.xRatio;\n        const max = last.xRatio;\n        const span = max - min;\n\n        cpa.forEach(cp => cp.xRatio = (cp.xRatio - min) / span);\n    }\n\n    return {\n        cpa,\n        firstX: xMap[first.childId],\n        lastX: measureParent.width - xMap[last.childId]\n    };\n}\n\n/**\n * @private\n */\nfunction moveAndRotate(parentModel: IModel, cpa: IChildPlacement[], rotate: boolean) {\n\n    cpa.forEach(cp => {\n        const child = parentModel.models[cp.childId];\n\n        //move the child to the new location\n        child.origin = cp.origin;\n\n        //rotate the child\n        if (rotate) model.rotate(child, cp.angle, cp.origin);\n    });\n}\n\n/**\n * @private\n */\nconst onPathMap: { [pathType: string]: (onPath: IPath, reversed: boolean, cpa: IChildPlacement[]) => void } = {};\n\nonPathMap[pathType.Arc] = function (arc: IPathArc, reversed: boolean, cpa: IChildPlacement[]) {\n    const arcSpan = angle.ofArcSpan(arc);\n    cpa.forEach(p => p.angle = reversed ? arc.endAngle - p.xRatio * arcSpan - 90 : arc.startAngle + p.xRatio * arcSpan + 90);\n};\n\nonPathMap[pathType.Line] = function (line: IPathLine, reversed: boolean, cpa: IChildPlacement[]) {\n    const lineAngle = angle.ofLineInDegrees(line as IPathLine);\n    cpa.forEach(p => p.angle = lineAngle);\n};\n\n/**\n * Layout the children of a model along a path. \n * The x-position of each child will be projected onto the path so that the proportion between children is maintained.\n * Each child will be rotated such that it will be perpendicular to the path at the child's x-center.\n * \n * @param parentModel The model containing children to lay out.\n * @param onPath The path on which to lay out.\n * @param baseline Numeric percentage value of vertical displacement from the path. Default is zero.\n * @param reversed Flag to travel along the path in reverse. Default is false.\n * @param contain Flag to contain the children layout within the length of the path. Default is false.\n * @param rotate Flag to rotate the child to perpendicular. Default is true.\n * @returns The parentModel, for cascading.\n */\nexport function childrenOnPath(parentModel: IModel, onPath: IPath, baseline = 0, reversed = false, contain = false, rotate = true) {\n\n    const result = getChildPlacement(parentModel, baseline);\n    const cpa = result.cpa;\n    let chosenPath = onPath;\n\n    if (contain && cpa.length > 1) {\n        //see if we need to clip\n        const onPathLength = measure.pathLength(onPath);\n\n        if (result.firstX + result.lastX < onPathLength) {\n            chosenPath = path.clone(onPath);\n            path.alterLength(chosenPath, -result.firstX, true);\n            path.alterLength(chosenPath, -result.lastX);\n        }\n    }\n\n    cpa.forEach(p => p.origin = point.middle(chosenPath, reversed ? 1 - p.xRatio : p.xRatio));\n\n    const fn = onPathMap[chosenPath.type];\n    if (fn) {\n        fn(chosenPath, reversed, cpa);\n    }\n\n    moveAndRotate(parentModel, cpa, rotate);\n\n    return parentModel;\n}\n\n/**\n * @private\n */\nfunction miterAngles(points: IPoint[], offsetAngle: number): number[] {\n    const arc = new paths.Arc([0, 0], 0, 0, 0);\n    return points.map((p, i) => {\n        let a: number;\n        if (i === 0) {\n            a = angle.ofPointInDegrees(p, points[i + 1]) + 90;\n        } else if (i === points.length - 1) {\n            a = angle.ofPointInDegrees(points[i - 1], p) + 90;\n        } else {\n            arc.origin = p;\n            arc.startAngle = angle.ofPointInDegrees(p, points[i + 1]);\n            arc.endAngle = angle.ofPointInDegrees(p, points[i - 1]);\n            a = angle.ofArcMiddle(arc);\n        }\n        return a + offsetAngle;\n    });\n}\n\n/**\n * Layout the children of a model along a chain. \n * The x-position of each child will be projected onto the chain so that the proportion between children is maintained.\n * The projected positions of the children will become an array of points that approximate the chain.\n * Each child will be rotated such that it will be mitered according to the vertex angles formed by this series of points.\n * \n * @param parentModel The model containing children to lay out.\n * @param onChain The chain on which to lay out.\n * @param baseline Numeric percentage value of vertical displacement from the chain. Default is zero.\n * @param reversed Flag to travel along the chain in reverse. Default is false.\n * @param contain Flag to contain the children layout within the length of the chain. Default is false.\n * @param rotate Flag to rotate the child to mitered angle. Default is true.\n * @returns The parentModel, for cascading.\n */\nexport function childrenOnChain(parentModel: IModel, onChain: IChain, baseline = 0, reversed = false, contain = false, rotated = true) {\n    const result = getChildPlacement(parentModel, baseline);\n    const cpa = result.cpa;\n\n    let chainLength = onChain.pathLength;\n    let points: IPoint[]\n\n    if (cpa.length > 1) {\n        if (contain) chainLength -= result.firstX + result.lastX;\n\n        let absolutes = cpa.map(cp => (reversed ? 1 - cp.xRatio : cp.xRatio) * chainLength);\n        let relatives: number[];\n\n        if (reversed) absolutes.reverse();\n\n        relatives = absolutes.map((ab, i) => Math.abs(ab - (i == 0 ? 0 : absolutes[i - 1])));\n\n        if (contain) {\n            relatives[0] += reversed ? result.lastX : result.firstX;\n        } else {\n            relatives.shift();\n        }\n\n        //chain.toPoints always follows the chain in its order, from beginning to end. This is why we needed to contort the points input\n        points = chain.toPoints(onChain, relatives);\n\n        if (points.length < cpa.length) {\n            //add last point of chain, since our distances exceeded the chain\n            const endLink = onChain.links[onChain.links.length - 1];\n            points.push(endLink.endPoints[endLink.reversed ? 0 : 1]);\n        }\n\n        if (contain) points.shift(); //delete the first point which is the beginning of the chain\n\n    } else {\n        //get the first point and the middle point of the chain\n        points = chain.toPoints(onChain, 0.5 * chainLength);\n        points.length = 2;\n        //add the last point of the chain\n        points.push(onChain.links[onChain.links.length - 1].endPoints[onChain.links[onChain.links.length - 1].reversed ? 0 : 1]);\n    }\n\n    if (reversed) points.reverse();\n\n    const angles = miterAngles(points, -90);\n\n    if (cpa.length > 1) {\n        cpa.forEach((cp, i) => {\n            cp.angle = angles[i];\n            cp.origin = points[i];\n        });\n    } else {\n        //use the middle point\n        cpa[0].angle = angles[1];\n        cpa[0].origin = points[1];\n    }\n\n    moveAndRotate(parentModel, cpa, rotated);\n\n    return parentModel;\n}\n\n/**\n * Layout clones in a radial format.\n * \n * Example:\n * ```\n * //daisy petals\n * import * as makerjs from 'maker.js';\n *\n * const belt = new makerjs.models.Belt(5, 50, 20);\n *\n * makerjs.model.move(belt, [25, 0]);\n * \n * const petals = makerjs.layout.cloneToRadial(belt, 8, 45);\n * \n * document.write(makerjs.exporter.toSVG(petals));\n * ```\n * \n * @param itemToClone: Either a model or a path object.\n * @param count Number of clones in the radial result.\n * @param angleInDegrees angle of rotation between clones..\n * @returns A new model with clones in a radial format.\n */\nexport function cloneToRadial(itemToClone: IModel | IPath, count: number, angleInDegrees: number, rotationOrigin?: IPoint) {\n    const result: IModel = {};\n    let add: IPathMap | IModelMap;\n    let rotateFn: (x: IModel | IPath, angleInDegrees: number, rotationOrigin?: IPoint) => IModel | IPath;\n\n    if (isModel(itemToClone)) {\n        add = result.models = {};\n        rotateFn = model.rotate;\n    } else {\n        add = result.paths = {};\n        rotateFn = path.rotate;\n    }\n\n    for (let i = 0; i < count; i++) {\n        add[i] = rotateFn(cloneObject(itemToClone), i * angleInDegrees, rotationOrigin);\n    }\n\n    return result;\n}\n\n/**\n * @private\n */\nfunction cloneTo(dimension: number, itemToClone: IModel | IPath, count: number, margin: number): IModel {\n    const result: IModel = {};\n    let add: IPathMap | IModelMap;\n    let measureFn: (x: IModel | IPath) => IMeasure;\n    let moveFn: (x: IModel | IPath, origin: IPoint) => IModel | IPath;\n\n    if (isModel(itemToClone)) {\n        measureFn = measure.modelExtents;\n        add = result.models = {};\n        moveFn = model.move;\n    } else {\n        measureFn = measure.pathExtents;\n        add = result.paths = {};\n        moveFn = path.move;\n    }\n\n    const m = measureFn(itemToClone);\n    const size = m.high[dimension] - m.low[dimension];\n\n    for (let i = 0; i < count; i++) {\n        const origin: IPoint = [0, 0];\n        origin[dimension] = i * (size + margin);\n        add[i] = moveFn(cloneObject(itemToClone), origin);\n    }\n\n    return result;\n}\n\n/**\n * Layout clones in a column format.\n * \n * Example:\n * ```\n * //Grooves for a finger joint\n * import * as makerjs from 'maker.js';\n * \n * const dogbone = new makerjs.models.Dogbone(50, 20, 2, -1, false);\n * \n * const grooves = makerjs.layout.cloneToColumn(dogbone, 5, 20);\n * \n * document.write(makerjs.exporter.toSVG(grooves));\n * ```\n * \n * @param itemToClone: Either a model or a path object.\n * @param count Number of clones in the column.\n * @param margin Optional distance between each clone.\n * @returns A new model with clones in a column.\n */\nexport function cloneToColumn(itemToClone: IModel | IPath, count: number, margin = 0): IModel {\n    return cloneTo(1, itemToClone, count, margin);\n}\n\n/**\n * Layout clones in a row format.\n * \n * Example:\n * ```\n * //Tongue and grooves for a box joint\n * import * as makerjs from 'maker.js';\n * const tongueWidth = 60;\n * const grooveWidth = 50;\n * const grooveDepth = 30;\n * const groove = new makerjs.models.Dogbone(grooveWidth, grooveDepth, 5, 0, true);\n * \n * groove.paths['leftTongue'] = new makerjs.paths.Line([-tongueWidth / 2, 0], [0, 0]);\n * groove.paths['rightTongue'] = new makerjs.paths.Line([grooveWidth, 0], [grooveWidth + tongueWidth / 2, 0]);\n * \n * const tongueAndGrooves = makerjs.layout.cloneToRow(groove, 3);\n * \n * document.write(makerjs.exporter.toSVG(tongueAndGrooves));\n * ```\n * \n * @param itemToClone: Either a model or a path object.\n * @param count Number of clones in the row.\n * @param margin Optional distance between each clone.\n * @returns A new model with clones in a row.\n */\nexport function cloneToRow(itemToClone: IModel | IPath, count: number, margin = 0): IModel {\n    return cloneTo(0, itemToClone, count, margin);\n}\n\n/**\n * Layout clones in a grid format.\n * \n * Example:\n * ```\n * //Grid of squares\n * import * as makerjs from 'maker.js';\n * const square = new makerjs.models.Square(43);\n * const grid = makerjs.layout.cloneToGrid(square, 5, 5, 7);\n * document.write(makerjs.exporter.toSVG(grid));\n * ```\n * \n * @param itemToClone: Either a model or a path object.\n * @param xCount Number of columns in the grid.\n * @param yCount Number of rows in the grid.\n * @param margin Optional numeric distance between each clone. Can also be a 2 dimensional array of numbers, to specify distances in x and y dimensions.\n * @returns A new model with clones in a grid layout.\n */\nexport function cloneToGrid(itemToClone: IModel | IPath, xCount: number, yCount: number, margin?: number | IPoint): IModel {\n    const margins = getMargins(margin);\n    return cloneToColumn(cloneToRow(itemToClone, xCount, margins[0]), yCount, margins[1]);\n}\n\n/**\n * @private\n */\nfunction getMargins(margin?: number | IPoint): IPoint {\n    if (Array.isArray(margin)) {\n        return margin;\n    } else {\n        return [margin as number, margin as number];\n    }\n}\n\n/**\n * @private\n */\ninterface IGridSpacing {\n    x: number;\n    y: number;\n    xMargin: number;\n}\n\n/**\n * @private\n */\nfunction cloneToAlternatingRows(itemToClone: IModel | IPath, xCount: number, yCount: number, spacingFn: (modelToMeasure: IModel) => IGridSpacing): IModel {\n    let modelToMeasure: IModel;\n    if (isModel(itemToClone)) {\n        modelToMeasure = itemToClone;\n    } else {\n        modelToMeasure = { paths: { \"0\": itemToClone as IPath } };\n    }\n\n    const spacing = spacingFn(modelToMeasure);\n    const result: IModel = { models: {} };\n\n    for (let i = 0; i < yCount; i++) {\n        const i2 = i % 2;\n        result.models[i] = model.move(cloneToRow(itemToClone, xCount + i2, spacing.xMargin), [i2 * spacing.x, i * spacing.y]);\n    }\n\n    return result;\n}\n\n/**\n * Layout clones in a brick format. Alternating rows will have an additional item in each row.\n * \n * Examples:\n * ```\n * //Brick wall\n * import * as makerjs from 'maker.js';\n * const brick = new makerjs.models.RoundRectangle(50, 30, 4);\n * const wall = makerjs.layout.cloneToBrick(brick, 8, 6, 3);\n * document.write(makerjs.exporter.toSVG(wall));\n * ```\n * \n * ```\n * //Fish scales\n * import * as makerjs from 'maker.js';\n * const arc = new makerjs.paths.Arc([0, 0], 50, 20, 160);\n * const scales = makerjs.layout.cloneToBrick(arc, 8, 20);\n * document.write(makerjs.exporter.toSVG(scales));\n * ```\n * \n * @param itemToClone: Either a model or a path object.\n * @param xCount Number of columns in the brick grid.\n * @param yCount Number of rows in the brick grid.\n * @param margin Optional numeric distance between each clone. Can also be a 2 dimensional array of numbers, to specify distances in x and y dimensions.\n * @returns A new model with clones in a brick layout.\n */\nexport function cloneToBrick(itemToClone: IModel | IPath, xCount: number, yCount: number, margin?: number | IPoint): IModel {\n\n    const margins = getMargins(margin);\n\n    function spacing(modelToMeasure: IModel): IGridSpacing {\n        const m = measure.modelExtents(modelToMeasure);\n        const xMargin = margins[0] || 0;\n        const yMargin = margins[1] || 0;\n        return { x: (m.width + xMargin) / -2, y: m.height + yMargin, xMargin: xMargin };\n    }\n\n    return cloneToAlternatingRows(itemToClone, xCount, yCount, spacing);\n}\n\n/**\n * Layout clones in a honeycomb format. Alternating rows will have an additional item in each row.\n * \n * Examples:\n * ```\n * //Honeycomb\n * import * as makerjs from 'maker.js';\n * const hex = new makerjs.models.Polygon(6, 50, 30);\n * const pattern = makerjs.layout.cloneToHoneycomb(hex, 8, 9, 10);\n * document.write(makerjs.exporter.toSVG(pattern));\n * ```\n * \n * @param itemToClone: Either a model or a path object.\n * @param xCount Number of columns in the honeycomb grid.\n * @param yCount Number of rows in the honeycomb grid.\n * @param margin Optional distance between each clone.\n * @returns A new model with clones in a honeycomb layout.\n */\nexport function cloneToHoneycomb(itemToClone: IModel | IPath, xCount: number, yCount: number, margin = 0): IModel {\n\n    function spacing(modelToMeasure: IModel): IGridSpacing {\n        const hex = measure.boundingHexagon(modelToMeasure);\n        const width = 2 * solvers.equilateralAltitude(hex.radius);\n        const s = width + margin;\n        return { x: s / -2, y: solvers.equilateralAltitude(s), xMargin: margin };\n    }\n\n    return cloneToAlternatingRows(itemToClone, xCount, yCount, spacing);\n}\n","// Export models (all 17 converted classes)\nexport * from './models/index.js';\n\n// Export commonly used utility functions at top level for convenience\nexport { round } from './core/maker.js';\n\n// Export functional composition utilities\nexport { pipe, compose } from './core/functional.js';\n\n// Export legacy cascade API (deprecated - use pipe/compose for new code)\nexport { $ } from './core/maker.js';\n\n// Export utilities\nexport * as schema from './core/schema.js';\nexport * as maker from './core/maker.js';\nexport * as angle from './core/angle.js';\nexport * as point from './core/point.js';\nexport * as path from './core/path.js';\nexport * as paths from './core/paths.js';\n\n// Register modules for cascade functionality (must be after imports)\nimport { registerCascadeModules } from './core/maker.js';\nimport * as _model from './core/model.js';\nimport * as _path from './core/path.js';\nimport * as _point from './core/point.js';\nregisterCascadeModules(_model, _path, _point);\nexport * as units from './core/units.js';\nexport * as equal from './core/equal.js';\nexport * as collect from './core/collect.js';\nexport * as model from './core/model.js';\nexport * as measure from './core/measure.js';\nexport * as exporter from './core/exporter-index.js';\nexport * as importer from './core/importer.js';\nexport * as intersect from './core/intersect.js';\n\n// Chain finding and manipulation\nexport * as chain from './core/chain.js';\n\n// Fillet operations (ES module migration)\nexport * as fillet from './core/fillet-path.js';\nexport * as filletChain from './core/fillet-chain.js';\n\n// Dead-end utilities (ES module migration)\nexport * as deadend from './core/deadend.js';\n\n// XML utilities\nexport { XmlTag, type IXmlTagAttrs } from './core/xml.js';\n\n// Serializers (ES module migration in progress)\nexport * as dxf from './core/dxf.js';\nexport * as svg from './core/svg-esm.js';\nexport * as pdf from './core/pdf-esm.js';\nexport * as openjscad from './core/openjscad-esm.js';\n\n// Model classes converted to ES modules\nexport * as models from './models/index.js';\n\n// Layout utilities (ES module migration)\nexport * as layout from './core/layout.js';\n\n// TODO: progressively export remaining modules\n// export * as break from './core/break.js';\n// export * as cascades from './core/cascades.js'; // Generated file - needs build script update\n"],"names":["value","model","point.subtract","mirror","point.fromArc","point.rotate","point.add","unitType","angle.noRevolutions","path.moveTemporary","pointDistance","onPathMap","angle.ofPointInDegrees","path.clone","angle.toDegrees","path.rotate","getExtremePoint","pathExtentsMap","isBetweenArcAngles","angle.ofArcSpan","isBetween","exclusive","pathExtents","pathLengthMap","pathLength","increase","augment","point.average","modelExtents","measure","model.walk","measure.pointDistance","chain","findSingleChain","findChains","layer","measure.pathLength","measure.isPointEqual","point.fromPathEnds","model.getSimilarPathId","path.moveRelative","toPoints","point.middle","toKeyPoints","path.toKeyPoints","middle","paths.Arc","equal.isPointEqual","point.fromAngleOnCircle","paths.Line","base","chain.reverse","measure.isBezierSeedLinear","point.clone","clone","chain.findChains","chainFindChains","chainFindSingleChain","point.zero","addTo","map","center","measure.modelExtents","point.mirror","path.mirror","move","moveRelative","rotate","scale","point.scale","path.scale","path.distort","distort","point.distort","units.isValidUnit","units.conversionScale","modelContext","zero","model.addPath","paths.Circle","angle.mirror","angle.ofArcEnd","subtract","point.fromSlopeIntersection","point.closest","useOrigin","model.findChains","measure.isArcOverlapping","measure.isBetweenPoints","measure.isBetweenArcAngles","angle.ofLineInDegrees","measure.isBetween","solvers.solveTriangleSSS","a","paths.Chord","isBetweenPoints","chain.toKeyPoints","add","models.BezierCurve","model.rotate","solvers.equilateralSide","solvers.equilateralAltitude","model.originate","model.center","models.Polygon","p","i","path.converge","angle.toRadians","measure.lineSlope","equal.isSlopeParallel","equal.isSlopeEqual","measure.isLineOverlapping","angle.ofArcMiddle","angle.ofPointInRadians","point.fromPolar","path.move","solvers.circleTangentAngles","path","path.copyProps","combine","combineModels","addPath","addModel","point.rounded","name","models","pathToData","chainToData","model.getAllCaptionsOffset","measure.increase","measure.pathExtents","svgArcData","svgBezierData","measure.isArcConcaveTowardsPoint","angle.ofChainLinkJoint","removeDeadEnds","colorLayerOptions","units","walkedPaths","dxf","table","model.scale","reverse","union","measure.Atlas","measure.augment","path.alterLength","chain.toPoints","model.move","measure.boundingHexagon"],"mappings":"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"}