---
ai_summary: 'You can combine models using the model.combine function, passing these
  parameters:'
category: General
description: 'You can combine models using the model.combine function, passing these
  parameters:'
difficulty: intermediate
keywords:
- combining
- export
- general
- geometry
- javascript
- models
- paths
- photon
- photon/core
- svg
primary_topic: combining
source: docs/_snippets/combining.html
tags:
- intermediate
- combining
- general
title: Combining
---
You can combine models using the [model.combine](/docs/api/modules/model.md#combine) function, passing these parameters:

* first model to combine, we'll call it "modelA"
* second model to combine, we'll call it "modelB"
* boolean to include modelA's paths which are inside of modelB
* boolean to include modelA's paths which are outside of modelB
* boolean to include modelB's paths which are inside of modelA
* boolean to include modelB's paths which are outside of modelA

Each model must be a closed geometry, and should not be self-intersecting. The effect of the 4 boolean parameters is shown in these examples:

## Examples

```javascript
//combine a rectangle and an oval, several ways
import { exporter, model, models } from '@7syllable/photon-core';
function example(origin) {
this.models = {
rect: new models.Rectangle(100, 50),
oval: model.move(new models.Oval(100, 50), [50, 25])
};
this.origin = origin;
}
const examples = {
models: {
x1: new example([0, 0]),
x2: new example([200, 0]),
x3: new example([400, 0]),
x4: new example([500, 0])
}
};
//save us some typing :)
const x = examples.models;
model.combine(x.x2.models.rect, x.x2.models.oval, false, true, false, true);
model.combine(x.x3.models.rect, x.x3.models.oval, false, true, true, false);
model.combine(x.x4.models.rect, x.x4.models.oval, true, false, true, false);
const svg = exporter.toSVG(examples);
document.write(svg);
```


---

Instead of remembering the boolean flag combinations, shortcuts are provided for:

* [model.combineIntersection](/docs/api/modules/model.md#combineintersection)
* [model.combineSubtraction](/docs/api/modules/model.md#combinesubtraction)
* [model.combineUnion](/docs/api/modules/model.md#combineunion)

```javascript
//combine a rectangle and an oval, several ways
import { exporter, model, models } from '@7syllable/photon-core';
function example(origin) {
this.models = {
rect: new models.Rectangle(100, 50),
oval: model.move(new models.Oval(100, 50), [50, 25])
};
this.origin = origin;
}
const examples = {
models: {
x1: new example([0, 0]),
x2: new example([200, 0]),
x3: new example([400, 0]),
x4: new example([500, 0])
}
};
//save us some typing :)
const x = examples.models;
model.combineUnion(x.x2.models.rect, x.x2.models.oval);
model.combineSubtraction(x.x3.models.rect, x.x3.models.oval);
model.combineIntersection(x.x4.models.rect, x.x4.models.oval);
const svg = exporter.toSVG(examples);
document.write(svg);
```
Now it is apparent why we need a closed geometry - because we need to know what is considered the inside of a model.

#### Return value

These function will return a new model object with 2 child models, **"a"** and **"b"** which are aliases for the 2 models you passed in.
